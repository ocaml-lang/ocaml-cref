<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/unix.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/unix.c - ocaml</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L122">caml_decompose_path</a></li>
<li><a href="#L250">caml_dlclose</a></li>
<li><a href="#L285">caml_dlclose</a></li>
<li><a href="#L317">caml_dlclose</a></li>
<li><a href="#L265">caml_dlerror</a></li>
<li><a href="#L304">caml_dlerror</a></li>
<li><a href="#L331">caml_dlerror</a></li>
<li><a href="#L244">caml_dlopen</a></li>
<li><a href="#L280">caml_dlopen</a></li>
<li><a href="#L312">caml_dlopen</a></li>
<li><a href="#L255">caml_dlsym</a></li>
<li><a href="#L290">caml_dlsym</a></li>
<li><a href="#L321">caml_dlsym</a></li>
<li><a href="#L365">caml_executable_name</a></li>
<li><a href="#L260">caml_globalsym</a></li>
<li><a href="#L295">caml_globalsym</a></li>
<li><a href="#L326">caml_globalsym</a></li>
<li><a href="#L479">caml_init_os_params</a></li>
<li><a href="#L465">caml_num_rows_fd</a></li>
<li><a href="#L566">caml_plat_mem_commit</a></li>
<li><a href="#L577">caml_plat_mem_decommit</a></li>
<li><a href="#L500">caml_plat_mem_map</a></li>
<li><a href="#L540">caml_plat_mem_map</a></li>
<li><a href="#L582">caml_plat_mem_unmap</a></li>
<li><a href="#L342">caml_read_directory</a></li>
<li><a href="#L86">caml_read_fd</a></li>
<li><a href="#L228">caml_search_dll_in_path</a></li>
<li><a href="#L210">caml_search_exe_in_path</a></li>
<li><a href="#L141">caml_search_in_path</a></li>
<li><a href="#L414">caml_secure_getenv</a></li>
<li><a href="#L433">caml_time_counter</a></li>
<li><a href="#L99">caml_write_fd</a></li>
<li><a href="#L168">cygwin_file_exists</a></li>
<li><a href="#L180">cygwin_search_exe_in_path</a></li>
<li><a href="#L522">map_fixed</a></li>
<li><a href="#L555">map_fixed</a></li>
<li><a href="#L490">safe_munmap</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L16">CAML_INTERNALS</a></li>
<li><a href="#L80">EAGAIN</a></li>
<li><a href="#L77">EINTR</a></li>
<li><a href="#L83">EWOULDBLOCK</a></li>
<li><a href="#L274">RTLD_GLOBAL</a></li>
<li><a href="#L277">RTLD_LOCAL</a></li>
<li><a href="#L73">S_ISREG</a></li>
<li><a href="#L36">WITH_DYNAMIC_LINKING</a></li>
<li><a href="#L20">_GNU_SOURCE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2001 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Unix-specific stuff */<br/></li>
<li></span><br/></li>
<li><a id="L20">&#x200c;</a><span class="PreProc">#define <span class="linkable">_GNU_SOURCE</span><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* Helps finding RTLD_DEFAULT in glibc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* also secure_getenv */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;stddef.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/ioctl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#if defined(SUPPORT_DYNAMIC_LINKING) &amp;&amp; !defined(BUILDING_LIBCAMLRUNS)<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WITH_DYNAMIC_LINKING</span><br/></li>
<li></span><span class="PreProc">#ifdef __CYGWIN__<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;flexdll.h&quot;<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;dlfcn.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAS_UNISTD<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAS_POSIX_MONOTONIC_CLOCK<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#elif HAS_MACH_ABSOLUTE_TIME<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;mach/mach_time.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAS_DIRENT<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;dirent.h&gt;<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/dir.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef __APPLE__<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;mach-o/dyld.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAS_SYS_MMAN_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/osdeps.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/signals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/sys.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/io.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/platform.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L73" title="ocaml/runtime/unix.c:73">S_ISREG</a><br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">S_ISREG</span>(mode) (((mode) &amp; S_IFMT) == S_IFREG)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L77" title="ocaml/runtime/unix.c:77">EINTR</a><br/></li>
<li><a id="L77">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">EINTR</span></span><span class="PreProc"> (-</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="sys.c.html#L87" title="ocaml/runtime/sys.c:87">EAGAIN</a><br/></li>
<li><a id="L80">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">EAGAIN</span></span><span class="PreProc"> (-</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="sys.c.html#L90" title="ocaml/runtime/sys.c:90">EWOULDBLOCK</a><br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">EWOULDBLOCK</span></span><span class="PreProc"> (-</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L86">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_read_fd</span>(<span class="Type">int</span> fd, <span class="Type">int</span> flags, <span class="Type">void</span> * buf, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode;<br/></li>
<li>&nbsp; <a href="signals.c.html#L161" title="ocaml/runtime/signals.c:161">caml_enter_blocking_section_no_pending</a>();<br/></li>
<li>&nbsp; retcode = read(fd, buf, n);<br/></li>
<li>&nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant"><a href="#L77" title="ocaml/runtime/unix.c:77">EINTR</a></span>) <span class="Statement">return</span> <a href="caml/osdeps.h.html#L35" title="ocaml/runtime/caml/osdeps.h:35">Io_interrupted</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <a href="sys.c.html#L115" title="ocaml/runtime/sys.c:115">caml_sys_io_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> retcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L99">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_write_fd</span>(<span class="Type">int</span> fd, <span class="Type">int</span> flags, <span class="Type">void</span> * buf, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode;<br/></li>
<li> <span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="signals.c.html#L161" title="ocaml/runtime/signals.c:161">caml_enter_blocking_section_no_pending</a>();<br/></li>
<li>&nbsp; retcode = write(fd, buf, n);<br/></li>
<li>&nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant"><a href="#L77" title="ocaml/runtime/unix.c:77">EINTR</a></span>) <span class="Statement">return</span> <a href="caml/osdeps.h.html#L35" title="ocaml/runtime/caml/osdeps.h:35">Io_interrupted</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((errno == <span class="Constant"><a href="sys.c.html#L87" title="ocaml/runtime/sys.c:87">EAGAIN</a></span> || errno == <span class="Constant"><a href="sys.c.html#L90" title="ocaml/runtime/sys.c:90">EWOULDBLOCK</a></span>) &amp;&amp; n &gt; <span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* We couldn't do a partial write here, probably because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; n &lt;= PIPE_BUF <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> POSIX says that writes of less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PIPE_BUF characters must be atomic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; We first try again with a partial write of 1 character.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; If that fails too, we'll return an <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> code. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; n = <span class="Constant">1</span>; <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span>) <a href="sys.c.html#L115" title="ocaml/runtime/sys.c:115">caml_sys_io_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (retcode &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> retcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L122">&#x200c;</a><a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">caml_decompose_path</span>(<span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * tbl, <span class="Type">char</span> * path)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">char</span> * p, * q;<br/></li>
<li>&nbsp; <span class="Type">size_t</span> n;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (path == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; p = <a href="memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>(path);<br/></li>
<li>&nbsp; q = p;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (n = <span class="Constant">0</span>; q[n] != <span class="Constant">0</span> &amp;&amp; q[n] != <span class="Constant">':'</span>; n++) <span class="Comment">/*nothing*/</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L146" title="ocaml/runtime/misc.c:146">caml_ext_table_add</a>(tbl, q);<br/></li>
<li>&nbsp; &nbsp; q = q + n;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*q == <span class="Constant">0</span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; *q = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; q += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L141">&#x200c;</a><a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">caml_search_in_path</span>(<span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * path, <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">char</span> * p;<br/></li>
<li>&nbsp; <span class="Type">char</span> * dir, * fullname;<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (p = name; *p != <span class="Constant">0</span>; p++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'/'</span>) <span class="Statement">goto</span> not_found;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;size; i++) {<br/></li>
<li>&nbsp; &nbsp; dir = path-&gt;contents[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dir[<span class="Constant">0</span>] == <span class="Constant">0</span>) dir = <span class="Constant">&quot;.&quot;</span>;&nbsp; <span class="Comment">/* empty path component = current dir */<br/></li>
<li></span>&nbsp; &nbsp; fullname = <a href="memory.c.html#L654" title="ocaml/runtime/memory.c:654">caml_stat_strconcat</a>(<span class="Constant">3</span>, dir, <span class="Constant">&quot;/&quot;</span>, name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(fullname, &amp;st) == <span class="Constant">0</span> &amp;&amp; <a href="#L73" title="ocaml/runtime/unix.c:73">S_ISREG</a>(st.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fullname;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(fullname);<br/></li>
<li>&nbsp; }<br/></li>
<li> <span class="Statement">not_found</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <a href="memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>(name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef __CYGWIN__<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Cygwin needs special treatment because of the implicit &quot;.exe&quot; at the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; end of executable file names */<br/></li>
<li></span><br/></li>
<li><a id="L168">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">cygwin_file_exists</span>(<span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> fd, ret;<br/></li>
<li>&nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li>&nbsp; <span class="Comment">/* Cannot use stat() here because it adds &quot;.exe&quot; implicitly */<br/></li>
<li></span>&nbsp; fd = open(name, O_RDONLY);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (fd == -<span class="Constant">1</span>) <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; ret = fstat(fd, &amp;st);<br/></li>
<li>&nbsp; close(fd);<br/></li>
<li>&nbsp; <span class="Statement">return</span> ret == <span class="Constant">0</span> &amp;&amp; <a href="#L73" title="ocaml/runtime/unix.c:73">S_ISREG</a>(st.st_mode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L180">&#x200c;</a><span class="Type">static</span> <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">cygwin_search_exe_in_path</span>(<span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">char</span> * p;<br/></li>
<li>&nbsp; <span class="Type">char</span> * dir, * fullname;<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (p = name; *p != <span class="Constant">0</span>; p++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'/'</span> || *p == <span class="Special">'\\'</span>) <span class="Statement">goto</span> not_found;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;size; i++) {<br/></li>
<li>&nbsp; &nbsp; dir = path-&gt;contents[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dir[<span class="Constant">0</span>] == <span class="Constant">0</span>) dir = <span class="Constant">&quot;.&quot;</span>;&nbsp; <span class="Comment">/* empty path component = current dir */<br/></li>
<li></span>&nbsp; &nbsp; fullname = <a href="memory.c.html#L654" title="ocaml/runtime/memory.c:654">caml_stat_strconcat</a>(<span class="Constant">3</span>, dir, <span class="Constant">&quot;/&quot;</span>, name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L168" title="ocaml/runtime/unix.c:168">cygwin_file_exists</a>(fullname)) <span class="Statement">return</span> fullname;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(fullname);<br/></li>
<li>&nbsp; &nbsp; fullname = <a href="memory.c.html#L654" title="ocaml/runtime/memory.c:654">caml_stat_strconcat</a>(<span class="Constant">4</span>, dir, <span class="Constant">&quot;/&quot;</span>, name, <span class="Constant">&quot;.exe&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L168" title="ocaml/runtime/unix.c:168">cygwin_file_exists</a>(fullname)) <span class="Statement">return</span> fullname;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(fullname);<br/></li>
<li>&nbsp; }<br/></li>
<li> <span class="Statement">not_found</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L168" title="ocaml/runtime/unix.c:168">cygwin_file_exists</a>(name)) <span class="Statement">return</span> <a href="memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>(name);<br/></li>
<li>&nbsp; fullname = <a href="memory.c.html#L654" title="ocaml/runtime/memory.c:654">caml_stat_strconcat</a>(<span class="Constant">2</span>, name, <span class="Constant">&quot;.exe&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L168" title="ocaml/runtime/unix.c:168">cygwin_file_exists</a>(fullname)) <span class="Statement">return</span> fullname;<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(fullname);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>(name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L210">&#x200c;</a><a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">caml_search_exe_in_path</span>(<span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> path;<br/></li>
<li>&nbsp; <span class="Type">char</span> * tofree;<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> res;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L139" title="ocaml/runtime/misc.c:139">caml_ext_table_init</a>(&amp;path, <span class="Constant">8</span>);<br/></li>
<li>&nbsp; tofree = <a href="#L122" title="ocaml/runtime/unix.c:122">caml_decompose_path</a>(&amp;path, getenv(<span class="Constant">&quot;PATH&quot;</span>));<br/></li>
<li><span class="PreProc">#ifndef __CYGWIN__<br/></li>
<li></span>&nbsp; res = <a href="#L141" title="ocaml/runtime/unix.c:141">caml_search_in_path</a>(&amp;path, name);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; res = <a href="#L180" title="ocaml/runtime/unix.c:180">cygwin_search_exe_in_path</a>(&amp;path, name);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(tofree);<br/></li>
<li>&nbsp; <a href="misc.c.html#L182" title="ocaml/runtime/misc.c:182">caml_ext_table_free</a>(&amp;path, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L228">&#x200c;</a><a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">caml_search_dll_in_path</span>(<span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> dllname;<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> res;<br/></li>
<li><br/></li>
<li>&nbsp; dllname = <a href="memory.c.html#L654" title="ocaml/runtime/memory.c:654">caml_stat_strconcat</a>(<span class="Constant">2</span>, name, <span class="Constant">&quot;.so&quot;</span>);<br/></li>
<li>&nbsp; res = <a href="#L141" title="ocaml/runtime/unix.c:141">caml_search_in_path</a>(path, dllname);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(dllname);<br/></li>
<li>&nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="#L36" title="ocaml/runtime/unix.c:36">WITH_DYNAMIC_LINKING</a><br/></li>
<li></span><span class="PreProc">#ifdef __CYGWIN__<br/></li>
<li></span><span class="Comment">/* Use flexdll */<br/></li>
<li></span><br/></li>
<li><a id="L244">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlopen</span>(<span class="Type">char</span> * libname, <span class="Type">int</span> global)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> flags = (global ? FLEXDLL_RTLD_GLOBAL : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> flexdll_dlopen(libname, flags);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L250">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_dlclose</span>(<span class="Type">void</span> * handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; flexdll_dlclose(handle);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L255">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlsym</span>(<span class="Type">void</span> * handle, <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> flexdll_dlsym(handle, name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L260">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_globalsym</span>(<span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> flexdll_dlsym(flexdll_dlopen(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<span class="Constant">0</span>), name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L265">&#x200c;</a><span class="Type">char</span> * <span class="linkable">caml_dlerror</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> flexdll_dlerror();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else</span> <span class="Comment">/* ! __CYGWIN__ */<br/></li>
<li></span><span class="Comment">/* Use normal dlopen */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L274" title="ocaml/runtime/unix.c:274">RTLD_GLOBAL</a><br/></li>
<li><a id="L274">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RTLD_GLOBAL</span> </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L277" title="ocaml/runtime/unix.c:277">RTLD_LOCAL</a><br/></li>
<li><a id="L277">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RTLD_LOCAL</span> </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L280">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlopen</span>(<span class="Type">char</span> * libname, <span class="Type">int</span> global)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> dlopen(libname, RTLD_NOW | (global ? <a href="#L274" title="ocaml/runtime/unix.c:274">RTLD_GLOBAL</a> : <a href="#L277" title="ocaml/runtime/unix.c:277">RTLD_LOCAL</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L285">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_dlclose</span>(<span class="Type">void</span> * handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; dlclose(handle);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L290">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlsym</span>(<span class="Type">void</span> * handle, <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> dlsym(handle, name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L295">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_globalsym</span>(<span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef RTLD_DEFAULT<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <a href="#L255" title="ocaml/runtime/unix.c:255">caml_dlsym</a>(RTLD_DEFAULT, name);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L304">&#x200c;</a><span class="Type">char</span> * <span class="linkable">caml_dlerror</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<span class="Type">char</span>*) dlerror();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* __CYGWIN__ */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li><a id="L312">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlopen</span>(<span class="Type">char</span> * libname, <span class="Type">int</span> global)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L317">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_dlclose</span>(<span class="Type">void</span> * handle)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L321">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlsym</span>(<span class="Type">void</span> * handle, <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L326">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_globalsym</span>(<span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L331">&#x200c;</a><span class="Type">char</span> * <span class="linkable">caml_dlerror</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">&quot;dynamic loading not supported on this platform&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="#L36" title="ocaml/runtime/unix.c:36">WITH_DYNAMIC_LINKING</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Add to [contents] the (short) names of the files contained in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the directory named [dirname].&nbsp; No entries are added for [.] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [..].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Return 0 on success, -1 on <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>; set errno in the case of <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>. */<br/></li>
<li></span><br/></li>
<li><a id="L342">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_read_directory</span>(<span class="Type">char</span> * dirname, <span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * contents)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">DIR</span> * d;<br/></li>
<li><span class="PreProc">#ifdef HAS_DIRENT<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> dirent * e;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> direct * e;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; d = opendir(dirname);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (d == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; e = readdir(d);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (e == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(e-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> || strcmp(e-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>) <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L146" title="ocaml/runtime/misc.c:146">caml_ext_table_add</a>(contents, <a href="memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>(e-&gt;d_name));<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; closedir(d);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Recover executable name from /proc/self/exe if possible */<br/></li>
<li></span><br/></li>
<li><a id="L365">&#x200c;</a><span class="Type">char</span> * <span class="linkable">caml_executable_name</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(__linux__)<br/></li>
<li></span>&nbsp; <span class="Type">int</span> namelen, retcode;<br/></li>
<li>&nbsp; <span class="Type">char</span> * name;<br/></li>
<li>&nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* lstat(&quot;/proc/self/exe&quot;) returns st_size == 0 so we cannot use it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; to determine the size of the buffer.&nbsp; Instead, we guess <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> adjust. */<br/></li>
<li></span>&nbsp; namelen = <span class="Constant">256</span>;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; name = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(namelen);<br/></li>
<li>&nbsp; &nbsp; retcode = readlink(<span class="Constant">&quot;/proc/self/exe&quot;</span>, name, namelen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span>) { <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(name); <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode &lt; namelen) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (namelen &gt;= <span class="Constant">1024</span>*<span class="Constant">1024</span>) <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>; <span class="Comment">/* avoid runaway <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> overflow */<br/></li>
<li></span>&nbsp; &nbsp; namelen *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* readlink() does not zero-terminate its result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; There is room for a <a href="caml/finalise.h.html#L24" title="ocaml/runtime/caml/finalise.h:24">final</a> zero since retcode &lt; namelen. */<br/></li>
<li></span>&nbsp; name[retcode] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Comment">/* Make sure that the contents of /proc/self/exe is a regular file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; (Old Linux kernels return an inode number instead.) */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (stat(name, &amp;st) == -<span class="Constant">1</span> || ! <a href="#L73" title="ocaml/runtime/unix.c:73">S_ISREG</a>(st.st_mode)) {<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(name); <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> name;<br/></li>
<li><br/></li>
<li><span class="PreProc">#elif defined(__APPLE__)<br/></li>
<li></span>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> namelen;<br/></li>
<li>&nbsp; <span class="Type">char</span> * name;<br/></li>
<li><br/></li>
<li>&nbsp; namelen = <span class="Constant">256</span>;<br/></li>
<li>&nbsp; name = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(namelen);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (_NSGetExecutablePath(name, &amp;namelen) == <span class="Constant">0</span>) <span class="Statement">return</span> name;<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(name);<br/></li>
<li>&nbsp; <span class="Comment">/* Buffer is too small, but namelen now contains the size needed */<br/></li>
<li></span>&nbsp; name = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(namelen);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (_NSGetExecutablePath(name, &amp;namelen) == <span class="Constant">0</span>) <span class="Statement">return</span> name;<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(name);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L414">&#x200c;</a><span class="Type">char</span> *<span class="linkable">caml_secure_getenv</span> (<span class="Type">char</span> <span class="Type">const</span> *var)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAS_SECURE_GETENV<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> secure_getenv (var);<br/></li>
<li><span class="PreProc">#elif defined (HAS___SECURE_GETENV)<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> __secure_getenv (var);<br/></li>
<li><span class="PreProc">#elif defined(HAS_ISSETUGID)<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (!issetugid ())<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> getenv(var);<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (geteuid () == getuid () &amp;&amp; getegid () == getgid ())<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> getenv(var);<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L433">&#x200c;</a><span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> <span class="linkable">caml_time_counter</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(HAS_MACH_ABSOLUTE_TIME)<br/></li>
<li></span>&nbsp; <span class="Type">static</span> mach_timebase_info_data_t time_base = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; <span class="Type"><a href="caml/config.h.html#L128" title="ocaml/runtime/caml/config.h:128">uint64_t</a></span> now;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (time_base.denom == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mach_timebase_info(&amp;time_base) != KERN_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; now = mach_absolute_time();<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)((now * time_base.numer) / time_base.denom);<br/></li>
<li><span class="PreProc">#elif defined(HAS_POSIX_MONOTONIC_CLOCK)<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> timespec t;<br/></li>
<li>&nbsp; clock_gettime(CLOCK_MONOTONIC, &amp;t);<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)t.tv_sec&nbsp; * (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)<span class="Constant">1000000000</span> +<br/></li>
<li>&nbsp; &nbsp; (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)t.tv_nsec;<br/></li>
<li><span class="PreProc">#elif defined(HAS_GETTIMEOFDAY)<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> timeval t;<br/></li>
<li>&nbsp; gettimeofday(&amp;t, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)t.tv_sec&nbsp; * (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)<span class="Constant">1000000000</span> +<br/></li>
<li>&nbsp; &nbsp; (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)t.tv_usec * (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)<span class="Constant">1000</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc"># <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> </span><span class="Constant">&quot;No timesource available&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L465">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_num_rows_fd</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef TIOCGWINSZ<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> winsize w;<br/></li>
<li>&nbsp; w.ws_row = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ioctl(fd, TIOCGWINSZ, &amp;w) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> w.ws_row;<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L479">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_init_os_params</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="platform.c.html#L142" title="ocaml/runtime/platform.c:142">caml_plat_mmap_alignment</a> = <a href="platform.c.html#L141" title="ocaml/runtime/platform.c:141">caml_plat_pagesize</a> = sysconf(_SC_PAGESIZE);<br/></li>
<li>&nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef __CYGWIN__<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Standard Unix implementation: reserve with mmap (<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> trim to alignment) with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; commit done using mmap as well. */<br/></li>
<li></span><br/></li>
<li><a id="L490">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">safe_munmap</span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> addr, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (size &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a>(<span class="Constant">0x1000</span>, <span class="Constant">&quot;munmap %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; bytes at %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;x&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; for heaps</span><span class="Special">\n</span><span class="Constant">&quot;</span>, size, addr);<br/></li>
<li>&nbsp; &nbsp; munmap((<span class="Type">void</span>*)addr, size);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L500">&#x200c;</a><span class="Type">void</span> *<span class="linkable">caml_plat_mem_map</span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> alignment, <span class="Type">int</span> reserve_only)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> alloc_sz = size + alignment;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> base, aligned_start, aligned_end;<br/></li>
<li>&nbsp; <span class="Type">void</span>* mem;<br/></li>
<li><br/></li>
<li>&nbsp; mem = mmap(<span class="Constant">0</span>, alloc_sz, reserve_only ? PROT_NONE : (PROT_READ | PROT_WRITE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAP_PRIVATE | <a href="caml/platform.h.html#L31" title="ocaml/runtime/caml/platform.h:31">MAP_ANONYMOUS</a>, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (mem == MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* trim to an aligned region */<br/></li>
<li></span>&nbsp; base = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)mem;<br/></li>
<li>&nbsp; aligned_start = (base + alignment - <span class="Constant">1</span>) &amp; ~(alignment - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; aligned_end = aligned_start + size;<br/></li>
<li>&nbsp; <a href="#L490" title="ocaml/runtime/unix.c:490">safe_munmap</a>(base, aligned_start - base);<br/></li>
<li>&nbsp; <a href="#L490" title="ocaml/runtime/unix.c:490">safe_munmap</a>(aligned_end, (base + alloc_sz) - aligned_end);<br/></li>
<li>&nbsp; mem = (<span class="Type">void</span>*)aligned_start;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> mem;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L522">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span>* <span class="linkable">map_fixed</span>(<span class="Type">void</span>* mem, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size, <span class="Type">int</span> prot)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (mmap(mem, size, prot, MAP_PRIVATE | <a href="caml/platform.h.html#L31" title="ocaml/runtime/caml/platform.h:31">MAP_ANONYMOUS</a> | MAP_FIXED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>, <span class="Constant">0</span>) == MAP_FAILED) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mem;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Cygwin implementation: memory reserved using mmap, but relying on the large<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; allocation granularity of the underlying Windows VirtualAlloc call to ensure<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; alignment (since on Windows it is not possible to trim the region). Commit<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; done using mprotect, since Cygwin's mmap doesn't implement the required<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; functions for committing using mmap. */<br/></li>
<li></span><br/></li>
<li><a id="L540">&#x200c;</a><span class="Type">void</span> *<span class="linkable">caml_plat_mem_map</span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> alignment, <span class="Type">int</span> reserve_only)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span>* mem;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (alignment &gt; <a href="platform.c.html#L142" title="ocaml/runtime/platform.c:142">caml_plat_mmap_alignment</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Cannot align memory to </span><span class="Special">%lx</span><span class="Constant"> on this platform&quot;</span>, alignment);<br/></li>
<li><br/></li>
<li>&nbsp; mem = mmap(<span class="Constant">0</span>, size, reserve_only ? PROT_NONE : (PROT_READ | PROT_WRITE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAP_PRIVATE | <a href="caml/platform.h.html#L31" title="ocaml/runtime/caml/platform.h:31">MAP_ANONYMOUS</a>, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (mem == MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> mem;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L555">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span>* <span class="linkable">map_fixed</span>(<span class="Type">void</span>* mem, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size, <span class="Type">int</span> prot)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (mprotect(mem, size, prot) != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mem;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* !__CYGWIN__ */<br/></li>
<li></span><br/></li>
<li><a id="L566">&#x200c;</a><span class="Type">void</span>* <span class="linkable">caml_plat_mem_commit</span>(<span class="Type">void</span>* mem, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span>* p = <a href="#L522" title="ocaml/runtime/unix.c:522">map_fixed</a>(mem, size, PROT_READ | PROT_WRITE);<br/></li>
<li>&nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; </span><span class="Todo">FIXME</span><span class="Comment">: On Linux, it might be useful to populate page tables with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; MAP_POPULATE to reduce the time spent blocking on page faults at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; a later point.<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L577">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_plat_mem_decommit</span>(<span class="Type">void</span>* mem, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L522" title="ocaml/runtime/unix.c:522">map_fixed</a>(mem, size, PROT_NONE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L582">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_plat_mem_unmap</span>(<span class="Type">void</span>* mem, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (munmap(mem, size) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
