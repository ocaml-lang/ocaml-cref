<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/backtrace_byt.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/backtrace_byt.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L50">caml_cds_file</a></li>
<li><a href="#L48">caml_debug_info</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L76">debug_info</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L377">alloc_callstack</a></li>
<li><a href="#L201">caml_add_debug_info</a></li>
<li><a href="#L249">caml_alloc_backtrace_buffer</a></li>
<li><a href="#L497">caml_debug_info_available</a></li>
<li><a href="#L502">caml_debug_info_status</a></li>
<li><a href="#L579">caml_debuginfo_extract</a></li>
<li><a href="#L558">caml_debuginfo_location</a></li>
<li><a href="#L584">caml_debuginfo_next</a></li>
<li><a href="#L547">caml_exact_event_for_location</a></li>
<li><a href="#L258">caml_free_backtrace_buffer</a></li>
<li><a href="#L399">caml_get_continuation_callstack</a></li>
<li><a href="#L389">caml_get_current_callstack</a></li>
<li><a href="#L484">caml_init_debug_info</a></li>
<li><a href="#L490">caml_load_main_debug_info</a></li>
<li><a href="#L296">caml_next_frame_pointer</a></li>
<li><a href="#L229">caml_remove_debug_info</a></li>
<li><a href="#L266">caml_stash_backtrace</a></li>
<li><a href="#L95">cmp_ev_info</a></li>
<li><a href="#L513">event_for_location</a></li>
<li><a href="#L84">find_debug_info</a></li>
<li><a href="#L322">get_callstack</a></li>
<li><a href="#L131">process_debug_events</a></li>
<li><a href="#L421">read_main_debug_info</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L16">CAML_INTERNALS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2000 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Stack backtrace for uncaught exceptions */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef HAS_UNISTD<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;caml/mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/custom.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/io.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/instruct.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/intext.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/exec.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fix_code.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/startup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fiber.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/sys.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/backtrace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/backtrace_prim.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/debugger.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The table of debug information fragments */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> <span class="linkable">caml_debug_info</span>;<br/></li>
<li><br/></li>
<li><a id="L50">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/misc.h.html#L227" title="ocaml/runtime/caml/misc.h:227">char_os</a> * <span class="linkable">caml_cds_file</span> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Location of fields in the <a href="interp.c.html#L55" title="ocaml/runtime/interp.c:55">Instruct</a>.debug_event record */<br/></li>
<li></span><span class="Type">enum</span> {<br/></li>
<li>&nbsp; EV_POS = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; EV_MODULE = <span class="Constant">1</span>,<br/></li>
<li>&nbsp; EV_LOC = <span class="Constant">2</span>,<br/></li>
<li>&nbsp; EV_KIND = <span class="Constant">3</span>,<br/></li>
<li>&nbsp; EV_DEFNAME = <span class="Constant">4<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Location of fields in the Location.t record. */<br/></li>
<li></span><span class="Type">enum</span> {<br/></li>
<li>&nbsp; LOC_START = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; LOC_END = <span class="Constant">1</span>,<br/></li>
<li>&nbsp; LOC_GHOST = <span class="Constant">2<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Location of fields in the Lexing.position record. */<br/></li>
<li></span><span class="Type">enum</span> {<br/></li>
<li>&nbsp; POS_FNAME = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; POS_LNUM = <span class="Constant">1</span>,<br/></li>
<li>&nbsp; POS_BOL = <span class="Constant">2</span>,<br/></li>
<li>&nbsp; POS_CNUM = <span class="Constant">3<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L76">&#x200c;</a><span class="Type">struct</span> <span class="linkable">debug_info</span> {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> start;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> end;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> num_events;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> *events;<br/></li>
<li>&nbsp; <span class="Type">int</span> already_read;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L84">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> *<span class="linkable">find_debug_info</span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> pc)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>.size; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> *di = <a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>.contents[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pc &gt;= di-&gt;start &amp;&amp; pc &lt; di-&gt;end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> di;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L95">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">cmp_ev_info</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a>* ev_a = a;<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a>* ev_b = <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> pc_a = ev_a-&gt;ev_pc;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> pc_b = ev_b-&gt;ev_pc;<br/></li>
<li>&nbsp; <span class="Type">int</span> num_a;<br/></li>
<li>&nbsp; <span class="Type">int</span> num_b;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Perform a full lexicographic comparison to make sure the resulting order is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the same under all implementations of qsort (which is not stable). */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">if</span> (pc_a &gt; pc_b) <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (pc_a &lt; pc_b) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; num_a = ev_a-&gt;ev_lnum;<br/></li>
<li>&nbsp; num_b = ev_b-&gt;ev_lnum;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (num_a &gt; num_b) <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (num_a &lt; num_b) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; num_a = ev_a-&gt;ev_startchr;<br/></li>
<li>&nbsp; num_b = ev_b-&gt;ev_startchr;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (num_a &gt; num_b) <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (num_a &lt; num_b) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; num_a = ev_a-&gt;ev_endchr;<br/></li>
<li>&nbsp; num_b = ev_b-&gt;ev_endchr;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (num_a &gt; num_b) <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (num_a &lt; num_b) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L131">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> *<span class="linkable">process_debug_events</span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> code_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> events_heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> *num_events)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a>(events_heap);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L384" title="ocaml/runtime/caml/memory.h:384">CAMLlocal3</a>(l, ev, ev_start);<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> i, j;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> *events;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Compute the size of the required event buffer. */<br/></li>
<li></span>&nbsp; *num_events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="array.c.html#L32" title="ocaml/runtime/array.c:32">caml_array_length</a>(events_heap); i++)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (l = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(events_heap, i); l != <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">0</span>); l = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(l, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; (*num_events)++;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (*num_events == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/memory.h.html#L413" title="ocaml/runtime/caml/memory.h:413">CAMLreturnT</a>(<span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> *, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><br/></li>
<li>&nbsp; events = <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(*num_events * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a>));<br/></li>
<li>&nbsp; <span class="Statement">if</span>(events == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a> (<span class="Constant">&quot;<a href="backtrace_nat.c.html#L319" title="ocaml/runtime/backtrace_nat.c:319">caml_add_debug_info</a>: out of memory&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="array.c.html#L32" title="ocaml/runtime/array.c:32">caml_array_length</a>(events_heap); i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (l = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(events_heap, i); l != <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">0</span>); l = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(l, <span class="Constant">1</span>)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; ev = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(l, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; events[j].ev_pc = (<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>)((<span class="Type">char</span>*)code_start<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev, EV_POS)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; ev_start = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev, EV_LOC), LOC_START);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fname = <a href="caml/mlvalues.h.html#L329" title="ocaml/runtime/caml/mlvalues.h:329">String_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev_start, POS_FNAME));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; events[j].ev_filename = <a href="memory.c.html#L622" title="ocaml/runtime/memory.c:622">caml_stat_strdup_noexc</a>(fname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span>(events[j].ev_filename == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a> (<span class="Constant">&quot;<a href="backtrace_nat.c.html#L319" title="ocaml/runtime/backtrace_nat.c:319">caml_add_debug_info</a>: out of memory&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev, EV_DEFNAME)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev, EV_DEFNAME)) == <a href="caml/mlvalues.h.html#L328" title="ocaml/runtime/caml/mlvalues.h:328">String_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *dname = <a href="caml/mlvalues.h.html#L329" title="ocaml/runtime/caml/mlvalues.h:329">String_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev, EV_DEFNAME));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; events[j].ev_defname = <a href="memory.c.html#L622" title="ocaml/runtime/memory.c:622">caml_stat_strdup_noexc</a>(dname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (events[j].ev_defname == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a> (<span class="Constant">&quot;<a href="backtrace_nat.c.html#L319" title="ocaml/runtime/backtrace_nat.c:319">caml_add_debug_info</a>: out of memory&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; events[j].ev_defname = <span class="Constant">&quot;&lt;old <a href="meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a>&gt;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; events[j].ev_lnum = <a href="caml/mlvalues.h.html#L82" title="ocaml/runtime/caml/mlvalues.h:82">Int_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev_start, POS_LNUM));<br/></li>
<li>&nbsp; &nbsp; &nbsp; events[j].ev_startchr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L82" title="ocaml/runtime/caml/mlvalues.h:82">Int_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev_start, POS_CNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; - <a href="caml/mlvalues.h.html#L82" title="ocaml/runtime/caml/mlvalues.h:82">Int_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev_start, POS_BOL));<br/></li>
<li>&nbsp; &nbsp; &nbsp; events[j].ev_endchr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L82" title="ocaml/runtime/caml/mlvalues.h:82">Int_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev, EV_LOC), LOC_END), POS_CNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; - <a href="caml/mlvalues.h.html#L82" title="ocaml/runtime/caml/mlvalues.h:82">Int_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev_start, POS_BOL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(j == *num_events);<br/></li>
<li><br/></li>
<li>&nbsp; qsort(events, *num_events, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a>), <a href="#L95" title="ocaml/runtime/backtrace_byt.c:95">cmp_ev_info</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L413" title="ocaml/runtime/caml/memory.h:413">CAMLreturnT</a>(<span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> *, events);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Processes a (<a href="interp.c.html#L55" title="ocaml/runtime/interp.c:55">Instruct</a>.debug_event list array) into a form suitable<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for quick lookup <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> registers it for the (code_start,code_size) pc range. */<br/></li>
<li><a id="L201">&#x200c;</a></span><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_add_debug_info</span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> code_start, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> code_size, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> events_heap)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a>(events_heap);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> *<a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (events_heap != <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="debugger.c.html#L45" title="ocaml/runtime/debugger.c:45">caml_debugger</a>(DEBUG_INFO_ADDED, events_heap);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* build the OCaml-side <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> */<br/></li>
<li></span>&nbsp; <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>));<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>-&gt;start = code_start;<br/></li>
<li>&nbsp; <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>-&gt;end = (<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>)((<span class="Type">char</span>*) code_start + <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(code_size));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (events_heap == <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>-&gt;events = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>-&gt;num_events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>-&gt;already_read = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>-&gt;events =<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L131" title="ocaml/runtime/backtrace_byt.c:131">process_debug_events</a>(code_start, events_heap, &amp;<a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>-&gt;num_events);<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>-&gt;already_read = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L146" title="ocaml/runtime/misc.c:146">caml_ext_table_add</a>(&amp;<a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>, <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>(<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L229">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_remove_debug_info</span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> start)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a>();<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L380" title="ocaml/runtime/caml/memory.h:380">CAMLlocal2</a>(dis, prev);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>.size; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> *di = <a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>.contents[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (di-&gt;start == start) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* note that <a href="misc.c.html#L160" title="ocaml/runtime/misc.c:160">caml_ext_table_remove</a> calls <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a> on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; removed resource, bracketing the <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a> call in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="backtrace_nat.c.html#L319" title="ocaml/runtime/backtrace_nat.c:319">caml_add_debug_info</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L160" title="ocaml/runtime/misc.c:160">caml_ext_table_remove</a>(&amp;<a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>, di);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>(<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L249">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_alloc_backtrace_buffer</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_pos == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_buffer =<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<a href="caml/backtrace_prim.h.html#L94" title="ocaml/runtime/caml/backtrace_prim.h:94">BACKTRACE_BUFFER_SIZE</a> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_buffer == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L258">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_free_backtrace_buffer</span>(<a href="caml/misc.h.html#L586" title="ocaml/runtime/caml/misc.h:586">backtrace_slot</a> *backtrace_buffer) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (backtrace_buffer != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(backtrace_buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Store the return addresses contained in the given stack fragment<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; into the backtrace array */<br/></li>
<li></span><br/></li>
<li><a id="L266">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_stash_backtrace</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> exn, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * sp, <span class="Type">int</span> reraise)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *trap_sp;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (exn != <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_last_exn || !reraise) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="globroots.c.html#L129" title="ocaml/runtime/globroots.c:129">caml_modify_generational_global_root</a>(&amp;<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_last_exn, exn);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_buffer == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="backtrace_nat.c.html#L72" title="ocaml/runtime/backtrace_nat.c:72">caml_alloc_backtrace_buffer</a>() == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Traverse the stack <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> put all values pointing into <a href="meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; into the backtrace buffer. */<br/></li>
<li></span>&nbsp; trap_sp = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack) + <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;trap_sp_off;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (<span class="Comment">/*nothing*/</span>; sp &lt; trap_sp; sp++) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> p;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L72" title="ocaml/runtime/caml/mlvalues.h:72">Is_long</a>(*sp)) <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; p = (<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>) *sp;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_pos &gt;= <a href="caml/backtrace_prim.h.html#L94" title="ocaml/runtime/caml/backtrace_prim.h:94">BACKTRACE_BUFFER_SIZE</a>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L84" title="ocaml/runtime/backtrace_byt.c:84">find_debug_info</a>(p) != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_buffer[<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_pos++] = p;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* returns the next frame pointer (<a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> if none is available);<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; updates *sp to point to the following one, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> *trap_spoff to the next<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; trap frame, which we will skip when we reach it&nbsp; */<br/></li>
<li></span><br/></li>
<li><a id="L296">&#x200c;</a><a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> <span class="linkable">caml_next_frame_pointer</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* stack_high, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ** sp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> * trap_spoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">while</span> (*sp &lt; stack_high) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *spv = (*sp)++;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L72" title="ocaml/runtime/caml/mlvalues.h:72">Is_long</a>(*spv)) <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; p = (<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>*) spv;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>((<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>*)&amp;<a href="caml/fiber.h.html#L242" title="ocaml/runtime/caml/fiber.h:242">Trap_pc</a>(stack_high + *trap_spoff) == p) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; *trap_spoff = <a href="caml/fiber.h.html#L243" title="ocaml/runtime/caml/fiber.h:243">Trap_link</a>(stack_high + *trap_spoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L84" title="ocaml/runtime/backtrace_byt.c:84">find_debug_info</a>(*p) != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> *p;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Stores upto [max_frames_value] frames of the current call stack to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; return to the user. This is used not in an exception-raising context, but<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; only when the user requests to save the <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a> (hopefully less often).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Instead of using a bounded buffer as [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stash_backtrace], we first<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; traverse the stack to compute the right size, then allocate space for the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>. */<br/></li>
<li></span><br/></li>
<li><a id="L322">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">get_callstack</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* sp, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> trap_spoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> max_frames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>** <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>* trace_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* parent = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(stack);<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *stack_high = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack);<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* saved_sp = sp;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> saved_trap_spoff = trap_spoff;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* first compute the size of the <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a> */<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; *trace_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*trace_size &lt; max_frames) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> p = <a href="#L296" title="ocaml/runtime/backtrace_byt.c:296">caml_next_frame_pointer</a>(stack_high, &amp;sp, &amp;trap_spoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp = parent-&gt;sp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trap_spoff = <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(sp[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack_high = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++*trace_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; *<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a> = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>*) * *trace_size);<br/></li>
<li><br/></li>
<li>&nbsp; sp = saved_sp;<br/></li>
<li>&nbsp; parent = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(stack);<br/></li>
<li>&nbsp; stack_high = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack);<br/></li>
<li>&nbsp; trap_spoff = saved_trap_spoff;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* then collect the <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a> */<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> trace_pos = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (trace_pos &lt; *trace_size) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> p = <a href="#L296" title="ocaml/runtime/backtrace_byt.c:296">caml_next_frame_pointer</a>(stack_high, &amp;sp, &amp;trap_spoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp = parent-&gt;sp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trap_spoff = <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(sp[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack_high = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>)[trace_pos] = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++trace_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L377">&#x200c;</a><span class="Type">static</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">alloc_callstack</span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>* <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> trace_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a>();<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L376" title="ocaml/runtime/caml/memory.h:376">CAMLlocal1</a>(callstack);<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; callstack = <a href="alloc.c.html#L33" title="ocaml/runtime/alloc.c:33">caml_alloc</a>(trace_len, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; trace_len; i++)<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L425" title="ocaml/runtime/caml/memory.h:425">Store_field</a>(callstack, i, <a href="caml/backtrace_prim.h.html#L78" title="ocaml/runtime/caml/backtrace_prim.h:78">Val_backtrace_slot</a>(<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>[i]));<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>(callstack);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L389">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_get_current_callstack</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> max_frames_value)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>* <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> trace_len;<br/></li>
<li>&nbsp; <a href="backtrace_nat.c.html#L128" title="ocaml/runtime/backtrace_nat.c:128">get_callstack</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack-&gt;sp, <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;trap_sp_off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack, <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(max_frames_value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, &amp;trace_len);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="backtrace_nat.c.html#L182" title="ocaml/runtime/backtrace_nat.c:182">alloc_callstack</a>(<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, trace_len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L399">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_get_continuation_callstack</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> max_frames)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a>* <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> trace_len;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *stack;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *sp;<br/></li>
<li><br/></li>
<li>&nbsp; stack = <a href="caml/mlvalues.h.html#L268" title="ocaml/runtime/caml/mlvalues.h:268">Ptr_val</a>(<a href="fiber.c.html#L624" title="ocaml/runtime/fiber.c:624">caml_continuation_use</a>(cont));<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>; <span class="Comment">/* GC must not see the stack outside the cont */<br/></li>
<li></span>&nbsp; &nbsp; sp = stack-&gt;sp;<br/></li>
<li>&nbsp; &nbsp; <a href="backtrace_nat.c.html#L128" title="ocaml/runtime/backtrace_nat.c:128">get_callstack</a>(sp, <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(sp[<span class="Constant">0</span>]), stack, <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(max_frames),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, &amp;trace_len);<br/></li>
<li>&nbsp; &nbsp; <a href="fiber.c.html#L651" title="ocaml/runtime/fiber.c:651">caml_continuation_replace</a>(cont, stack);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="backtrace_nat.c.html#L182" title="ocaml/runtime/backtrace_nat.c:182">alloc_callstack</a>(<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, trace_len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Read the debugging info contained in the current <a href="meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a> executable. */<br/></li>
<li></span><br/></li>
<li><a id="L421">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">read_main_debug_info</span>(<span class="Type">struct</span> <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> *di)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a>();<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L384" title="ocaml/runtime/caml/memory.h:384">CAMLlocal3</a>(events, evl, l);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L227" title="ocaml/runtime/caml/misc.h:227">char_os</a> *exec_name;<br/></li>
<li>&nbsp; <span class="Type">int</span> fd, num_events, orig, i;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *chan;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/exec.h.html#L53" title="ocaml/runtime/caml/exec.h:53">exec_trailer</a> trail;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(di-&gt;already_read == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; di-&gt;already_read = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* At the moment, <a href="meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a> programs built with --output-complete-exe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; do not contain any debug info.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; See&nbsp; https://github.com/ocaml/ocaml/issues/9344 for details.<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;cds_file == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> &amp;&amp; <a href="startup_byt.c.html#L115" title="ocaml/runtime/startup_byt.c:115">caml_byte_program_mode</a> == COMPLETE_EXE)<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L408" title="ocaml/runtime/caml/memory.h:408">CAMLreturn0</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;cds_file != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; exec_name = (<a href="caml/misc.h.html#L227" title="ocaml/runtime/caml/misc.h:227">char_os</a>*) <a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;cds_file;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; exec_name = (<a href="caml/misc.h.html#L227" title="ocaml/runtime/caml/misc.h:227">char_os</a>*) <a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;exe_name;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; fd = <a href="startup_byt.c.html#L117" title="ocaml/runtime/startup_byt.c:117">caml_attempt_open</a>(&amp;exec_name, &amp;trail, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record the failure of <a href="startup_byt.c.html#L117" title="ocaml/runtime/startup_byt.c:117">caml_attempt_open</a> in di-&gt;already-read */<br/></li>
<li></span>&nbsp; &nbsp; di-&gt;already_read = fd;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L408" title="ocaml/runtime/caml/memory.h:408">CAMLreturn0</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="startup_byt.c.html#L160" title="ocaml/runtime/startup_byt.c:160">caml_read_section_descriptors</a>(fd, &amp;trail);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="startup_byt.c.html#L178" title="ocaml/runtime/startup_byt.c:178">caml_seek_optional_section</a>(fd, &amp;trail, <span class="Constant">&quot;DBUG&quot;</span>) != -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; chan = <a href="io.c.html#L164" title="ocaml/runtime/io.c:164">caml_open_descriptor_in</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num_events = <a href="io.c.html#L373" title="ocaml/runtime/io.c:373">caml_getword</a>(chan);<br/></li>
<li>&nbsp; &nbsp; events = <a href="alloc.c.html#L33" title="ocaml/runtime/alloc.c:33">caml_alloc</a>(num_events, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_events; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; orig = <a href="io.c.html#L373" title="ocaml/runtime/io.c:373">caml_getword</a>(chan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; evl = <a href="intern.c.html#L825" title="ocaml/runtime/intern.c:825">caml_input_val</a>(chan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="intern.c.html#L825" title="ocaml/runtime/intern.c:825">caml_input_val</a>(chan); <span class="Comment">/* Skip the list of absolute directory names */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Relocate events in event list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (l = evl; l != <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">0</span>); l = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(l, <span class="Constant">1</span>)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ev = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(l, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/memory.h.html#L425" title="ocaml/runtime/caml/memory.h:425">Store_field</a> (ev, EV_POS, <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ev, EV_POS)) + orig));<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Record event list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/memory.h.html#L425" title="ocaml/runtime/caml/memory.h:425">Store_field</a>(events, i, evl);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="io.c.html#L193" title="ocaml/runtime/io.c:193">caml_close_channel</a>(chan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; di-&gt;events = <a href="#L131" title="ocaml/runtime/backtrace_byt.c:131">process_debug_events</a>(<a href="fix_code.c.html#L38" title="ocaml/runtime/fix_code.c:38">caml_start_code</a>, events, &amp;di-&gt;num_events);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L408" title="ocaml/runtime/caml/memory.h:408">CAMLreturn0</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L484">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_init_debug_info</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="misc.c.html#L139" title="ocaml/runtime/misc.c:139">caml_ext_table_init</a>(&amp;<a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <a href="backtrace_nat.c.html#L319" title="ocaml/runtime/backtrace_nat.c:319">caml_add_debug_info</a>(<a href="fix_code.c.html#L38" title="ocaml/runtime/fix_code.c:38">caml_start_code</a>, <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<a href="fix_code.c.html#L39" title="ocaml/runtime/fix_code.c:39">caml_code_size</a>), <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L490">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_load_main_debug_info</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;backtrace_enabled &gt; <span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="ocaml/runtime/backtrace_byt.c:421">read_main_debug_info</a>(<a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>.contents[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L497">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_debug_info_available</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>.size != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L502">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_debug_info_status</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="backtrace_nat.c.html#L329" title="ocaml/runtime/backtrace_nat.c:329">caml_debug_info_available</a>()) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ((<span class="Type">struct</span> <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> *)<a href="#L48" title="ocaml/runtime/backtrace_byt.c:48">caml_debug_info</a>.contents[<span class="Constant">0</span>])-&gt;already_read;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Search the event index for the given PC.&nbsp; Return -1 if not found. */<br/></li>
<li></span><br/></li>
<li><a id="L513">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> *<span class="linkable">event_for_location</span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> pc)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> low, high;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L76" title="ocaml/runtime/backtrace_byt.c:76">debug_info</a> *di = <a href="#L84" title="ocaml/runtime/backtrace_byt.c:84">find_debug_info</a>(pc);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (di == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!di-&gt;already_read)<br/></li>
<li>&nbsp; &nbsp; <a href="#L421" title="ocaml/runtime/backtrace_byt.c:421">read_main_debug_info</a>(di);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (di-&gt;num_events == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; low = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; high = di-&gt;num_events;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (low+<span class="Constant">1</span> &lt; high) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> m = (low+high)/<span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>(pc &lt; di-&gt;events[m].ev_pc) high = m;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> low = m;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (di-&gt;events[low].ev_pc == pc)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;di-&gt;events[low];<br/></li>
<li>&nbsp; <span class="Comment">/* ocamlc sometimes moves an event past a following PUSH instruction;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; allow mismatch by 1 instruction. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (di-&gt;events[low].ev_pc == pc + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;di-&gt;events[low];<br/></li>
<li>&nbsp; <span class="Statement">if</span> (low+<span class="Constant">1</span> &lt; di-&gt;num_events &amp;&amp; di-&gt;events[low+<span class="Constant">1</span>].ev_pc == pc + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;di-&gt;events[low+<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Search for event info at the exact given PC. */<br/></li>
<li><a id="L547">&#x200c;</a></span><span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> * <span class="linkable">caml_exact_event_for_location</span>(<a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> pc)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> *ev = <a href="#L513" title="ocaml/runtime/backtrace_byt.c:513">event_for_location</a>(pc);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ev &amp;&amp; ev-&gt;ev_pc == pc)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ev;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Extract location information for the given PC */<br/></li>
<li></span><br/></li>
<li><a id="L558">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_debuginfo_location</span>(<a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> dbg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/*out*/</span> <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L35" title="ocaml/runtime/caml/backtrace_prim.h:35">caml_loc_info</a> * li)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> pc = dbg;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L109" title="ocaml/runtime/caml/backtrace_prim.h:109">ev_info</a> *event = <a href="#L513" title="ocaml/runtime/backtrace_byt.c:513">event_for_location</a>(pc);<br/></li>
<li>&nbsp; li-&gt;loc_is_raise =<br/></li>
<li>&nbsp; &nbsp; <a href="fix_code.c.html#L178" title="ocaml/runtime/fix_code.c:178">caml_is_instruction</a>(*pc, RAISE) ||<br/></li>
<li>&nbsp; &nbsp; <a href="fix_code.c.html#L178" title="ocaml/runtime/fix_code.c:178">caml_is_instruction</a>(*pc, RERAISE);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (event == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; li-&gt;loc_valid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; li-&gt;loc_valid = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; li-&gt;loc_is_inlined = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; li-&gt;loc_filename = event-&gt;ev_filename;<br/></li>
<li>&nbsp; li-&gt;loc_defname = event-&gt;ev_defname;<br/></li>
<li>&nbsp; li-&gt;loc_lnum = event-&gt;ev_lnum;<br/></li>
<li>&nbsp; li-&gt;loc_startchr = event-&gt;ev_startchr;<br/></li>
<li>&nbsp; li-&gt;loc_endchr = event-&gt;ev_endchr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L579">&#x200c;</a><a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> <span class="linkable">caml_debuginfo_extract</span>(<a href="caml/misc.h.html#L586" title="ocaml/runtime/caml/misc.h:586">backtrace_slot</a> slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a>)slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L584">&#x200c;</a><a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> <span class="linkable">caml_debuginfo_next</span>(<a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> dbg)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* No inlining in <a href="meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a> */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
