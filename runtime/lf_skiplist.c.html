<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/lf_skiplist.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/lf_skiplist.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L67">random_seed</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L295">caml_lf_skiplist_find</a></li>
<li><a href="#L308">caml_lf_skiplist_find_below</a></li>
<li><a href="#L490">caml_lf_skiplist_free_garbage</a></li>
<li><a href="#L98">caml_lf_skiplist_init</a></li>
<li><a href="#L333">caml_lf_skiplist_insert</a></li>
<li><a href="#L430">caml_lf_skiplist_remove</a></li>
<li><a href="#L253">lf_skiplist_lookup</a></li>
<li><a href="#L69">random_level</a></li>
<li><a href="#L139">skiplist_find</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L18">CAML_INTERNALS</a></li>
<li><a href="#L54">SIZEOF_LF_SKIPCELL</a></li>
<li><a href="#L56">SIZEOF_LF_SKIPCELL</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Sadiq Jaffer, OCaml Labs Consultancy Ltd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cambium, INRIA Paris&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2021 OCaml Labs Consultancy Ltd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2020 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L18">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="shared_heap.c.html#L657" title="ocaml/runtime/shared_heap.c:657">A</a> concurrent dictionary data structure implemented as skip lists. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; implementation is based on the sequential skip list implementation in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the runtime by Xavier Leroy but extends it to be safe under concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; modification. It has the property that insert/remove are lock-free <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; contains is further wait-free. It is literally a textbook implementation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> can be found in Herlihy et al's &quot;The Art of Multiprocessor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Programming&quot; 2nd Edition, section 14.4. It only differs from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; textbook implementation to fix errors in the pseudocode in [contains],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to <a href="ints.c.html#L461" title="ocaml/runtime/ints.c:461">add</a> a [search_level] optimisation to the data structure, replacing Java's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; volatile with atomics <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> to keep a list of removed nodes in order to do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; deferred free.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; You _must_ call [<a href="#L490" title="ocaml/runtime/lf_skiplist.c:490">caml_lf_skiplist_free_garbage</a>] &quot;every so often&quot; in order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for the data structure to free removed nodes. This must be done by only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; one thread at a time when no other thread can be accessing the structure.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It is roughly half the speed of the sequential skip list so only use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where concurrent access is necessary. For use-cases where there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; only infrequent contention <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> where acquiring a lock during find is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; allowed then a sequential skip list guarded by a mutex may perform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; better.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; <a href="shared_heap.c.html#L657" title="ocaml/runtime/shared_heap.c:657">A</a> sequential implementation of skip lists is in file <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>.c <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> is based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; on the paper by William Pugh, &quot;Skip lists: a probabilistic alternative to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; balanced binary trees&quot;, Comm. ACM 33(6), 1990). */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;caml/<a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stddef.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Size of struct <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a>, in bytes, without the forward array */<br/></li>
<li></span><span class="PreProc">#if (</span><span class="Constant">__STDC_VERSION__</span><span class="PreProc"> &gt;= </span><span class="Constant">199901L</span><span class="PreProc">)<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SIZEOF_LF_SKIPCELL</span> </span><span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span><span class="PreProc">(</span><span class="Type">struct</span><span class="PreProc"> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a>)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SIZEOF_LF_SKIPCELL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; (</span><span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span><span class="PreProc">(</span><span class="Type">struct</span><span class="PreProc"> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a>) - </span><span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span><span class="PreProc">(</span><span class="Type">struct</span><span class="PreProc"> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *))<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Generate a random level for a new node: 0 with probability 3/4,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; 1 with probability 3/16, 2 with probability 3/64, etc.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; We use a simple linear congruential PRNG (see Knuth vol 2) instead<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of random(), because we need exactly 32 bits of pseudo-random data<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (i.e. 2 * (<a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a> - 1)).&nbsp; Moreover, the congruential PRNG<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is faster <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> guaranteed to be deterministic (to reproduce bugs). */<br/></li>
<li></span><br/></li>
<li><a id="L67">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> <span class="Type">_Atomic</span> <span class="linkable">random_seed</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L69">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">random_level</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> r;<br/></li>
<li>&nbsp; <span class="Type">int</span> level = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Linear congruence with modulus = 2^32, multiplier = 69069<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (Knuth vol 2 p. 106, line 15 of table 1), additive = 25173. */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">while</span>( <span class="Constant">1</span> ) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> curr = <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;<a href="#L67" title="ocaml/runtime/lf_skiplist.c:67">random_seed</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = curr * <span class="Constant">69069</span> + <span class="Constant">25173</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>( <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(&amp;<a href="#L67" title="ocaml/runtime/lf_skiplist.c:67">random_seed</a>, &amp;curr, r) ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* Knuth (vol 2 p. 13) shows that the least significant bits are<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; &quot;less random&quot; than the most significant bits with a modulus of 2^m,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; so consume most significant bits first */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> ((r &amp; <span class="Constant">0xC0000000U</span>) == <span class="Constant">0xC0000000U</span>) {<br/></li>
<li>&nbsp; &nbsp; level++;<br/></li>
<li>&nbsp; &nbsp; r = r &lt;&lt; <span class="Constant">2</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(level &lt; <a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> level;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Initialize a skip list */<br/></li>
<li></span><br/></li>
<li><a id="L98">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_lf_skiplist_init</span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a> *sk) {<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L60" title="ocaml/runtime/caml/platform.h:60">atomic_store_relaxed</a>(&amp;sk-&gt;search_level, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* This concurrent skip list has two sentinel nodes, the first [head] is<br/></li>
<li></span><span class="Comment">&nbsp; less than any possible key in the data structure <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the second [tail] is<br/></li>
<li></span><span class="Comment">&nbsp; greater than any key. */<br/></li>
<li></span>&nbsp; sk-&gt;head = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<a href="#L54" title="ocaml/runtime/lf_skiplist.c:54">SIZEOF_LF_SKIPCELL</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *));<br/></li>
<li>&nbsp; sk-&gt;head-&gt;key = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; sk-&gt;head-&gt;data = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; sk-&gt;head-&gt;garbage_next = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; sk-&gt;head-&gt;top_level = <a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a> - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; sk-&gt;tail = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<a href="#L54" title="ocaml/runtime/lf_skiplist.c:54">SIZEOF_LF_SKIPCELL</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *));<br/></li>
<li>&nbsp; sk-&gt;tail-&gt;key = <a href="caml/config.h.html#L157" title="ocaml/runtime/caml/config.h:157">UINTNAT_MAX</a>;<br/></li>
<li>&nbsp; sk-&gt;tail-&gt;data = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; sk-&gt;tail-&gt;garbage_next = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; sk-&gt;tail-&gt;top_level = <a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a> - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* We do this so that later in find when we try to CAS a cell's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; `garbage_next` in `<a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>` we can disambiguate between a cell with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; an uninitialised `garbage_next` (that we may take ownership of) <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; that is already in the garbage list. If we instead used <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> then this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; would not be possible.&nbsp; */<br/></li>
<li></span>&nbsp; sk-&gt;<a href="codefrag.c.html#L34" title="ocaml/runtime/codefrag.c:34">garbage_head</a> = sk-&gt;head;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* each level in the skip list starts of being just head pointing to tail */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (<span class="Type">int</span> j = <span class="Constant">0</span>; j &lt; <a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a>; j++) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;sk-&gt;head-&gt;forward[j], sk-&gt;tail);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;sk-&gt;tail-&gt;forward[j], <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>] is used for insert/remove <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> attempts to find a node in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>. It populates the [preds] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [succs] arrays at each level. These<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; arrays are later used for inserting <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> removing the node (by either CASing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the new <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a> <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> marking it). Additional [<a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>] will snip out nodes<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that have been marked for deletion if it finds during the search. The<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function is lock-free. */<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">skiplist_find</span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a> *sk, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> **preds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> **succs) {<br/></li>
<li>&nbsp; <span class="Comment">/* [pred] is a node that precedes the node we are looking for */<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *pred = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Comment">/* [curr] is the current node we are examining. If it is less<br/></li>
<li></span><span class="Comment">&nbsp; than our key */<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *curr = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Comment">/* [succ] is the next node to examine at our current level */<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *succ = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* start at the the head of the <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>. This node has a key less than any<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; key we could be searching for */<br/></li>
<li></span>&nbsp; &nbsp; pred = sk-&gt;head;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The algorithm itself is fairly simple, we start at the highest level (i.e<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the top, the level with the fewest nodes) of the <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a> <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> keep walking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; nodes along the level until [curr] is greater than the key we are looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for. When that happens we drop down to the next level <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> start the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; thing again from [pred]. If we could visualise searching for an element near<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the end of the list it would look something like a staircase with wide steps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; at the beginning <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> shorter ones as we descend down.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The only complexity is that we need to make sure that we don't examine any<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; nodes that are 'marked', that is the lowest bit of their forward pointer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the next node is set to 1. When we encounter one of those it means [curr]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; has been deleted <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> we need to snip it out. We might need to retry this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; several times if there's concention with other threads <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> we fail the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; compare-<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a>-swap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> level = <a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a> - <span class="Constant">1</span>; level &gt;= <span class="Constant">0</span>; level--) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; curr = <a href="caml/lf_skiplist.h.html#L95" title="ocaml/runtime/caml/lf_skiplist.h:95">LF_SK_UNMARK</a>(<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;pred-&gt;forward[level]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> <a href="caml/shared_heap.h.html#L83" title="ocaml/runtime/caml/shared_heap.h:83">is_marked</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/lf_skiplist.h.html#L96" title="ocaml/runtime/caml/lf_skiplist.h:96">LF_SK_EXTRACT</a>(curr-&gt;forward[level], <a href="caml/shared_heap.h.html#L83" title="ocaml/runtime/caml/shared_heap.h:83">is_marked</a>, succ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="caml/shared_heap.h.html#L83" title="ocaml/runtime/caml/shared_heap.h:83">is_marked</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *null_cell = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> snip = <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(&amp;pred-&gt;forward[level],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;curr, succ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!snip) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If we are at this point then we have successfully snipped out a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removed node. What we need to try to do now is <a href="ints.c.html#L461" title="ocaml/runtime/ints.c:461">add</a> the node to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>'s garbage list.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; There's a bit of complexity here. While we use a compare-<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a>-swap to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snip the node out of <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>, it's possible that it can be removed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; two threads at the same time from different levels of the <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>. To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avoid this we reuse the garbage_next field <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> make sure only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thread can ever <a href="ints.c.html#L461" title="ocaml/runtime/ints.c:461">add</a> the node to the garbage list. This is what the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compare-<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a>-swap below ensures by swapping garbage_next to a <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of 1. We don't need to worry about anyone accidentally following this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bogus pointer, it is only dereferenced in the cleanup function <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this is called when no thread can be concurrently modifying the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(&amp;curr-&gt;garbage_next, &amp;null_cell,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *)<span class="Constant">1</span>)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Despite now having exclusivity of the current node's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; garbage_next, having won the CAS, we might be racing another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; thread to <a href="ints.c.html#L461" title="ocaml/runtime/ints.c:461">add</a> a different node to the <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>'s <a href="codefrag.c.html#L34" title="ocaml/runtime/codefrag.c:34">garbage_head</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; This is why we need to a retry loop <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> yet another CAS. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *<span class="Type">_Atomic</span> current_garbage_head =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;sk-&gt;<a href="codefrag.c.html#L34" title="ocaml/runtime/codefrag.c:34">garbage_head</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;curr-&gt;garbage_next, current_garbage_head);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sk-&gt;<a href="codefrag.c.html#L34" title="ocaml/runtime/codefrag.c:34">garbage_head</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> **)&amp;current_garbage_head, curr)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now try to load the current node again. We need to check it too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hasn't been marked. If it has we repeat the process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr = <a href="caml/lf_skiplist.h.html#L95" title="ocaml/runtime/caml/lf_skiplist.h:95">LF_SK_UNMARK</a>(<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;pred-&gt;forward[level]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/lf_skiplist.h.html#L96" title="ocaml/runtime/caml/lf_skiplist.h:96">LF_SK_EXTRACT</a>(curr-&gt;forward[level], <a href="caml/shared_heap.h.html#L83" title="ocaml/runtime/caml/shared_heap.h:83">is_marked</a>, succ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curr-&gt;key &lt; key) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred = curr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr = succ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; preds[level] = pred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; succs[level] = curr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> curr-&gt;key == key;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="#L253" title="ocaml/runtime/lf_skiplist.c:253">lf_skiplist_lookup</a>] will return a <a href="caml/skiplist.h.html#L39" title="ocaml/runtime/caml/skiplist.h:39">skipcell</a> <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> node that is greater than <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; equal to the key provided, along with the node that directly proceeds it. It<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is a much simplified version of [lf_skiplist_find] as it simply ignores<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; marked nodes <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> does not snip them out. As a consequence, it is wait-free.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This implementation differs from of the 'contains' in &quot;The Art of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Multiprocessor Programming&quot; to fix the erroneous swap of pred <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> curr inside<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the while(marked) loop. It also uses [search_level] to avoid scanning the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; sentinels unnecessarily.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L253">&#x200c;</a></span><span class="Type">static</span> <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *<span class="linkable">lf_skiplist_lookup</span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a> *sk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> **pred_out) {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *pred = sk-&gt;head;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *curr = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *succ = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Type">int</span> marked = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* We start our search from the search_level of the <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a> - this is in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; contrast to the find function above where we start at <a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a>. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; intentional. Since every search has to eventually end up at the bottom-most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; level (even those of an empty list), if we accidentally start at the wrong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; level then our only cost is an increased number of nodes searched. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; did the same thing in the find function above then we'd also fail to snip<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; out marked nodes. If we did that for long enough we might leak memory. */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (<span class="Type">int</span> level = <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;sk-&gt;search_level);<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; level &gt;= <span class="Constant">0</span>; level--) {<br/></li>
<li>&nbsp; &nbsp; curr = <a href="caml/lf_skiplist.h.html#L95" title="ocaml/runtime/caml/lf_skiplist.h:95">LF_SK_UNMARK</a>(<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;pred-&gt;forward[level]));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/lf_skiplist.h.html#L96" title="ocaml/runtime/caml/lf_skiplist.h:96">LF_SK_EXTRACT</a>(curr-&gt;forward[level], marked, succ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (marked) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr = succ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/lf_skiplist.h.html#L96" title="ocaml/runtime/caml/lf_skiplist.h:96">LF_SK_EXTRACT</a>(curr-&gt;forward[level], marked, succ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curr-&gt;key &lt; key) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pred = curr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr = succ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (pred_out) {<br/></li>
<li>&nbsp; &nbsp; *pred_out = pred;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> curr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Search a skip list */<br/></li>
<li></span><br/></li>
<li><a id="L295">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_lf_skiplist_find</span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a> *sk, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> key, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> *data) {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *found_cell = <a href="#L253" title="ocaml/runtime/lf_skiplist.c:253">lf_skiplist_lookup</a>(sk, key, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (found_cell-&gt;key == key) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; *data = found_cell-&gt;data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L308">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_lf_skiplist_find_below</span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a> *sk, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> k, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> *data) {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *pred;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *curr = <a href="#L253" title="ocaml/runtime/lf_skiplist.c:253">lf_skiplist_lookup</a>(sk, k, &amp;pred);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *found_cell;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (curr-&gt;key == k) {<br/></li>
<li>&nbsp; &nbsp; found_cell = curr;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (pred != sk-&gt;head) {<br/></li>
<li>&nbsp; &nbsp; found_cell = pred;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (data) {<br/></li>
<li>&nbsp; &nbsp; *data = found_cell-&gt;data;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (key) {<br/></li>
<li>&nbsp; &nbsp; *key = found_cell-&gt;key;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Insertion in a skip list */<br/></li>
<li></span><br/></li>
<li><a id="L333">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_lf_skiplist_insert</span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a> *sk, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> key, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> data) {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *preds[<a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a>];<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *succs[<a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a>];<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(key &gt; <span class="Constant">0</span> &amp;&amp; key &lt; <a href="caml/config.h.html#L157" title="ocaml/runtime/caml/config.h:157">UINTNAT_MAX</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We first try to find a node with [key] in the skip list. If it exists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; then we don't need to <a href="ints.c.html#L461" title="ocaml/runtime/ints.c:461">add</a> it. The [<a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>] method will also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; populate the predecessors <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> successors arrays, which gives us the nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; between which we could <a href="ints.c.html#L461" title="ocaml/runtime/ints.c:461">add</a> the new node. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span> found = <a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>(sk, key, preds, succs);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *pred;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *succ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Already present; update data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L60" title="ocaml/runtime/caml/platform.h:60">atomic_store_relaxed</a>((<a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a>*)&amp;succs[<span class="Constant">0</span>]-&gt;data, data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* node does not exist. We need to generate a random top_level <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * construct a new node. The new node's forward array (which contains the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * next node in increasing order of key, at each level) starts at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * [top_level] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> goes to 0. Each entry will point to the successors in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; the [succ] array for that level. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> top_level = <a href="#L69" title="ocaml/runtime/lf_skiplist.c:69">random_level</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* attentive readers will have noticed that we assume memory is aligned to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * atleast even addresses. This is certainly the case on glibc amd64 <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * Visual C++ on Windows though I can find no guarantees for other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; platorms. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *new_cell = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L54" title="ocaml/runtime/lf_skiplist.c:54">SIZEOF_LF_SKIPCELL</a> + (top_level + <span class="Constant">1</span>) * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; new_cell-&gt;top_level = top_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; new_cell-&gt;key = key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; new_cell-&gt;data = data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L60" title="ocaml/runtime/caml/platform.h:60">atomic_store_relaxed</a>(&amp;new_cell-&gt;garbage_next,<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> level = <span class="Constant">0</span>; level &lt;= top_level; level++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;new_cell-&gt;forward[level], succs[level]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we need to actually slip the node in. We start at the bottom-most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level (i.e the linked list of all nodes). This is because all searches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; must end up at this level <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> so as long as the node is present, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; will be found - regardless of whether it has been added to the level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; above. Consider the staircasing referred to in [<a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>] earlier,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; the <a href="caml/finalise.h.html#L24" title="ocaml/runtime/caml/finalise.h:24">final</a> step in finding a node is following the reference from it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; predecessor at the bottom level. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; pred = preds[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; succ = succs[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* We could be racing another insertion here <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> if we are then restart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; the whole insertion process. We can't just retry the CAS because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new node's predecessor <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> successors could have changed. There's also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; a possibility that the predecessor's forward pointer could have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; marked <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> we would fail the CAS for that reason too. In that case the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [<a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>] earlier on will take care of snipping the node before<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; we get back to this point. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(&amp;pred-&gt;forward[<span class="Constant">0</span>], &amp;succ, new_cell)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(new_cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> level = <span class="Constant">1</span>; level &lt;= top_level; level++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pred = preds[level];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; succ = succs[level];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we were able to insert the node then we proceed to the next<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(&amp;pred-&gt;forward[level], &amp;succ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_cell)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* On the other hand if we failed it might be because the pointer was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; marked <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> because a new node was added between pred <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> succ nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; at level. In both cases we can fix things by calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [<a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> repopulating preds <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> succs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>(sk, key, preds, succs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* If we put the new node at a higher level than the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [search_level] then to speed up searches we need to bump it. We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; care too much if this fails though. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (top_level &gt; <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;sk-&gt;search_level)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L60" title="ocaml/runtime/caml/platform.h:60">atomic_store_relaxed</a>(&amp;sk-&gt;search_level, top_level);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Deletion in a skip list */<br/></li>
<li></span><br/></li>
<li><a id="L430">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_lf_skiplist_remove</span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a> *sk, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> key) {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *preds[<a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a>];<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *succs[<a href="caml/skiplist.h.html#L28" title="ocaml/runtime/caml/skiplist.h:28">NUM_LEVELS</a>];<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *succ;<br/></li>
<li>&nbsp; <span class="Type">int</span> marked;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* As with insert. If the node doesn't exist, we don't need to do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; While we're checking for it we populate the predecessor nodes <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> successor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; nodes at each level. */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> found = <a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>(sk, key, preds, succs);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!found) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When the node exists in the <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>, then succs[0] must point to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Note: this isn't the case for levels &gt; 0. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *to_remove = succs[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> level = to_remove-&gt;top_level; level &gt;= <span class="Constant">1</span>; level--) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* We <a href="major_gc.c.html#L993" title="ocaml/runtime/major_gc.c:993">mark</a> each of the forward pointers at every level the node is present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; at. We may be raced by another thread deleting the same node <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; threads inserting new nodes directly after the node we are removing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so we need to retry the CAS in a loop to deal with the latter. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/lf_skiplist.h.html#L96" title="ocaml/runtime/caml/lf_skiplist.h:96">LF_SK_EXTRACT</a>(to_remove-&gt;forward[level], marked, succ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!marked) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(&amp;to_remove-&gt;forward[level], &amp;succ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/lf_skiplist.h.html#L94" title="ocaml/runtime/caml/lf_skiplist.h:94">LF_SK_MARKED</a>(succ));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/lf_skiplist.h.html#L96" title="ocaml/runtime/caml/lf_skiplist.h:96">LF_SK_EXTRACT</a>(to_remove-&gt;forward[level], marked, succ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The bottom layer is what ultimately determines whether the node is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; present in the <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a> <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> not. We try to remove it <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> if we succeed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; then indicate so to the caller. If not then another thread raced us an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; won. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/lf_skiplist.h.html#L96" title="ocaml/runtime/caml/lf_skiplist.h:96">LF_SK_EXTRACT</a>(to_remove-&gt;forward[<span class="Constant">0</span>], marked, succ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> mark_success = <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;to_remove-&gt;forward[<span class="Constant">0</span>], &amp;succ, <a href="caml/lf_skiplist.h.html#L94" title="ocaml/runtime/caml/lf_skiplist.h:94">LF_SK_MARKED</a>(succ));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/lf_skiplist.h.html#L96" title="ocaml/runtime/caml/lf_skiplist.h:96">LF_SK_EXTRACT</a>(to_remove-&gt;forward[<span class="Constant">0</span>], marked, succ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mark_success) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="ocaml/runtime/lf_skiplist.c:139">skiplist_find</a>(sk, key, preds, succs); <span class="Comment">/* This will fix up the <a href="major_gc.c.html#L993" title="ocaml/runtime/major_gc.c:993">mark</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (marked) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>; <span class="Comment">/* Someone else beat us to removing it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* If we end up here then we lost to a thread inserting a node directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; after the node we were removing. That's why we move on one successor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Collects freed nodes from the <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a>. This must be called periodically from<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; a single thread at a time when there can be no concurrent access to this<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="caml/skiplist.h.html#L32" title="ocaml/runtime/caml/skiplist.h:32">skiplist</a> */<br/></li>
<li></span><br/></li>
<li><a id="L490">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_lf_skiplist_free_garbage</span>(<span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L36" title="ocaml/runtime/caml/lf_skiplist.h:36">lf_skiplist</a> *sk) {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *curr = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;sk-&gt;<a href="codefrag.c.html#L34" title="ocaml/runtime/codefrag.c:34">garbage_head</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *head = sk-&gt;head;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (curr != head) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/lf_skiplist.h.html#L45" title="ocaml/runtime/caml/lf_skiplist.h:45">lf_skipcell</a> *next = <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;curr-&gt;garbage_next);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">// acquire not useful, if executed in STW<br/></li>
<li></span>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(curr);<br/></li>
<li>&nbsp; &nbsp; curr = next;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;sk-&gt;<a href="codefrag.c.html#L34" title="ocaml/runtime/codefrag.c:34">garbage_head</a>, sk-&gt;head);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
