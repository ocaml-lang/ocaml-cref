<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/backtrace_nat.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/backtrace_nat.c - ocaml</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L272">name_info</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L182">alloc_callstack</a></li>
<li><a href="#L319">caml_add_debug_info</a></li>
<li><a href="#L72">caml_alloc_backtrace_buffer</a></li>
<li><a href="#L329">caml_debug_info_available</a></li>
<li><a href="#L334">caml_debug_info_status</a></li>
<li><a href="#L219">caml_debuginfo_extract</a></li>
<li><a href="#L278">caml_debuginfo_location</a></li>
<li><a href="#L254">caml_debuginfo_next</a></li>
<li><a href="#L80">caml_free_backtrace_buffer</a></li>
<li><a href="#L202">caml_get_continuation_callstack</a></li>
<li><a href="#L194">caml_get_current_callstack</a></li>
<li><a href="#L37">caml_next_frame_descriptor</a></li>
<li><a href="#L324">caml_remove_debug_info</a></li>
<li><a href="#L91">caml_stash_backtrace</a></li>
<li><a href="#L128">get_callstack</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L16">CAML_INTERNALS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Gallium, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2006 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Stack backtrace for uncaught exceptions */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/backtrace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/backtrace_prim.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/frame_descriptors.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/stack.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fiber.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Returns the next frame descriptor (<a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> if none is available),<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> updates *pc <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> *sp to point to the following one.&nbsp; */<br/></li>
<li><a id="L37">&#x200c;</a></span><a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a> * <span class="linkable">caml_next_frame_descriptor</span><br/></li>
<li>&nbsp; &nbsp; (<a href="caml/frame_descriptors.h.html#L123" title="ocaml/runtime/caml/frame_descriptors.h:123">caml_frame_descrs</a> fds, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> * pc, <span class="Type">char</span> ** sp, <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a> * d;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; d = <a href="frame_descriptors.c.html#L218" title="ocaml/runtime/frame_descriptors.c:218">caml_find_frame_descr</a>(fds, *pc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>( d == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip to next frame */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="caml/frame_descriptors.h.html#L79" title="ocaml/runtime/caml/frame_descriptors.h:79">frame_return_to_C</a>(d)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Regular frame, update sp/pc <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> return the frame descriptor */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *sp += <a href="caml/frame_descriptors.h.html#L83" title="ocaml/runtime/caml/frame_descriptors.h:83">frame_size</a>(d);<br/></li>
<li>&nbsp; &nbsp; &nbsp; *pc = <a href="caml/stack.h.html#L27" title="ocaml/runtime/caml/stack.h:27">Saved_return_address</a>(*sp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> d;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* This marks the top of an ML stack chunk. Move sp to the previous stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; chunk. This includes skipping over the DWARF <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a> &amp; trap frame<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; (4 words). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *sp += <span class="Constant">4</span> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*sp == (<span class="Type">char</span>*)<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We've reached the top of stack. No more frames. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *pc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/stack.h.html#L43" title="ocaml/runtime/caml/stack.h:43">Pop_frame_pointer</a>(*sp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; *pc = **(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>**)sp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; *sp += <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>); <span class="Comment">/* return address */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L72">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_alloc_backtrace_buffer</span>(<span class="Type">void</span>){<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_pos == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_buffer =<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<a href="caml/backtrace_prim.h.html#L94" title="ocaml/runtime/caml/backtrace_prim.h:94">BACKTRACE_BUFFER_SIZE</a> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/misc.h.html#L586" title="ocaml/runtime/caml/misc.h:586">backtrace_slot</a>));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_buffer == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L80">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_free_backtrace_buffer</span>(<a href="caml/misc.h.html#L586" title="ocaml/runtime/caml/misc.h:586">backtrace_slot</a> *backtrace_buffer) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (backtrace_buffer != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(backtrace_buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Stores the return addresses contained in the given stack fragment<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; into the backtrace array ; this version is performance-sensitive as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; it is called at each [raise] in a program compiled with [-g], so we<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; preserved the global, statically bounded buffer of the old<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; implementation -- before the more flexible<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L194" title="ocaml/runtime/backtrace_nat.c:194">caml_get_current_callstack</a>] was implemented. */<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_stash_backtrace</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> exn, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> pc, <span class="Type">char</span> * sp, <span class="Type">char</span>* trapsp)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <a href="caml/frame_descriptors.h.html#L123" title="ocaml/runtime/caml/frame_descriptors.h:123">caml_frame_descrs</a> fds;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (exn != domain_state-&gt;backtrace_last_exn) {<br/></li>
<li>&nbsp; &nbsp; domain_state-&gt;backtrace_pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="globroots.c.html#L129" title="ocaml/runtime/globroots.c:129">caml_modify_generational_global_root</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; (&amp;domain_state-&gt;backtrace_last_exn, exn);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;backtrace_buffer == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L72" title="ocaml/runtime/backtrace_nat.c:72">caml_alloc_backtrace_buffer</a>() == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; fds = <a href="frame_descriptors.c.html#L213" title="ocaml/runtime/frame_descriptors.c:213">caml_get_frame_descrs</a>();<br/></li>
<li>&nbsp; <span class="Comment">/* iterate on each frame&nbsp; */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a> * descr = <a href="#L37" title="ocaml/runtime/backtrace_nat.c:37">caml_next_frame_descriptor</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fds, &amp;pc, &amp;sp, domain_state-&gt;current_stack);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (descr == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store its descriptor in the backtrace buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (domain_state-&gt;backtrace_pos &gt;= <a href="caml/backtrace_prim.h.html#L94" title="ocaml/runtime/caml/backtrace_prim.h:94">BACKTRACE_BUFFER_SIZE</a>) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; domain_state-&gt;backtrace_buffer[domain_state-&gt;backtrace_pos++] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<a href="caml/misc.h.html#L586" title="ocaml/runtime/caml/misc.h:586">backtrace_slot</a>) descr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Stop when we reach the current exception handler */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sp &gt; trapsp) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Stores upto [max_frames_value] frames of the current call stack to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; return to the user. This is used not in an exception-raising<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; context, but only when the user requests to save the <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (hopefully less often). Instead of using a bounded buffer as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L91" title="ocaml/runtime/backtrace_nat.c:91">caml_stash_backtrace</a>], we first traverse the stack to compute the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; right size, then allocate space for the <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>. */<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">get_callstack</span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* orig_stack, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> max_frames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a>*** <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>* trace_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> trace_pos;<br/></li>
<li>&nbsp; <span class="Type">char</span> *sp;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> pc;<br/></li>
<li>&nbsp; <a href="caml/frame_descriptors.h.html#L123" title="ocaml/runtime/caml/frame_descriptors.h:123">caml_frame_descrs</a> fds;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; fds = <a href="frame_descriptors.c.html#L213" title="ocaml/runtime/frame_descriptors.c:213">caml_get_frame_descrs</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* first compute the size of the <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a> */<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack = orig_stack;<br/></li>
<li>&nbsp; &nbsp; <a href="fiber.c.html#L215" title="ocaml/runtime/fiber.c:215">caml_get_stack_sp_pc</a>(stack, &amp;sp, &amp;pc);<br/></li>
<li>&nbsp; &nbsp; trace_pos = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span>(<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a> *descr = <a href="#L37" title="ocaml/runtime/backtrace_nat.c:37">caml_next_frame_descriptor</a>(fds, &amp;pc, &amp;sp, stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trace_pos &gt;= max_frames) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (descr == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stack == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="fiber.c.html#L215" title="ocaml/runtime/fiber.c:215">caml_get_stack_sp_pc</a>(stack, &amp;sp, &amp;pc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++trace_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; *trace_size = trace_pos;<br/></li>
<li>&nbsp; *<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a> = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a>*) * trace_pos);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* then collect the <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a> */<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack = orig_stack;<br/></li>
<li>&nbsp; &nbsp; <a href="fiber.c.html#L215" title="ocaml/runtime/fiber.c:215">caml_get_stack_sp_pc</a>(stack, &amp;sp, &amp;pc);<br/></li>
<li>&nbsp; &nbsp; trace_pos = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span>(<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a> *descr = <a href="#L37" title="ocaml/runtime/backtrace_nat.c:37">caml_next_frame_descriptor</a>(fds, &amp;pc, &amp;sp, stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trace_pos &gt;= max_frames) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (descr == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stack == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="fiber.c.html#L215" title="ocaml/runtime/fiber.c:215">caml_get_stack_sp_pc</a>(stack, &amp;sp, &amp;pc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>)[trace_pos] = descr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++trace_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L182">&#x200c;</a><span class="Type">static</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">alloc_callstack</span>(<a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a>** <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> trace_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a>();<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L376" title="ocaml/runtime/caml/memory.h:376">CAMLlocal1</a>(callstack);<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; callstack = <a href="alloc.c.html#L33" title="ocaml/runtime/alloc.c:33">caml_alloc</a>(trace_len, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; trace_len; i++)<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L425" title="ocaml/runtime/caml/memory.h:425">Store_field</a>(callstack, i, <a href="caml/backtrace_prim.h.html#L78" title="ocaml/runtime/caml/backtrace_prim.h:78">Val_backtrace_slot</a>(<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>[i]));<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>(callstack);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L194">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_get_current_callstack</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> max_frames_value) {<br/></li>
<li>&nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a>** <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> trace_len;<br/></li>
<li>&nbsp; <a href="#L128" title="ocaml/runtime/backtrace_nat.c:128">get_callstack</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack, <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(max_frames_value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, &amp;trace_len);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L182" title="ocaml/runtime/backtrace_nat.c:182">alloc_callstack</a>(<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, trace_len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L202">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_get_continuation_callstack</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> max_frames)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a>** <a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> trace_len;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack;<br/></li>
<li><br/></li>
<li>&nbsp; stack = <a href="caml/mlvalues.h.html#L268" title="ocaml/runtime/caml/mlvalues.h:268">Ptr_val</a>(<a href="fiber.c.html#L624" title="ocaml/runtime/fiber.c:624">caml_continuation_use</a>(cont));<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L128" title="ocaml/runtime/backtrace_nat.c:128">get_callstack</a>(stack, max_frames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, &amp;trace_len);<br/></li>
<li>&nbsp; &nbsp; <a href="fiber.c.html#L651" title="ocaml/runtime/fiber.c:651">caml_continuation_replace</a>(cont, stack);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L182" title="ocaml/runtime/backtrace_nat.c:182">alloc_callstack</a>(<a href="parsing.c.html#L141" title="ocaml/runtime/parsing.c:141">trace</a>, trace_len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L219">&#x200c;</a><a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> <span class="linkable">caml_debuginfo_extract</span>(<a href="caml/misc.h.html#L586" title="ocaml/runtime/caml/misc.h:586">backtrace_slot</a> slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">char</span>* infoptr;<br/></li>
<li>&nbsp; <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> debuginfo_offset;<br/></li>
<li>&nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a> * d = (<a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a> *)slot;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* The special frames marking returns from Caml to C are never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; returned by <a href="#L37" title="ocaml/runtime/backtrace_nat.c:37">caml_next_frame_descriptor</a>, so should never reach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; here. */<br/></li>
<li></span>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!<a href="caml/frame_descriptors.h.html#L79" title="ocaml/runtime/caml/frame_descriptors.h:79">frame_return_to_C</a>(d));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="caml/frame_descriptors.h.html#L91" title="ocaml/runtime/caml/frame_descriptors.h:91">frame_has_debug</a>(d)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* Recover debugging info */<br/></li>
<li></span>&nbsp; infoptr = (<span class="Type">unsigned</span> <span class="Type">char</span>*)&amp;d-&gt;live_ofs[d-&gt;num_live];<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/frame_descriptors.h.html#L87" title="ocaml/runtime/caml/frame_descriptors.h:87">frame_has_allocs</a>(d)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* skip alloc_lengths */<br/></li>
<li></span>&nbsp; &nbsp; infoptr += *infoptr + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* align to 32 bits */<br/></li>
<li></span>&nbsp; &nbsp; infoptr = <a href="caml/frame_descriptors.h.html#L102" title="ocaml/runtime/caml/frame_descriptors.h:102">Align_to</a>(infoptr, <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we know there's at least one valid <a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; but it may not be the one for the first alloc */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*(<span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span>*)infoptr == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; infoptr += <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* align to 32 bits */<br/></li>
<li></span>&nbsp; &nbsp; infoptr = <a href="caml/frame_descriptors.h.html#L102" title="ocaml/runtime/caml/frame_descriptors.h:102">Align_to</a>(infoptr, <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* read offset to <a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> */<br/></li>
<li></span>&nbsp; debuginfo_offset = *(<span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span>*)infoptr;<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a>)(infoptr + debuginfo_offset);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L254">&#x200c;</a><a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> <span class="linkable">caml_debuginfo_next</span>(<a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> dbg)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> * infoptr;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (dbg == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; infoptr = dbg;<br/></li>
<li>&nbsp; <span class="Statement">if</span> ((infoptr[<span class="Constant">0</span>] &amp; <span class="Constant">1</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No next <a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* <a href="interp.c.html#L63" title="ocaml/runtime/interp.c:63">Next</a> <a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> is after the two packed info fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a>*)(infoptr + <span class="Constant">2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Multiple names may share the same filename,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; so it is referenced as an offset instead of stored inline */<br/></li>
<li><a id="L272">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">name_info</span> {<br/></li>
<li>&nbsp; <span class="Type"><a href="caml/config.h.html#L125" title="ocaml/runtime/caml/config.h:125">int32_t</a></span> filename_offs;<br/></li>
<li>&nbsp; <span class="Type">char</span> name[<span class="Constant">1</span>];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Extract location information for the given frame descriptor */<br/></li>
<li><a id="L278">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_debuginfo_location</span>(<a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a> dbg, <span class="Comment">/*out*/</span> <span class="Type">struct</span> <a href="caml/backtrace_prim.h.html#L35" title="ocaml/runtime/caml/backtrace_prim.h:35">caml_loc_info</a> * li)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> info1, info2;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L272" title="ocaml/runtime/backtrace_nat.c:272">name_info</a> * <a href="#L272" title="ocaml/runtime/backtrace_nat.c:272">name_info</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* If no debugging information available, print nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; When everything is compiled with -g, this corresponds to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; compiler-inserted re-raise operations. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (dbg == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; li-&gt;loc_valid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; li-&gt;loc_is_raise = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; li-&gt;loc_is_inlined = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* Recover debugging info */<br/></li>
<li></span>&nbsp; info1 = ((<span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> *)dbg)[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; info2 = ((<span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> *)dbg)[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; <a href="#L272" title="ocaml/runtime/backtrace_nat.c:272">name_info</a> = (<span class="Type">struct</span> <a href="#L272" title="ocaml/runtime/backtrace_nat.c:272">name_info</a>*)((<span class="Type">char</span> *) dbg + (info1 &amp; <span class="Constant">0x3FFFFFC</span>));<br/></li>
<li>&nbsp; <span class="Comment">/* Format of the two info words:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; llllllllllllllllllll aaaaaaaa bbbbbbbbbb ffffffffffffffffffffffff k n<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 44&nbsp; &nbsp; &nbsp;&nbsp; 36&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 26&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 1 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (32+12)&nbsp; &nbsp; (32+4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; n ( 1 bit ): 0 if this is the <a href="caml/finalise.h.html#L24" title="ocaml/runtime/caml/finalise.h:24">final</a> <a href="caml/backtrace_prim.h.html#L49" title="ocaml/runtime/caml/backtrace_prim.h:49">debuginfo</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if there's another following this one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; k ( 1 bit ): 0 if it's a call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 if it's a raise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; f (24 bits): offset (in 4-byte words) of file name relative to dbg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; l (20 bits): line number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; a ( 8 bits): beginning of character range<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> (10 bits): end of character range */<br/></li>
<li></span>&nbsp; li-&gt;loc_valid = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; li-&gt;loc_is_raise = (info1 &amp; <span class="Constant">2</span>) == <span class="Constant">2</span>;<br/></li>
<li>&nbsp; li-&gt;loc_is_inlined = <a href="#L254" title="ocaml/runtime/backtrace_nat.c:254">caml_debuginfo_next</a>(dbg) != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; li-&gt;loc_defname = <a href="#L272" title="ocaml/runtime/backtrace_nat.c:272">name_info</a>-&gt;name;<br/></li>
<li>&nbsp; li-&gt;loc_filename =<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">char</span> *)<a href="#L272" title="ocaml/runtime/backtrace_nat.c:272">name_info</a> + <a href="#L272" title="ocaml/runtime/backtrace_nat.c:272">name_info</a>-&gt;filename_offs;<br/></li>
<li>&nbsp; li-&gt;loc_lnum = info2 &gt;&gt; <span class="Constant">12</span>;<br/></li>
<li>&nbsp; li-&gt;loc_startchr = (info2 &gt;&gt; <span class="Constant">4</span>) &amp; <span class="Constant">0xFF</span>;<br/></li>
<li>&nbsp; li-&gt;loc_endchr = ((info2 &amp; <span class="Constant">0xF</span>) &lt;&lt; <span class="Constant">6</span>) | (info1 &gt;&gt; <span class="Constant">26</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L319">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_add_debug_info</span>(<a href="caml/misc.h.html#L586" title="ocaml/runtime/caml/misc.h:586">backtrace_slot</a> start, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> size, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> events)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L324">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_remove_debug_info</span>(<a href="caml/misc.h.html#L586" title="ocaml/runtime/caml/misc.h:586">backtrace_slot</a> start)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L329">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_debug_info_available</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L334">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_debug_info_status</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
