<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/fiber.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/fiber.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L667">caml_continuation_already_resumed_exn</a></li>
<li><a href="#L316">caml_global_data</a></li>
<li><a href="#L666">caml_unhandled_effect_exn</a></li>
<li><a href="#L49">fiber_id</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L97">alloc_for_stack</a></li>
<li><a href="#L137">alloc_size_class_stack_noexc</a></li>
<li><a href="#L669">cache_named_exception</a></li>
<li><a href="#L550">caml_alloc_main_stack</a></li>
<li><a href="#L200">caml_alloc_stack</a></li>
<li><a href="#L318">caml_alloc_stack</a></li>
<li><a href="#L81">caml_alloc_stack_cache</a></li>
<li><a href="#L190">caml_alloc_stack_noexc</a></li>
<li><a href="#L64">caml_change_max_stack_size</a></li>
<li><a href="#L651">caml_continuation_replace</a></li>
<li><a href="#L624">caml_continuation_use</a></li>
<li><a href="#L632">caml_continuation_use_and_update_handler_noexc</a></li>
<li><a href="#L595">caml_continuation_use_noexc</a></li>
<li><a href="#L659">caml_drop_continuation</a></li>
<li><a href="#L337">caml_ensure_stack_capacity</a></li>
<li><a href="#L585">caml_free_gc_regs_buckets</a></li>
<li><a href="#L558">caml_free_stack</a></li>
<li><a href="#L51">caml_get_init_stack_wsize</a></li>
<li><a href="#L215">caml_get_stack_sp_pc</a></li>
<li><a href="#L693">caml_make_unhandled_effect_exn</a></li>
<li><a href="#L292">caml_maybe_expand_stack</a></li>
<li><a href="#L685">caml_raise_continuation_already_resumed</a></li>
<li><a href="#L705">caml_raise_unhandled_effect</a></li>
<li><a href="#L402">caml_rewrite_exception_stack</a></li>
<li><a href="#L277">caml_scan_stack</a></li>
<li><a href="#L363">caml_scan_stack</a></li>
<li><a href="#L486">caml_try_realloc_stack</a></li>
<li><a href="#L357">is_scannable</a></li>
<li><a href="#L432">rewrite_frame_pointers</a></li>
<li><a href="#L225">scan_stack_frames</a></li>
<li><a href="#L122">stack_cache_bucket</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L19">CAML_INTERNALS</a></li>
<li><a href="#L79">NUM_STACK_SIZE_CLASSES</a></li>
<li><a href="#L44">fiber_debug_log</a></li>
<li><a href="#L46">fiber_debug_log</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; KC Sivaramakrishnan, Indian Institute of Technology, Madras&nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Tom Kelly, OCaml Labs Consultancy&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Stephen Dolan, University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2021 Indian Institute of Technology, Madras&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2021 OCaml Labs Consultancy&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2019 University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L19">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/callback.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/codefrag.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fiber.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/gc_ctrl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/platform.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/minor_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/major_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/startup_aux.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef NATIVE_CODE<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/stack.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/frame_descriptors.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_MMAP_MAP_STACK<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">fiber_debug_log</span>(...) <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(</span><span class="Constant">__VA_ARGS__</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">fiber_debug_log</span>(...)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L49">&#x200c;</a><span class="Type">static</span> <span class="Type">_Atomic</span> <span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> <span class="linkable">fiber_id</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L51">&#x200c;</a><a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">caml_get_init_stack_wsize</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> default_stack_wsize = <a href="caml/mlvalues.h.html#L182" title="ocaml/runtime/caml/mlvalues.h:182">Wsize_bsize</a>(<a href="caml/config.h.html#L197" title="ocaml/runtime/caml/config.h:197">Stack_init_bsize</a>);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> stack_wsize;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (default_stack_wsize &lt; <a href="gc_ctrl.c.html#L41" title="ocaml/runtime/gc_ctrl.c:41">caml_max_stack_wsize</a>)<br/></li>
<li>&nbsp; &nbsp; stack_wsize = default_stack_wsize;<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; stack_wsize = <a href="gc_ctrl.c.html#L41" title="ocaml/runtime/gc_ctrl.c:41">caml_max_stack_wsize</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> stack_wsize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L64">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_change_max_stack_size</span> (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> new_max_wsize)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *current_stack = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> wsize = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(current_stack) - (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)current_stack-&gt;sp<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + <a href="caml/config.h.html#L204" title="ocaml/runtime/caml/config.h:204">Stack_threshold</a> / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (new_max_wsize &lt; wsize) new_max_wsize = wsize;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (new_max_wsize != <a href="gc_ctrl.c.html#L41" title="ocaml/runtime/gc_ctrl.c:41">caml_max_stack_wsize</a>){<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Changing stack limit to %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;uk bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_max_wsize * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) / <span class="Constant">1024</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="gc_ctrl.c.html#L41" title="ocaml/runtime/gc_ctrl.c:41">caml_max_stack_wsize</a> = new_max_wsize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L79">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUM_STACK_SIZE_CLASSES</span> </span><span class="Constant">5<br/></li>
<li></span><br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>** <span class="linkable">caml_alloc_stack_cache</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>** stack_cache =<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>**)<a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>*) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L79" title="ocaml/runtime/fiber.c:79">NUM_STACK_SIZE_CLASSES</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (stack_cache == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span>(i = <span class="Constant">0</span>; i &lt; <a href="#L79" title="ocaml/runtime/fiber.c:79">NUM_STACK_SIZE_CLASSES</a>; i++)<br/></li>
<li>&nbsp; &nbsp; stack_cache[i] = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> stack_cache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L97">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* <span class="linkable">alloc_for_stack</span> (<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">size_t</span> len = <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) * wosize +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">8</span> <span class="Comment">/* for alignment to 16-bytes, needed for arm64 */</span> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L31" title="ocaml/runtime/caml/fiber.h:31">stack_handler</a>);<br/></li>
<li><span class="PreProc">#ifdef USE_MMAP_MAP_STACK<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* si;<br/></li>
<li>&nbsp; si = mmap(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, len, PROT_WRITE | PROT_READ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/platform.h.html#L31" title="ocaml/runtime/caml/platform.h:31">MAP_ANONYMOUS</a> | MAP_PRIVATE | MAP_STACK, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (si == MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; si-&gt;size = len;<br/></li>
<li>&nbsp; <span class="Statement">return</span> si;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(len);<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* USE_MMAP_MAP_STACK */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Returns the index into the [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stack_cache] array if this size is<br/></li>
<li></span><span class="Comment"> * pooled. If unpooled, it is [-1].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Stacks may be unpooled if either the stack size is not 2**N multiple of<br/></li>
<li></span><span class="Comment"> * [<a href="gc_ctrl.c.html#L42" title="ocaml/runtime/gc_ctrl.c:42">caml_fiber_wsz</a>] <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> the stack is bigger than pooled sizes. */<br/></li>
<li><a id="L122">&#x200c;</a></span><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">int</span> <span class="linkable">stack_cache_bucket</span> (<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize) {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> size_bucket_wsz = <a href="gc_ctrl.c.html#L42" title="ocaml/runtime/gc_ctrl.c:42">caml_fiber_wsz</a>;<br/></li>
<li>&nbsp; <span class="Type">int</span> bucket=<span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (bucket &lt; <a href="#L79" title="ocaml/runtime/fiber.c:79">NUM_STACK_SIZE_CLASSES</a>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wosize == size_bucket_wsz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> bucket;<br/></li>
<li>&nbsp; &nbsp; ++bucket;<br/></li>
<li>&nbsp; &nbsp; size_bucket_wsz += size_bucket_wsz;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>*<br/></li>
<li><a id="L137">&#x200c;</a><span class="linkable">alloc_size_class_stack_noexc</span>(<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <span class="Type">int</span> cache_bucket, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hexn, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> heff, <span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> id)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L31" title="ocaml/runtime/caml/fiber.h:31">stack_handler</a>* hand;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> **cache = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stack_cache;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L222" title="ocaml/runtime/caml/misc.h:222">CAML_STATIC_ASSERT</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>) % <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L222" title="ocaml/runtime/caml/misc.h:222">CAML_STATIC_ASSERT</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L31" title="ocaml/runtime/caml/fiber.h:31">stack_handler</a>) % <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(cache != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (cache_bucket != -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; cache[cache_bucket] != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; stack = cache[cache_bucket];<br/></li>
<li>&nbsp; &nbsp; cache[cache_bucket] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>*)stack-&gt;exception_ptr;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(stack-&gt;cache_bucket == <a href="#L122" title="ocaml/runtime/fiber.c:122">stack_cache_bucket</a>(wosize));<br/></li>
<li>&nbsp; &nbsp; hand = stack-&gt;handler;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* couldn't get a cached stack, so have to create one */<br/></li>
<li></span>&nbsp; &nbsp; stack = <a href="#L97" title="ocaml/runtime/fiber.c:97">alloc_for_stack</a>(wosize);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stack == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stack-&gt;cache_bucket = cache_bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure 16-byte alignment because some architectures require it */<br/></li>
<li></span>&nbsp; &nbsp; hand = (<span class="Type">struct</span> <a href="caml/fiber.h.html#L31" title="ocaml/runtime/caml/fiber.h:31">stack_handler</a>*)<br/></li>
<li>&nbsp; &nbsp;&nbsp; (((<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)stack + <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>) + <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) * wosize + <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &amp; ((<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)-<span class="Constant">1</span> &lt;&lt; <span class="Constant">4</span>));<br/></li>
<li>&nbsp; &nbsp; stack-&gt;handler = hand;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; hand-&gt;handle_value = hval;<br/></li>
<li>&nbsp; hand-&gt;handle_exn = hexn;<br/></li>
<li>&nbsp; hand-&gt;handle_effect = heff;<br/></li>
<li>&nbsp; hand-&gt;parent = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; stack-&gt;sp = (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)hand;<br/></li>
<li>&nbsp; stack-&gt;exception_ptr = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; stack-&gt;id = id;<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; stack-&gt;magic = <span class="Constant">42</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack) - <a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(stack) == wosize ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack) - <a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(stack) == wosize + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> stack;<br/></li>
<li><br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* allocate a stack with at least &quot;wosize&quot; usable words of stack */<br/></li>
<li></span><span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>*<br/></li>
<li><a id="L190">&#x200c;</a><span class="linkable">caml_alloc_stack_noexc</span>(<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hval, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hexn, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> heff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> id)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> cache_bucket = <a href="#L122" title="ocaml/runtime/fiber.c:122">stack_cache_bucket</a> (wosize);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L137" title="ocaml/runtime/fiber.c:137">alloc_size_class_stack_noexc</a>(wosize, cache_bucket, hval, hexn, heff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NATIVE_CODE<br/></li>
<li></span><br/></li>
<li><a id="L200">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_alloc_stack</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hval, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hexn, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> heff) {<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> id = <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L49" title="ocaml/runtime/fiber.c:49">fiber_id</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack =<br/></li>
<li>&nbsp; &nbsp; <a href="#L137" title="ocaml/runtime/fiber.c:137">alloc_size_class_stack_noexc</a>(<a href="gc_ctrl.c.html#L42" title="ocaml/runtime/gc_ctrl.c:42">caml_fiber_wsz</a>, <span class="Constant">0</span> <span class="Comment">/* first bucket */</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hval, hexn, heff, id);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!stack) <a href="fail_nat.c.html#L150" title="ocaml/runtime/fail_nat.c:150">caml_raise_out_of_memory</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L44" title="ocaml/runtime/fiber.c:44">fiber_debug_log</a> (<span class="Constant">&quot;Allocate stack=</span><span class="Special">%p</span><span class="Constant"> of %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;u words&quot;</span>, stack, <a href="gc_ctrl.c.html#L42" title="ocaml/runtime/gc_ctrl.c:42">caml_fiber_wsz</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L263" title="ocaml/runtime/caml/mlvalues.h:263">Val_ptr</a>(stack);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L215">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_get_stack_sp_pc</span> (<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span>** sp <span class="Comment">/* out */</span>, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>* pc <span class="Comment">/* out */</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">char</span>* p = (<span class="Type">char</span>*)stack-&gt;sp;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/stack.h.html#L43" title="ocaml/runtime/caml/stack.h:43">Pop_frame_pointer</a>(p);<br/></li>
<li>&nbsp; *pc = *(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>*)p; <span class="Comment">/* ret addr */<br/></li>
<li></span>&nbsp; *sp = p + <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L225">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">scan_stack_frames</span>(<br/></li>
<li>&nbsp; <a href="caml/roots.h.html#L28" title="ocaml/runtime/caml/roots.h:28">scanning_action</a> f, <a href="caml/roots.h.html#L26" title="ocaml/runtime/caml/roots.h:26">scanning_action_flags</a> fflags, <span class="Type">void</span>* fdata,<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* gc_regs)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">char</span> * sp;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> retaddr;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * regs;<br/></li>
<li>&nbsp; <a href="caml/frame_descriptors.h.html#L77" title="ocaml/runtime/caml/frame_descriptors.h:77">frame_descr</a> * d;<br/></li>
<li>&nbsp; <span class="Type">int</span> n, ofs;<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">short</span> * p;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *root;<br/></li>
<li>&nbsp; <a href="caml/frame_descriptors.h.html#L123" title="ocaml/runtime/caml/frame_descriptors.h:123">caml_frame_descrs</a> fds = <a href="frame_descriptors.c.html#L213" title="ocaml/runtime/frame_descriptors.c:213">caml_get_frame_descrs</a>();<br/></li>
<li><br/></li>
<li>&nbsp; sp = (<span class="Type">char</span>*)stack-&gt;sp;<br/></li>
<li>&nbsp; regs = gc_regs;<br/></li>
<li><br/></li>
<li><span class="Statement">next_chunk</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (sp == (<span class="Type">char</span>*)<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack)) <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/stack.h.html#L43" title="ocaml/runtime/caml/stack.h:43">Pop_frame_pointer</a>(sp);<br/></li>
<li>&nbsp; retaddr = *(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>*)sp;<br/></li>
<li>&nbsp; sp += <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span>(<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; d = <a href="frame_descriptors.c.html#L218" title="ocaml/runtime/frame_descriptors.c:218">caml_find_frame_descr</a>(fds, retaddr);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(d);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="caml/frame_descriptors.h.html#L79" title="ocaml/runtime/caml/frame_descriptors.h:79">frame_return_to_C</a>(d)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan the roots in this frame */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (p = d-&gt;live_ofs, n = d-&gt;num_live; n &gt; <span class="Constant">0</span>; n--, p++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ofs = *p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ofs &amp; <span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = regs + (ofs &gt;&gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *)(sp + ofs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f (fdata, *root, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Move to next frame */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; sp += <a href="caml/frame_descriptors.h.html#L83" title="ocaml/runtime/caml/frame_descriptors.h:83">frame_size</a>(d);<br/></li>
<li>&nbsp; &nbsp; &nbsp; retaddr = <a href="caml/stack.h.html#L27" title="ocaml/runtime/caml/stack.h:27">Saved_return_address</a>(sp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> KC: disabled already scanned optimization. */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* This marks the top of an ML stack chunk. Move sp to the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * stack chunk.&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; sp += <span class="Constant">3</span> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>); <span class="Comment">/* trap frame &amp; DWARF pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; regs = *(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>**)sp;&nbsp; &nbsp;&nbsp; <span class="Comment">/* update gc_regs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; sp += <span class="Constant">1</span> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>); <span class="Comment">/* gc_regs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> next_chunk;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L277">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_scan_stack</span>(<br/></li>
<li>&nbsp; <a href="caml/roots.h.html#L28" title="ocaml/runtime/caml/roots.h:28">scanning_action</a> f, <a href="caml/roots.h.html#L26" title="ocaml/runtime/caml/roots.h:26">scanning_action_flags</a> fflags, <span class="Type">void</span>* fdata,<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* gc_regs)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">while</span> (stack != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L225" title="ocaml/runtime/fiber.c:225">scan_stack_frames</a>(f, fflags, fdata, stack, gc_regs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; f(fdata, <a href="caml/fiber.h.html#L71" title="ocaml/runtime/caml/fiber.h:71">Stack_handle_value</a>(stack), &amp;<a href="caml/fiber.h.html#L71" title="ocaml/runtime/caml/fiber.h:71">Stack_handle_value</a>(stack));<br/></li>
<li>&nbsp; &nbsp; f(fdata, <a href="caml/fiber.h.html#L72" title="ocaml/runtime/caml/fiber.h:72">Stack_handle_exception</a>(stack), &amp;<a href="caml/fiber.h.html#L72" title="ocaml/runtime/caml/fiber.h:72">Stack_handle_exception</a>(stack));<br/></li>
<li>&nbsp; &nbsp; f(fdata, <a href="caml/fiber.h.html#L73" title="ocaml/runtime/caml/fiber.h:73">Stack_handle_effect</a>(stack), &amp;<a href="caml/fiber.h.html#L73" title="ocaml/runtime/caml/fiber.h:73">Stack_handle_effect</a>(stack));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stack = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(stack);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L292">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_maybe_expand_stack</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stk = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> stack_available =<br/></li>
<li>&nbsp; &nbsp; (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)stk-&gt;sp - <a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(stk);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> stack_needed =<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L204" title="ocaml/runtime/caml/config.h:204">Stack_threshold</a> / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)<br/></li>
<li>&nbsp; &nbsp; + <span class="Constant">8</span> <span class="Comment">/* for words pushed by caml_start_program */</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (stack_available &lt; stack_needed)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L486" title="ocaml/runtime/fiber.c:486">caml_try_realloc_stack</a> (stack_needed))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="fail_nat.c.html#L158" title="ocaml/runtime/fail_nat.c:158">caml_raise_stack_overflow</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;gc_regs_buckets == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure there is at least one gc_regs bucket available before<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; running any OCaml code. See fiber.h for documentation. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* bucket = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) * <a href="caml/stack.h.html#L41" title="ocaml/runtime/caml/stack.h:41">Wosize_gc_regs</a>);<br/></li>
<li>&nbsp; &nbsp; bucket[<span class="Constant">0</span>] = <span class="Constant">0</span>; <span class="Comment">/* no next bucket */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;gc_regs_buckets = bucket;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else</span> <span class="Comment">/* End NATIVE_CODE, begin BYTE_CODE */<br/></li>
<li></span><br/></li>
<li><a id="L316">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_global_data</span>;<br/></li>
<li><br/></li>
<li><a id="L318">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_alloc_stack</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hval, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hexn, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> heff)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* sp;<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> id = <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L49" title="ocaml/runtime/fiber.c:49">fiber_id</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack =<br/></li>
<li>&nbsp; &nbsp; <a href="#L137" title="ocaml/runtime/fiber.c:137">alloc_size_class_stack_noexc</a>(<a href="gc_ctrl.c.html#L42" title="ocaml/runtime/gc_ctrl.c:42">caml_fiber_wsz</a>, <span class="Constant">0</span> <span class="Comment">/* first bucket */</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hval, hexn, heff, id);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!stack) <a href="fail_nat.c.html#L150" title="ocaml/runtime/fail_nat.c:150">caml_raise_out_of_memory</a>();<br/></li>
<li><br/></li>
<li>&nbsp; sp = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack);<br/></li>
<li>&nbsp; sp -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; sp[<span class="Constant">0</span>] = <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; stack-&gt;sp = sp;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L263" title="ocaml/runtime/caml/mlvalues.h:263">Val_ptr</a>(stack);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L337">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ensure_stack_capacity</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> required_space)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> req = <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(required_space);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack-&gt;sp - req &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L486" title="ocaml/runtime/fiber.c:486">caml_try_realloc_stack</a>(req))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="fail_nat.c.html#L158" title="ocaml/runtime/fail_nat.c:158">caml_raise_stack_overflow</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; Root scanning.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Used by the GC to find roots on the stacks of running <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> runnable fibers.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Code pointers are stored on the <a href="meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a> stack as naked pointers.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; We must avoid passing them to the scanning action,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; unless we know that it is a no-op outside young values<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (so it will safely ignore code pointers). */<br/></li>
<li><a id="L357">&#x200c;</a></span> <a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">int</span> <span class="linkable">is_scannable</span>(<a href="caml/roots.h.html#L26" title="ocaml/runtime/caml/roots.h:26">scanning_action_flags</a> flags, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v) {<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; (flags &amp; SCANNING_ONLY_YOUNG_VALUES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; || (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(v) &amp;&amp; <a href="codefrag.c.html#L104" title="ocaml/runtime/codefrag.c:104">caml_find_code_fragment_by_pc</a>((<span class="Type">char</span> *) v) == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L363">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_scan_stack</span>(<br/></li>
<li>&nbsp; <a href="caml/roots.h.html#L28" title="ocaml/runtime/caml/roots.h:28">scanning_action</a> f, <a href="caml/roots.h.html#L26" title="ocaml/runtime/caml/roots.h:26">scanning_action_flags</a> fflags, <span class="Type">void</span>* fdata,<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* v_gc_regs)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *low, *high, *sp;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (stack != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(stack-&gt;magic == <span class="Constant">42</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; high = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack);<br/></li>
<li>&nbsp; &nbsp; low = stack-&gt;sp;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (sp = low; sp &lt; high; sp++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v = *sp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="ocaml/runtime/fiber.c:357">is_scannable</a>(fflags, v)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f(fdata, v, sp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="ocaml/runtime/fiber.c:357">is_scannable</a>(fflags, <a href="caml/fiber.h.html#L71" title="ocaml/runtime/caml/fiber.h:71">Stack_handle_value</a>(stack)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; f(fdata, <a href="caml/fiber.h.html#L71" title="ocaml/runtime/caml/fiber.h:71">Stack_handle_value</a>(stack), &amp;<a href="caml/fiber.h.html#L71" title="ocaml/runtime/caml/fiber.h:71">Stack_handle_value</a>(stack));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="ocaml/runtime/fiber.c:357">is_scannable</a>(fflags, <a href="caml/fiber.h.html#L72" title="ocaml/runtime/caml/fiber.h:72">Stack_handle_exception</a>(stack)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; f(fdata, <a href="caml/fiber.h.html#L72" title="ocaml/runtime/caml/fiber.h:72">Stack_handle_exception</a>(stack), &amp;<a href="caml/fiber.h.html#L72" title="ocaml/runtime/caml/fiber.h:72">Stack_handle_exception</a>(stack));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="ocaml/runtime/fiber.c:357">is_scannable</a>(fflags, <a href="caml/fiber.h.html#L73" title="ocaml/runtime/caml/fiber.h:73">Stack_handle_effect</a>(stack)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; f(fdata, <a href="caml/fiber.h.html#L73" title="ocaml/runtime/caml/fiber.h:73">Stack_handle_effect</a>(stack), &amp;<a href="caml/fiber.h.html#L73" title="ocaml/runtime/caml/fiber.h:73">Stack_handle_effect</a>(stack));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stack = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(stack);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* end BYTE_CODE */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; Stack management.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Used by the interpreter to allocate stack space.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef NATIVE_CODE<br/></li>
<li></span><span class="Comment">/* Update absolute exception pointers for new stack*/<br/></li>
<li><a id="L402">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_rewrite_exception_stack</span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *old_stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>** exn_ptr, <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *new_stack)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L44" title="ocaml/runtime/fiber.c:44">fiber_debug_log</a>(<span class="Constant">&quot;Old [</span><span class="Special">%p</span><span class="Constant">, </span><span class="Special">%p</span><span class="Constant">]&quot;</span>, <a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(old_stack), <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack));<br/></li>
<li>&nbsp; <a href="#L44" title="ocaml/runtime/fiber.c:44">fiber_debug_log</a>(<span class="Constant">&quot;New [</span><span class="Special">%p</span><span class="Constant">, </span><span class="Special">%p</span><span class="Constant">]&quot;</span>, <a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(new_stack), <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(new_stack));<br/></li>
<li>&nbsp; <span class="Statement">if</span>(exn_ptr) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="ocaml/runtime/fiber.c:44">fiber_debug_log</a> (<span class="Constant">&quot;*exn_ptr=</span><span class="Special">%p</span><span class="Constant">&quot;</span>, *exn_ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(old_stack) &lt; *exn_ptr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *exn_ptr &lt;= <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack)) {<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* old_val = *exn_ptr;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *exn_ptr = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(new_stack) - (<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack) - *exn_ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L44" title="ocaml/runtime/fiber.c:44">fiber_debug_log</a> (<span class="Constant">&quot;Rewriting </span><span class="Special">%p</span><span class="Constant"> to </span><span class="Special">%p</span><span class="Constant">&quot;</span>, old_val, *exn_ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(new_stack) &lt; *exn_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>((<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)*exn_ptr &lt;= <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(new_stack));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; exn_ptr = (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>**)*exn_ptr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="ocaml/runtime/fiber.c:44">fiber_debug_log</a> (<span class="Constant">&quot;finished with *exn_ptr=</span><span class="Special">%p</span><span class="Constant">&quot;</span>, *exn_ptr);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="ocaml/runtime/fiber.c:44">fiber_debug_log</a> (<span class="Constant">&quot;exn_ptr is null&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WITH_FRAME_POINTERS<br/></li>
<li></span><span class="Comment">/* Update absolute base pointers for new stack */<br/></li>
<li><a id="L432">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">rewrite_frame_pointers</span>(<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *old_stack,<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *new_stack)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> frame_walker {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> frame_walker *base_addr;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> return_addr;<br/></li>
<li>&nbsp; } *frame, *next;<br/></li>
<li>&nbsp; <span class="Type">ssize_t</span> delta;<br/></li>
<li>&nbsp; <span class="Type">void</span> *top, **p;<br/></li>
<li><br/></li>
<li>&nbsp; delta = (<span class="Type">char</span>*)<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(new_stack) - (<span class="Type">char</span>*)<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Walk the frame-pointers linked list */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (frame = __builtin_frame_address(<span class="Constant">0</span>); frame; frame = next) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; top = (<span class="Type">char</span>*)&amp;frame-&gt;return_addr<br/></li>
<li>&nbsp; &nbsp; &nbsp; + <span class="Constant">1</span> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) <span class="Comment">/* return address */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; + <span class="Constant">2</span> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) <span class="Comment">/* trap frame */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; + <span class="Constant">2</span> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>); <span class="Comment">/* DWARF pointer &amp; gc_regs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detect top of the fiber <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> bail out */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* It also avoid to dereference invalid base pointer at main */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (top == <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the base address since it may be adjusted */<br/></li>
<li></span>&nbsp; &nbsp; next = frame-&gt;base_addr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(<a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(old_stack) &lt;= (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)frame-&gt;base_addr<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)frame-&gt;base_addr &lt; <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack))) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to adjust base pointers that don't point into the reallocated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * fiber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(old_stack) &lt;= (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)&amp;frame-&gt;base_addr<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)&amp;frame-&gt;base_addr &lt; <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* The base pointer itself is located inside the reallocated fiber<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> needs to be adjusted on the new fiber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; p = (<span class="Type">void</span>**)((<span class="Type">char</span>*)<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(new_stack) - (<span class="Type">char</span>*)<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + (<span class="Type">char</span>*)&amp;frame-&gt;base_addr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(*p == frame-&gt;base_addr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; *p += delta;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Base pointers on other stacks are adjusted in place */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; frame-&gt;base_addr = (<span class="Type">struct</span> frame_walker*)((<span class="Type">char</span>*)frame-&gt;base_addr<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + delta);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L486">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_try_realloc_stack</span>(<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> required_space)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *old_stack, *new_stack;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> wsize;<br/></li>
<li>&nbsp; <span class="Type">int</span> stack_used;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; old_stack = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack;<br/></li>
<li>&nbsp; stack_used = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack) - (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)old_stack-&gt;sp;<br/></li>
<li>&nbsp; wsize = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack) - <a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(old_stack);<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wsize &gt;= <a href="gc_ctrl.c.html#L41" title="ocaml/runtime/gc_ctrl.c:41">caml_max_stack_wsize</a>) <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; wsize *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (wsize &lt; stack_used + required_space);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (wsize &gt; <span class="Constant">4096</span> / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Growing stack to %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;uk bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) wsize * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) / <span class="Constant">1024</span>);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Growing stack to %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) wsize * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>));<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; new_stack = <a href="#L190" title="ocaml/runtime/fiber.c:190">caml_alloc_stack_noexc</a>(wsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/fiber.h.html#L71" title="ocaml/runtime/caml/fiber.h:71">Stack_handle_value</a>(old_stack),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/fiber.h.html#L72" title="ocaml/runtime/caml/fiber.h:72">Stack_handle_exception</a>(old_stack),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/fiber.h.html#L73" title="ocaml/runtime/caml/fiber.h:73">Stack_handle_effect</a>(old_stack),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_stack-&gt;id);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!new_stack) <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; memcpy(<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(new_stack) - stack_used,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack) - stack_used,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stack_used * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>));<br/></li>
<li>&nbsp; new_stack-&gt;sp = <a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(new_stack) - stack_used;<br/></li>
<li>&nbsp; <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(new_stack) = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(old_stack);<br/></li>
<li><span class="PreProc">#ifdef NATIVE_CODE<br/></li>
<li></span>&nbsp; <a href="#L402" title="ocaml/runtime/fiber.c:402">caml_rewrite_exception_stack</a>(old_stack, (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>**)&amp;<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;exn_handler,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_stack);<br/></li>
<li><span class="PreProc">#ifdef WITH_FRAME_POINTERS<br/></li>
<li></span>&nbsp; <a href="#L432" title="ocaml/runtime/fiber.c:432">rewrite_frame_pointers</a>(old_stack, new_stack);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Update stack pointers in <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;c_stack. It is possible to have<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * multiple c_stack_links to point to the same stack since callbacks are run<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * on existing stacks. */<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L109" title="ocaml/runtime/caml/fiber.h:109">c_stack_link</a>* <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a> = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;c_stack; <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a>; <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a> = <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a>-&gt;prev) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a>-&gt;stack == old_stack) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a>-&gt;stack = new_stack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a>-&gt;sp = (<span class="Type">void</span>*)((<span class="Type">char</span>*)<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(new_stack) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((<span class="Type">char</span>*)<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(old_stack) - (<span class="Type">char</span>*)<a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a>-&gt;sp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L558" title="ocaml/runtime/fiber.c:558">caml_free_stack</a>(old_stack);<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack = new_stack;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L550">&#x200c;</a><span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* <span class="linkable">caml_alloc_main_stack</span> (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> init_wsize)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> id = <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L49" title="ocaml/runtime/fiber.c:49">fiber_id</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stk =<br/></li>
<li>&nbsp; &nbsp; <a href="#L190" title="ocaml/runtime/fiber.c:190">caml_alloc_stack_noexc</a>(init_wsize, <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, id);<br/></li>
<li>&nbsp; <span class="Statement">return</span> stk;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L558">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_free_stack</span> (<span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>** cache = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stack_cache;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(stack-&gt;magic == <span class="Constant">42</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(cache != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (stack-&gt;cache_bucket != -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; stack-&gt;exception_ptr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<span class="Type">void</span>*)(cache[stack-&gt;cache_bucket]);<br/></li>
<li>&nbsp; &nbsp; cache[stack-&gt;cache_bucket] = stack;<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; memset(<a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(stack), <span class="Constant">0x42</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="caml/fiber.h.html#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a>(stack)-<a href="caml/fiber.h.html#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(stack))*<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; memset(stack, <span class="Constant">0x42</span>, (<span class="Type">char</span>*)stack-&gt;handler - (<span class="Type">char</span>*)stack);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_MMAP_MAP_STACK<br/></li>
<li></span>&nbsp; &nbsp; munmap(stack, stack-&gt;size);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(stack);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L585">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_free_gc_regs_buckets</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *gc_regs_buckets)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">while</span> (gc_regs_buckets != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *next = (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)gc_regs_buckets[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(gc_regs_buckets);<br/></li>
<li>&nbsp; &nbsp; gc_regs_buckets = next;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L595">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_continuation_use_noexc</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> null_stk = <a href="caml/mlvalues.h.html#L263" title="ocaml/runtime/caml/mlvalues.h:263">Val_ptr</a>(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L44" title="ocaml/runtime/fiber.c:44">fiber_debug_log</a>(<span class="Constant">&quot;cont: is_block(</span><span class="Special">%d</span><span class="Constant">) tag_val(</span><span class="Special">%u</span><span class="Constant">l) is_young(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(cont), <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(cont), <a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(cont));<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(cont) &amp;&amp; <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(cont) == <a href="caml/mlvalues.h.html#L300" title="ocaml/runtime/caml/mlvalues.h:300">Cont_tag</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* this forms a barrier between execution <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> any other domains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; that might be marking this continuation */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (!<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(cont) ) <a href="major_gc.c.html#L1028" title="ocaml/runtime/major_gc.c:1028">caml_darken_cont</a>(cont);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* at this stage the stack is assured to be marked */<br/></li>
<li></span>&nbsp; v = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(cont, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>()) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(cont, <span class="Constant">0</span>) = null_stk;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>(cont), &amp;v, null_stk)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> null_stk;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L624">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_continuation_use</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v = <a href="#L595" title="ocaml/runtime/fiber.c:595">caml_continuation_use_noexc</a>(cont);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (v == <a href="caml/mlvalues.h.html#L263" title="ocaml/runtime/caml/mlvalues.h:263">Val_ptr</a>(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>))<br/></li>
<li>&nbsp; &nbsp; <a href="#L685" title="ocaml/runtime/fiber.c:685">caml_raise_continuation_already_resumed</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> v;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L632">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_continuation_use_and_update_handler_noexc</span><br/></li>
<li>&nbsp; (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hval, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hexn, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> heff)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> stack;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stk;<br/></li>
<li><br/></li>
<li>&nbsp; stack = <a href="#L595" title="ocaml/runtime/fiber.c:595">caml_continuation_use_noexc</a> (cont);<br/></li>
<li>&nbsp; stk = <a href="caml/mlvalues.h.html#L268" title="ocaml/runtime/caml/mlvalues.h:268">Ptr_val</a>(stack);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (stk == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The continuation has already been taken */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> stack;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(stk) != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) stk = <a href="caml/fiber.h.html#L74" title="ocaml/runtime/caml/fiber.h:74">Stack_parent</a>(stk);<br/></li>
<li>&nbsp; <a href="caml/fiber.h.html#L71" title="ocaml/runtime/caml/fiber.h:71">Stack_handle_value</a>(stk) = hval;<br/></li>
<li>&nbsp; <a href="caml/fiber.h.html#L72" title="ocaml/runtime/caml/fiber.h:72">Stack_handle_exception</a>(stk) = hexn;<br/></li>
<li>&nbsp; <a href="caml/fiber.h.html#L73" title="ocaml/runtime/caml/fiber.h:73">Stack_handle_effect</a>(stk) = heff;<br/></li>
<li>&nbsp; <span class="Statement">return</span> stack;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L651">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_continuation_replace</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont, <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stk)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> n = <a href="caml/mlvalues.h.html#L263" title="ocaml/runtime/caml/mlvalues.h:263">Val_ptr</a>(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; <span class="Type">int</span> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> = <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>(cont), &amp;n, <a href="caml/mlvalues.h.html#L263" title="ocaml/runtime/caml/mlvalues.h:263">Val_ptr</a>(stk));<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li>&nbsp; (<span class="Type">void</span>)<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>; <span class="Comment">/* squash unused warning */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L659">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_drop_continuation</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stk = <a href="caml/mlvalues.h.html#L268" title="ocaml/runtime/caml/mlvalues.h:268">Ptr_val</a>(<a href="#L624" title="ocaml/runtime/fiber.c:624">caml_continuation_use</a>(cont));<br/></li>
<li>&nbsp; <a href="#L558" title="ocaml/runtime/fiber.c:558">caml_free_stack</a>(stk);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L666">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * <span class="Type">_Atomic</span> <span class="linkable">caml_unhandled_effect_exn</span> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><a id="L667">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * <span class="Type">_Atomic</span> <span class="linkable">caml_continuation_already_resumed_exn</span> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><a id="L669">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * <span class="linkable">cache_named_exception</span>(<span class="Type">const</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * <span class="Type">_Atomic</span> * cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">const</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * exn;<br/></li>
<li>&nbsp; exn = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(cache);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (exn == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; exn = <a href="callback.c.html#L367" title="ocaml/runtime/callback.c:367">caml_named_value</a>(name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (exn == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;Fatal <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>: exception </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>, name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; exit(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(cache, exn);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> exn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L685">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_raise_continuation_already_resumed</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">const</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * exn =<br/></li>
<li>&nbsp; &nbsp; <a href="#L669" title="ocaml/runtime/fiber.c:669">cache_named_exception</a>(&amp;<a href="#L667" title="ocaml/runtime/fiber.c:667">caml_continuation_already_resumed_exn</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Effect.Continuation_already_resumed&quot;</span>);<br/></li>
<li>&nbsp; <a href="fail_nat.c.html#L59" title="ocaml/runtime/fail_nat.c:59">caml_raise</a>(*exn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L693">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_make_unhandled_effect_exn</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> effect)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a>(effect);<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> res;<br/></li>
<li>&nbsp; <span class="Type">const</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> * exn =<br/></li>
<li>&nbsp; &nbsp; <a href="#L669" title="ocaml/runtime/fiber.c:669">cache_named_exception</a>(&amp;<a href="#L666" title="ocaml/runtime/fiber.c:666">caml_unhandled_effect_exn</a>, <span class="Constant">&quot;Effect.Unhandled&quot;</span>);<br/></li>
<li>&nbsp; res = <a href="alloc.c.html#L158" title="ocaml/runtime/alloc.c:158">caml_alloc_small</a>(<span class="Constant">2</span>,<span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(res, <span class="Constant">0</span>) = *exn;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(res, <span class="Constant">1</span>) = effect;<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L705">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_raise_unhandled_effect</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> effect)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="fail_nat.c.html#L59" title="ocaml/runtime/fail_nat.c:59">caml_raise</a>(<a href="#L693" title="ocaml/runtime/fiber.c:693">caml_make_unhandled_effect_exn</a>(effect));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
