<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/memory.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/memory.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L425">pool</a></li>
<li><a href="#L426">pool_mutex</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L394">max_align</a></li>
<li><a href="#L405">pool_block</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L329">alloc_shr</a></li>
<li><a href="#L190">caml_adjust_gc_speed</a></li>
<li><a href="#L167">caml_alloc_dependent_memory</a></li>
<li><a href="#L359">caml_alloc_shr</a></li>
<li><a href="#L372">caml_alloc_shr_noexc</a></li>
<li><a href="#L364">caml_alloc_shr_reserved</a></li>
<li><a href="#L278">caml_atomic_cas</a></li>
<li><a href="#L220">caml_atomic_cas_field</a></li>
<li><a href="#L262">caml_atomic_exchange</a></li>
<li><a href="#L302">caml_atomic_fetch_add</a></li>
<li><a href="#L248">caml_atomic_load</a></li>
<li><a href="#L173">caml_free_dependent_memory</a></li>
<li><a href="#L207">caml_initialize</a></li>
<li><a href="#L149">caml_modify</a></li>
<li><a href="#L319">caml_set_fields</a></li>
<li><a href="#L550">caml_stat_alloc</a></li>
<li><a href="#L539">caml_stat_alloc_aligned</a></li>
<li><a href="#L512">caml_stat_alloc_aligned_noexc</a></li>
<li><a href="#L494">caml_stat_alloc_noexc</a></li>
<li><a href="#L609">caml_stat_calloc_noexc</a></li>
<li><a href="#L464">caml_stat_create_pool</a></li>
<li><a href="#L478">caml_stat_destroy_pool</a></li>
<li><a href="#L559">caml_stat_free</a></li>
<li><a href="#L600">caml_stat_resize</a></li>
<li><a href="#L573">caml_stat_resize_noexc</a></li>
<li><a href="#L654">caml_stat_strconcat</a></li>
<li><a href="#L632">caml_stat_strdup</a></li>
<li><a href="#L622">caml_stat_strdup_noexc</a></li>
<li><a href="#L686">caml_stat_wcsconcat</a></li>
<li><a href="#L642">caml_stat_wcsdup</a></li>
<li><a href="#L429">get_pool_block</a></li>
<li><a href="#L445">link_pool_block</a></li>
<li><a href="#L456">unlink_pool_block</a></li>
<li><a href="#L127">write_barrier</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L16">CAML_INTERNALS</a></li>
<li><a href="#L420">SIZEOF_POOL_BLOCK</a></li>
<li><a href="#L422">SIZEOF_POOL_BLOCK</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Damien Doligez, projet Para, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdarg.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stddef.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/major_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/signals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/shared_heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/domain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/roots.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fiber.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/platform.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/runtime_events.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Note [MM]: Enforcing the memory model.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Multicore OCaml implements the memory consistency model defined in<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Bounding Data Races in Space <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> Time (PLDI '18)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Stephen Dolan, KC Sivaramakrishnan, Anil Madhavapeddy.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Unlike the C++ (also used in C11) memory model, this model gives<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; well-defined behaviour to data races, ensuring that they do not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; affect unrelated computations. In C++, plain (non-atomic) accesses<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; have undefined semantics if they race, so it is necessary to use at<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; least relaxed atomics to implement all accesses.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; However, simply using C++ relaxed atomics for non-atomic accesses<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> C++ SC atomics for atomic ones is not enough, since the OCaml<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; memory model is stronger. The prototypical example where C++<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; exhibits a behaviour not allowed by OCaml is below. Assume that the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; reference <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the atomic reference a are initially 0:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Thread 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Thread 2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Atomic.set a 1;&nbsp; &nbsp;&nbsp; let x = !<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> := 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let y = Atomic.get a in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Outcome: x = 1, y = 0<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This outcome is not permitted by the OCaml memory model, as can be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; seen from the operational model: if !<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> sees the write <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> := 1, then<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the Atomic.set must have executed before the Atomic.get, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> since<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; it is atomic the most recent set must be returned by the get,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; yielding y = 1. In the equivalent axiomatic model, this would be a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; violation of Causality.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If this example is naively translated to C++ (using atomic_{load,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; store} for atomics, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> atomic_{load, store}_explicit(...,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; memory_order_relaxed) for nonatomics), then this outcome becomes<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; possible. The C++ model specifies that there is a total order on SC<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; accesses, but this total order is surprisingly weak. In this<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; example, we can have:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; x = !<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [happens-before]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; y = Atomic.get a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [SC-before]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Atomic.set a 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [happens-before]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> := 1<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Sadly, the composition of happens-before <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> SC-before does not <a href="ints.c.html#L461" title="ocaml/runtime/ints.c:461">add</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; up to anything useful, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the C++ model permits the read 'x = !<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>'<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to read from the write '<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> := 1' in this example, allowing the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; outcome above.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; To remedy this, we need to strengthen the relaxed accesses used for<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; non-atomic loads <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> stores. The most straightforward way to do<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; this is to use acquire loads <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> release stores instead of relaxed<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for non-atomic accesses, which ensures that all reads-from edges<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; appear in the C++ synchronises-with relation, outlawing the outcome<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; above.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Using release stores for all writes also ensures publication safety<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for newly-allocated objects, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> isn't necessary for initialising<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; writes. The cost is free on x86, but requires a fence in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="#L149" title="ocaml/runtime/memory.c:149">caml_modify</a> on weakly-ordered architectures (ARM, Power).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; However, instead of using acquire loads for all reads, an<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; optimisation is possible. (Optimising reads is more important than<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; optimising writes because reads are vastly more common). The OCaml<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; memory model does not require ordering between non-atomic reads,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; which acquire loads provide. The acquire semantics are only<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; necessary between a non-atomic read <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> an atomic access <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; write, so we delay the acquire fence until one of those operations<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; occurs.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; So, our non-atomic reads are implemented as standard relaxed loads,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; but non-atomic writes <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> atomic operations (in this file, below)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; contain an odd-looking line:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L79" title="ocaml/runtime/caml/camlatomic.h:79">atomic_thread_fence</a>(memory_order_acquire)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; which serves to upgrade previous relaxed loads to acquire loads.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This encodes the OCaml memory model in the primitives provided by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the C++ model.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; On x86, all loads <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> all stores have acquire/release semantics by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; default anyway, so all of these fences compile away to nothing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (They're still useful, though: they serve to inhibit an overeager C<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; compiler's optimisations). On ARMv8, actual hardware fences are<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; generated.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L127">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">write_barrier</span>(<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> obj, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> field, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> old_val, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> new_val)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* HACK: can't assert when get old C-api style pointers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(obj)); */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(obj)) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(old_val)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* if old is in the minor heap,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then this is in a remembered set already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">if</span> (<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(old_val)) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* old is a block <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> in the major heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp;&nbsp; <a href="major_gc.c.html#L1052" title="ocaml/runtime/major_gc.c:1052">caml_darken</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>, old_val, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp;&nbsp; }<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Comment">/* this update is creating a new <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a> from major to minor, remember it */<br/></li>
<li></span>&nbsp; &nbsp;&nbsp; <span class="Statement">if</span> (<a href="caml/address_class.h.html#L56" title="ocaml/runtime/caml/address_class.h:56">Is_block_and_young</a>(new_val)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/minor_gc.h.html#L96" title="ocaml/runtime/caml/minor_gc.h:96">Ref_table_add</a>(&amp;<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;minor_tables-&gt;major_ref, <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a>(obj) + field);<br/></li>
<li>&nbsp; &nbsp;&nbsp; }<br/></li>
<li>&nbsp;&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L149">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/misc.h.html#L130" title="ocaml/runtime/caml/misc.h:130">CAMLweakdef</a> <span class="Type">void</span> <span class="linkable">caml_modify</span> (<span class="Type">volatile</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *fp, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> val)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L127" title="ocaml/runtime/memory.c:127">write_barrier</a>((<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)fp, <span class="Constant">0</span>, *fp, val);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* See Note [MM] above */<br/></li>
<li></span>&nbsp; <a href="caml/camlatomic.h.html#L79" title="ocaml/runtime/caml/camlatomic.h:79">atomic_thread_fence</a>(memory_order_acquire);<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>((<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)fp)[<span class="Constant">0</span>], val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Dependent memory is all memory blocks allocated out of the heap<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that depend on the GC (<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> finalizers) for deallocation.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; For the GC to take dependent memory into account when computing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; its automatic speed setting,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; you must call [<a href="#L167" title="ocaml/runtime/memory.c:167">caml_alloc_dependent_memory</a>] when you allocate some<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; dependent memory, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [<a href="#L173" title="ocaml/runtime/memory.c:173">caml_free_dependent_memory</a>] when you<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; free it.&nbsp; In both cases, you pass as argument the size (in bytes)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of the block being allocated <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> freed.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L167">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_alloc_dependent_memory</span> (<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> nbytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;dependent_size += nbytes / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;dependent_allocated += nbytes / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L173">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_free_dependent_memory</span> (<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> nbytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;dependent_size &lt; nbytes / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)){<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;dependent_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;dependent_size -= nbytes / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Use this function to tell the major GC to speed up when you use<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; finalized blocks to automatically deallocate resources (other<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; than memory). The GC will do at least one cycle every [max]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; allocated resources; [res] is the number of resources allocated<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; this time.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Note that only [res/max] is relevant.&nbsp; The units (<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> kind of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; resource) can change between calls to [<a href="#L190" title="ocaml/runtime/memory.c:190">caml_adjust_gc_speed</a>].<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L190">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_adjust_gc_speed</span> (<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> res, <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> max)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (max == <span class="Constant">0</span>) max = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (res &gt; max) res = max;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;extra_heap_resources += (<span class="Type">double</span>) res / (<span class="Type">double</span>) max;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;extra_heap_resources &gt; <span class="Constant">0.2</span>){<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a> (EV_C_REQUEST_MAJOR_ADJUST_GC_SPEED, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L237" title="ocaml/runtime/signals.c:237">caml_request_major_slice</a> (<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* You must use [caml_intialize] to store the initial <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> in a field of a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; block, unless you are sure the <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> is not a young block, in which case a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; plain assignment would do.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; [<a href="#L207" title="ocaml/runtime/memory.c:207">caml_initialize</a>] never calls the GC, so you may call it while a block is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; unfinished (i.e. just after a call to [<a href="#L359" title="ocaml/runtime/memory.c:359">caml_alloc_shr</a>].) */<br/></li>
<li><a id="L207">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/misc.h.html#L130" title="ocaml/runtime/caml/misc.h:130">CAMLweakdef</a> <span class="Type">void</span> <span class="linkable">caml_initialize</span> (<span class="Type">volatile</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *fp, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> val)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <span class="Comment">/* Previous <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> should not be a pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; In the debug runtime, it can be either a TMC placeholder,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> an uninitialized <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> canary (Debug_uninit_{major,minor}). */<br/></li>
<li></span>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L72" title="ocaml/runtime/caml/mlvalues.h:72">Is_long</a>(*fp));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; *fp = val;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>((<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)fp) &amp;&amp; <a href="caml/address_class.h.html#L56" title="ocaml/runtime/caml/address_class.h:56">Is_block_and_young</a> (val))<br/></li>
<li>&nbsp; &nbsp; <a href="caml/minor_gc.h.html#L96" title="ocaml/runtime/caml/minor_gc.h:96">Ref_table_add</a>(&amp;<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;minor_tables-&gt;major_ref, fp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L220">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_atomic_cas_field</span> (<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> obj, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> field, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> oldval, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> newval)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>()) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* non-atomic CAS since only this thread can access the object */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">volatile</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* p = &amp;<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(obj, field);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p == oldval) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; *p = newval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L127" title="ocaml/runtime/memory.c:127">write_barrier</a>(obj, field, oldval, newval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* need a real CAS */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L64" title="ocaml/runtime/caml/mlvalues.h:64">atomic_value</a>* p = &amp;<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>(obj)[field];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> cas_ret = <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(p, &amp;oldval, newval);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/camlatomic.h.html#L79" title="ocaml/runtime/caml/camlatomic.h:79">atomic_thread_fence</a>(memory_order_release); <span class="Comment">/* generates `dmb ish` on Arm64*/<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cas_ret) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L127" title="ocaml/runtime/memory.c:127">write_barrier</a>(obj, field, oldval, newval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L248">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_atomic_load</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ref)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>()) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ref, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See Note [MM] above */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/camlatomic.h.html#L79" title="ocaml/runtime/caml/camlatomic.h:79">atomic_thread_fence</a>(memory_order_acquire);<br/></li>
<li>&nbsp; &nbsp; v = <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>(ref));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> v;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* stores are implemented as exchanges */<br/></li>
<li><a id="L262">&#x200c;</a></span><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_atomic_exchange</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ref, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ret;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>()) {<br/></li>
<li>&nbsp; &nbsp; ret = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ref, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(ref, <span class="Constant">0</span>) = v;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See Note [MM] above */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/camlatomic.h.html#L79" title="ocaml/runtime/caml/camlatomic.h:79">atomic_thread_fence</a>(memory_order_acquire);<br/></li>
<li>&nbsp; &nbsp; ret = <a href="caml/camlatomic.h.html#L73" title="ocaml/runtime/caml/camlatomic.h:73">atomic_exchange</a>(<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>(ref), v);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/camlatomic.h.html#L79" title="ocaml/runtime/caml/camlatomic.h:79">atomic_thread_fence</a>(memory_order_release); <span class="Comment">/* generates `dmb ish` on Arm64*/<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L127" title="ocaml/runtime/memory.c:127">write_barrier</a>(ref, <span class="Constant">0</span>, ret, v);<br/></li>
<li>&nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L278">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_atomic_cas</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ref, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> oldv, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> newv)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>()) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* p = <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a>(ref);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p == oldv) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; *p = newv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L127" title="ocaml/runtime/memory.c:127">write_barrier</a>(ref, <span class="Constant">0</span>, oldv, newv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L64" title="ocaml/runtime/caml/mlvalues.h:64">atomic_value</a>* p = &amp;<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>(ref)[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> cas_ret = <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(p, &amp;oldv, newv);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/camlatomic.h.html#L79" title="ocaml/runtime/caml/camlatomic.h:79">atomic_thread_fence</a>(memory_order_release); <span class="Comment">/* generates `dmb ish` on Arm64*/<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cas_ret) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L127" title="ocaml/runtime/memory.c:127">write_barrier</a>(ref, <span class="Constant">0</span>, oldv, newv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L302">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_atomic_fetch_add</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ref, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> incr)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ret;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>()) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* p = <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a>(ref);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L72" title="ocaml/runtime/caml/mlvalues.h:72">Is_long</a>(*p));<br/></li>
<li>&nbsp; &nbsp; ret = *p;<br/></li>
<li>&nbsp; &nbsp; *p = <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(ret) + <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(incr));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no write barrier needed, integer write */<br/></li>
<li></span>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L64" title="ocaml/runtime/caml/mlvalues.h:64">atomic_value</a> *p = &amp;<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>(ref)[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; ret = <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(p, <span class="Constant">2</span>*<a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(incr));<br/></li>
<li>&nbsp; &nbsp; <a href="caml/camlatomic.h.html#L79" title="ocaml/runtime/caml/camlatomic.h:79">atomic_thread_fence</a>(memory_order_release); <span class="Comment">/* generates `dmb ish` on Arm64*/<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L319">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_set_fields</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> obj, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(obj));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="caml/mlvalues.h.html#L174" title="ocaml/runtime/caml/mlvalues.h:174">Wosize_val</a>(obj); i++) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="ocaml/runtime/memory.c:149">caml_modify</a>(&amp;<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(obj, i), v);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L329">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">alloc_shr</span>(<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <a href="caml/mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a> tag, <a href="caml/mlvalues.h.html#L59" title="ocaml/runtime/caml/mlvalues.h:59">reserved_t</a> reserved,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> noexc)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L72" title="ocaml/runtime/caml/domain_state.h:72">Caml_check_caml_state</a>();<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> *dom_st = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *v = <a href="shared_heap.c.html#L397" title="ocaml/runtime/shared_heap.c:397">caml_shared_try_alloc</a>(dom_st-&gt;shared_heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wosize, tag, reserved, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (v == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!noexc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="fail_nat.c.html#L150" title="ocaml/runtime/fail_nat.c:150">caml_raise_out_of_memory</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; dom_st-&gt;allocated_words += <a href="caml/mlvalues.h.html#L178" title="ocaml/runtime/caml/mlvalues.h:178">Whsize_wosize</a>(wosize);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (dom_st-&gt;allocated_words &gt; dom_st-&gt;minor_heap_wsz / <span class="Constant">5</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a> (EV_C_REQUEST_MAJOR_ALLOC_SHR, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L237" title="ocaml/runtime/signals.c:237">caml_request_major_slice</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (tag &lt; <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> i;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; wosize; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L168" title="ocaml/runtime/caml/mlvalues.h:168">Op_hp</a>(v)[i] = <a href="caml/misc.h.html#L535" title="ocaml/runtime/caml/misc.h:535">Debug_uninit_major</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L167" title="ocaml/runtime/caml/mlvalues.h:167">Val_hp</a>(v);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L359">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_alloc_shr</span>(<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <a href="caml/mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a> tag)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L329" title="ocaml/runtime/memory.c:329">alloc_shr</a>(wosize, tag, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L364">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_alloc_shr_reserved</span>(<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a> tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/mlvalues.h.html#L59" title="ocaml/runtime/caml/mlvalues.h:59">reserved_t</a> reserved)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L329" title="ocaml/runtime/memory.c:329">alloc_shr</a>(wosize, tag, reserved, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L372">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_alloc_shr_noexc</span>(<a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <a href="caml/mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a> tag) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L329" title="ocaml/runtime/memory.c:329">alloc_shr</a>(wosize, tag, <span class="Constant">0</span>, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Global memory <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> is structured as a ring of blocks, where each block's header<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; contains two links: to the previous <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> to the next block. The data<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; structure allows for insertions <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> removals of blocks in constant time,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; given that a pointer to the operated block is provided.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Initially, the <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> contains a single block -- a pivot with no data, the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; guaranteed existence of which makes for a more concise implementation.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The API functions that operate on the <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> receive not pointers to the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; block's header, but rather pointers to the block's &quot;data&quot; field. This<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; behaviour is required to maintain compatibility with the interfaces of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [malloc], [realloc], <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [free] family of functions, as well as to hide<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the implementation from the user.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="shared_heap.c.html#L657" title="ocaml/runtime/shared_heap.c:657">A</a> type with the most strict alignment requirements */<br/></li>
<li><a id="L394">&#x200c;</a></span><span class="Type">union</span> <span class="linkable">max_align</span> {<br/></li>
<li>&nbsp; <span class="Type">char</span> c;<br/></li>
<li>&nbsp; <span class="Type">short</span> s;<br/></li>
<li>&nbsp; <span class="Type">long</span> l;<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Type">float</span> f;<br/></li>
<li>&nbsp; <span class="Type">double</span> d;<br/></li>
<li>&nbsp; <span class="Type">void</span> *v;<br/></li>
<li>&nbsp; <span class="Type">void</span> (*q)(<span class="Type">void</span>);<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L405">&#x200c;</a><span class="Type">struct</span> <span class="linkable">pool_block</span> {<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> magic;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *next;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *prev;<br/></li>
<li>&nbsp; <span class="Comment">/* Use C99's flexible array types if possible */<br/></li>
<li></span><span class="PreProc">#if (</span><span class="Constant">__STDC_VERSION__</span><span class="PreProc"> &gt;= </span><span class="Constant">199901L</span><span class="PreProc">)<br/></li>
<li></span>&nbsp; <span class="Type">union</span> <a href="#L394" title="ocaml/runtime/memory.c:394">max_align</a> data[];&nbsp; <span class="Comment">/* not allocated, used for alignment purposes */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Type">union</span> <a href="#L394" title="ocaml/runtime/memory.c:394">max_align</a> data[<span class="Constant">1</span>];<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="PreProc">#if (</span><span class="Constant">__STDC_VERSION__</span><span class="PreProc"> &gt;= </span><span class="Constant">199901L</span><span class="PreProc">)<br/></li>
<li><a id="L420">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SIZEOF_POOL_BLOCK</span> </span><span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span><span class="PreProc">(</span><span class="Type">struct</span><span class="PreProc"> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a>)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L422">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SIZEOF_POOL_BLOCK</span> offsetof(</span><span class="Type">struct</span><span class="PreProc"> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a>, data)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L425">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *<span class="linkable">pool</span> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><a id="L426">&#x200c;</a><span class="Type">static</span> <a href="caml/platform.h.html#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a> <span class="linkable">pool_mutex</span> = <a href="caml/platform.h.html#L101" title="ocaml/runtime/caml/platform.h:101">CAML_PLAT_MUTEX_INITIALIZER</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Returns a pointer to the block header, given a pointer to &quot;data&quot; */<br/></li>
<li><a id="L429">&#x200c;</a></span><span class="Type">static</span> <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a>* <span class="linkable">get_pool_block</span>(<a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *pb =<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a>*)(((<span class="Type">char</span>*)<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>) - <a href="#L420" title="ocaml/runtime/memory.c:420">SIZEOF_POOL_BLOCK</a>);<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(pb-&gt;magic == <a href="caml/misc.h.html#L538" title="ocaml/runtime/caml/misc.h:538">Debug_pool_magic</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> pb;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Linking a <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> block into the ring */<br/></li>
<li><a id="L445">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">link_pool_block</span>(<span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L426" title="ocaml/runtime/memory.c:426">pool_mutex</a>);<br/></li>
<li>&nbsp; pb-&gt;next = <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>-&gt;next;<br/></li>
<li>&nbsp; pb-&gt;prev = <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>;<br/></li>
<li>&nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>-&gt;next-&gt;prev = pb;<br/></li>
<li>&nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>-&gt;next = pb;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L426" title="ocaml/runtime/memory.c:426">pool_mutex</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Unlinking a <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> block from the ring */<br/></li>
<li><a id="L456">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">unlink_pool_block</span>(<span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L426" title="ocaml/runtime/memory.c:426">pool_mutex</a>);<br/></li>
<li>&nbsp; &nbsp; pb-&gt;prev-&gt;next = pb-&gt;next;<br/></li>
<li>&nbsp; &nbsp; pb-&gt;next-&gt;prev = pb-&gt;prev;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L426" title="ocaml/runtime/memory.c:426">pool_mutex</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L464">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_stat_create_pool</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> = malloc(<a href="#L420" title="ocaml/runtime/memory.c:420">SIZEOF_POOL_BLOCK</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Fatal <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>: out of memory.</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>-&gt;magic = <a href="caml/misc.h.html#L538" title="ocaml/runtime/caml/misc.h:538">Debug_pool_magic</a>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>-&gt;next = <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>-&gt;prev = <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L478">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_stat_destroy_pool</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L426" title="ocaml/runtime/memory.c:426">pool_mutex</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>-&gt;prev-&gt;next = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *next = <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>-&gt;next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; free(<a href="#L425" title="ocaml/runtime/memory.c:425">pool</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> = next;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L426" title="ocaml/runtime/memory.c:426">pool_mutex</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [sz] is a number of bytes */<br/></li>
<li><a id="L494">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <span class="linkable">caml_stat_alloc_noexc</span>(<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* Backward compatibility mode */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> malloc(sz);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *pb = malloc(sz + <a href="#L420" title="ocaml/runtime/memory.c:420">SIZEOF_POOL_BLOCK</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pb == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;(pb-&gt;data), <a href="caml/misc.h.html#L540" title="ocaml/runtime/caml/misc.h:540">Debug_uninit_stat</a>, sz);<br/></li>
<li>&nbsp; &nbsp; pb-&gt;magic = <a href="caml/misc.h.html#L538" title="ocaml/runtime/caml/misc.h:538">Debug_pool_magic</a>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L445" title="ocaml/runtime/memory.c:445">link_pool_block</a>(pb);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;(pb-&gt;data);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [sz] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [modulo] are numbers of bytes */<br/></li>
<li><a id="L512">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span>* <span class="linkable">caml_stat_alloc_aligned_noexc</span>(<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz, <span class="Type">int</span> modulo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> *<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">char</span> *raw_mem;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> aligned_mem;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<span class="Constant">0</span> &lt;= modulo &amp;&amp; modulo &lt; <a href="caml/config.h.html#L193" title="ocaml/runtime/caml/config.h:193">Page_size</a>);<br/></li>
<li>&nbsp; raw_mem = (<span class="Type">char</span> *) <a href="#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(sz + <a href="caml/config.h.html#L193" title="ocaml/runtime/caml/config.h:193">Page_size</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (raw_mem == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; *<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> = raw_mem;<br/></li>
<li>&nbsp; raw_mem += modulo;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Address to be aligned */<br/></li>
<li></span>&nbsp; aligned_mem = (((<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) raw_mem / <a href="caml/config.h.html#L193" title="ocaml/runtime/caml/config.h:193">Page_size</a> + <span class="Constant">1</span>) * <a href="caml/config.h.html#L193" title="ocaml/runtime/caml/config.h:193">Page_size</a>);<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> *p;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> *p0 = (<span class="Type">void</span> *) *<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> *p1 = (<span class="Type">void</span> *) (aligned_mem - modulo);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> *p2 = (<span class="Type">void</span> *) (aligned_mem - modulo + sz);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> *p3 = (<span class="Type">void</span> *) ((<span class="Type">char</span> *) *<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> + sz + <a href="caml/config.h.html#L193" title="ocaml/runtime/caml/config.h:193">Page_size</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = p0; p &lt; p1; p++) *p = <a href="caml/misc.h.html#L537" title="ocaml/runtime/caml/misc.h:537">Debug_filler_align</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = p1; p &lt; p2; p++) *p = <a href="caml/misc.h.html#L536" title="ocaml/runtime/caml/misc.h:536">Debug_uninit_align</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = p2; p &lt; p3; p++) *p = <a href="caml/misc.h.html#L537" title="ocaml/runtime/caml/misc.h:537">Debug_filler_align</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> (<span class="Type">char</span> *) (aligned_mem - modulo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [sz] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [modulo] are numbers of bytes */<br/></li>
<li><a id="L539">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span>* <span class="linkable">caml_stat_alloc_aligned</span>(<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz, <span class="Type">int</span> modulo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> *<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span> *result = <a href="#L512" title="ocaml/runtime/memory.c:512">caml_stat_alloc_aligned_noexc</a>(sz, modulo, <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li>&nbsp; <span class="Comment">/* malloc() may return <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> if size is 0 */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> ((result == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) &amp;&amp; (sz != <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L150" title="ocaml/runtime/fail_nat.c:150">caml_raise_out_of_memory</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [sz] is a number of bytes */<br/></li>
<li><a id="L550">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <span class="linkable">caml_stat_alloc</span>(<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span> *result = <a href="#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(sz);<br/></li>
<li>&nbsp; <span class="Comment">/* malloc() may return <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> if size is 0 */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> ((result == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) &amp;&amp; (sz != <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L150" title="ocaml/runtime/fail_nat.c:150">caml_raise_out_of_memory</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L559">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_stat_free</span>(<a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* Backward compatibility mode */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; free(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *pb = <a href="#L429" title="ocaml/runtime/memory.c:429">get_pool_block</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pb == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L456" title="ocaml/runtime/memory.c:456">unlink_pool_block</a>(pb);<br/></li>
<li>&nbsp; &nbsp; free(pb);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [sz] is a number of bytes */<br/></li>
<li><a id="L573">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <span class="linkable">caml_stat_resize_noexc</span>(<a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>, <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(sz);<br/></li>
<li>&nbsp; <span class="Comment">/* Backward compatibility mode */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> realloc(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>, sz);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *pb = <a href="#L429" title="ocaml/runtime/memory.c:429">get_pool_block</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L405" title="ocaml/runtime/memory.c:405">pool_block</a> *pb_new;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlinking the block because it can be freed by realloc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; while other domains access the <a href="#L425" title="ocaml/runtime/memory.c:425">pool</a> concurrently. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L456" title="ocaml/runtime/memory.c:456">unlink_pool_block</a>(pb);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reallocating */<br/></li>
<li></span>&nbsp; &nbsp; pb_new = realloc(pb, sz + <a href="#L420" title="ocaml/runtime/memory.c:420">SIZEOF_POOL_BLOCK</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pb_new == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* The old block is still there, relinking it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L445" title="ocaml/runtime/memory.c:445">link_pool_block</a>(pb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L445" title="ocaml/runtime/memory.c:445">link_pool_block</a>(pb_new);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;(pb_new-&gt;data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [sz] is a number of bytes */<br/></li>
<li><a id="L600">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <span class="linkable">caml_stat_resize</span>(<a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>, <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span> *result = <a href="#L573" title="ocaml/runtime/memory.c:573">caml_stat_resize_noexc</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>, sz);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (result == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L150" title="ocaml/runtime/fail_nat.c:150">caml_raise_out_of_memory</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* [sz] is a number of bytes */<br/></li>
<li><a id="L609">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <span class="linkable">caml_stat_calloc_noexc</span>(<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> num, <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> total;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/misc.h.html#L347" title="ocaml/runtime/caml/misc.h:347">caml_umul_overflow</a>(sz, num, &amp;total))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> result = <a href="#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(total);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; memset(result, <span class="Constant">0</span>, total);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L622">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">caml_stat_strdup_noexc</span>(<span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">size_t</span> slen = strlen(s);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> result = <a href="#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(slen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (result == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; memcpy(result, s, slen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L632">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">caml_stat_strdup</span>(<span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> result = <a href="#L622" title="ocaml/runtime/memory.c:622">caml_stat_strdup_noexc</a>(s);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (result == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L150" title="ocaml/runtime/fail_nat.c:150">caml_raise_out_of_memory</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef _WIN32<br/></li>
<li></span><br/></li>
<li><a id="L642">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">wchar_t</span> * <span class="linkable">caml_stat_wcsdup</span>(<span class="Type">const</span> <span class="Type">wchar_t</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> slen = wcslen(s);<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span>* result = <a href="#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>((slen + <span class="Constant">1</span>)*<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (result == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L150" title="ocaml/runtime/fail_nat.c:150">caml_raise_out_of_memory</a>();<br/></li>
<li>&nbsp; memcpy(result, s, (slen + <span class="Constant">1</span>)*<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>));<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L654">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">caml_stat_strconcat</span>(<span class="Type">int</span> n, ...)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">va_list</span> args;<br/></li>
<li>&nbsp; <span class="Type">char</span> *result, *p;<br/></li>
<li>&nbsp; <span class="Type">size_t</span> len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li><br/></li>
<li>&nbsp; va_start(args, n);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *s = va_arg(args, <span class="Type">const</span> <span class="Type">char</span>*);<br/></li>
<li>&nbsp; &nbsp; len += strlen(s);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; va_end(args);<br/></li>
<li><br/></li>
<li>&nbsp; result = <a href="#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(len + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; va_start(args, n);<br/></li>
<li>&nbsp; p = result;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *s = va_arg(args, <span class="Type">const</span> <span class="Type">char</span>*);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span> l = strlen(s);<br/></li>
<li>&nbsp; &nbsp; memcpy(p, s, l);<br/></li>
<li>&nbsp; &nbsp; p += l;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; va_end(args);<br/></li>
<li><br/></li>
<li>&nbsp; *p = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef _WIN32<br/></li>
<li></span><br/></li>
<li><a id="L686">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">wchar_t</span>* <span class="linkable">caml_stat_wcsconcat</span>(<span class="Type">int</span> n, ...)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">va_list</span> args;<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> *result, *p;<br/></li>
<li>&nbsp; <span class="Type">size_t</span> len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li><br/></li>
<li>&nbsp; va_start(args, n);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">wchar_t</span> *s = va_arg(args, <span class="Type">const</span> <span class="Type">wchar_t</span>*);<br/></li>
<li>&nbsp; &nbsp; len += wcslen(s);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; va_end(args);<br/></li>
<li><br/></li>
<li>&nbsp; result = <a href="#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>((len + <span class="Constant">1</span>)*<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>));<br/></li>
<li><br/></li>
<li>&nbsp; va_start(args, n);<br/></li>
<li>&nbsp; p = result;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">wchar_t</span> *s = va_arg(args, <span class="Type">const</span> <span class="Type">wchar_t</span>*);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span> l = wcslen(s);<br/></li>
<li>&nbsp; &nbsp; memcpy(p, s, l*<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>));<br/></li>
<li>&nbsp; &nbsp; p += l;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; va_end(args);<br/></li>
<li><br/></li>
<li>&nbsp; *p = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
