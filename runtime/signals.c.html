<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/signals.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/signals.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L140">caml_enter_blocking_section_hook</a></li>
<li><a href="#L142">caml_leave_blocking_section_hook</a></li>
<li><a href="#L44">caml_pending_signals</a></li>
<li><a href="#L193">caml_signal_handlers</a></li>
<li><a href="#L538">caml_signal_stack_0</a></li>
<li><a href="#L452">posix_signals</a></li>
<li><a href="#L46">signal_install_mutex</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L295">caml_check_pending_actions</a></li>
<li><a href="#L48">caml_check_pending_signals</a></li>
<li><a href="#L459">caml_convert_signal_number</a></li>
<li><a href="#L301">caml_do_pending_actions_exn</a></li>
<li><a href="#L145">caml_enter_blocking_section</a></li>
<li><a href="#L128">caml_enter_blocking_section_default</a></li>
<li><a href="#L161">caml_enter_blocking_section_no_pending</a></li>
<li><a href="#L206">caml_execute_signal_exn</a></li>
<li><a href="#L511">caml_free_signal_stack</a></li>
<li><a href="#L195">caml_init_signal_handling</a></li>
<li><a href="#L475">caml_init_signal_stack</a></li>
<li><a href="#L541">caml_init_signals</a></li>
<li><a href="#L622">caml_install_signal_handler</a></li>
<li><a href="#L166">caml_leave_blocking_section</a></li>
<li><a href="#L134">caml_leave_blocking_section_default</a></li>
<li><a href="#L360">caml_process_pending_actions</a></li>
<li><a href="#L355">caml_process_pending_actions_exn</a></li>
<li><a href="#L349">caml_process_pending_actions_with_root</a></li>
<li><a href="#L338">caml_process_pending_actions_with_root_exn</a></li>
<li><a href="#L60">caml_process_pending_signals_exn</a></li>
<li><a href="#L115">caml_record_signal</a></li>
<li><a href="#L237">caml_request_major_slice</a></li>
<li><a href="#L247">caml_request_minor_gc</a></li>
<li><a href="#L467">caml_rev_convert_signal_number</a></li>
<li><a href="#L289">caml_set_action_pending</a></li>
<li><a href="#L591">caml_set_signal_action</a></li>
<li><a href="#L569">caml_terminate_signals</a></li>
<li><a href="#L579">handle_signal</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L16">CAML_INTERNALS</a></li>
<li><a href="#L368">SIGABRT</a></li>
<li><a href="#L371">SIGALRM</a></li>
<li><a href="#L431">SIGBUS</a></li>
<li><a href="#L407">SIGCHLD</a></li>
<li><a href="#L410">SIGCONT</a></li>
<li><a href="#L374">SIGFPE</a></li>
<li><a href="#L377">SIGHUP</a></li>
<li><a href="#L380">SIGILL</a></li>
<li><a href="#L383">SIGINT</a></li>
<li><a href="#L386">SIGKILL</a></li>
<li><a href="#L389">SIGPIPE</a></li>
<li><a href="#L434">SIGPOLL</a></li>
<li><a href="#L428">SIGPROF</a></li>
<li><a href="#L392">SIGQUIT</a></li>
<li><a href="#L395">SIGSEGV</a></li>
<li><a href="#L413">SIGSTOP</a></li>
<li><a href="#L437">SIGSYS</a></li>
<li><a href="#L398">SIGTERM</a></li>
<li><a href="#L440">SIGTRAP</a></li>
<li><a href="#L416">SIGTSTP</a></li>
<li><a href="#L419">SIGTTIN</a></li>
<li><a href="#L422">SIGTTOU</a></li>
<li><a href="#L443">SIGURG</a></li>
<li><a href="#L401">SIGUSR1</a></li>
<li><a href="#L404">SIGUSR2</a></li>
<li><a href="#L425">SIGVTALRM</a></li>
<li><a href="#L446">SIGXCPU</a></li>
<li><a href="#L449">SIGXFSZ</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Xavier Leroy <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> Damien Doligez, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Signal handling, code common to the <a href="meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a> <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> native systems */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef USE_MMAP_MAP_STACK<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/callback.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/roots.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/signals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/sys.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memprof.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/finalise.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The set of pending signals (received but not yet processed).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; It is represented as a bit vector.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Valid signal numbers range from 1 to <a href="caml/signals.h.html#L51" title="ocaml/runtime/caml/signals.h:51">NSIG</a> - 1 included.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (This is checked when we install a signal handler.)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Signal 1 is the least significant bit of <a href="caml/signals.h.html#L57" title="ocaml/runtime/caml/signals.h:57">caml_pending_signals</a>[0]. */<br/></li>
<li></span><br/></li>
<li><a id="L44">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">caml_pending_signals</span>[<a href="caml/signals.h.html#L55" title="ocaml/runtime/caml/signals.h:55">NSIG_WORDS</a>];<br/></li>
<li><br/></li>
<li><a id="L46">&#x200c;</a><span class="Type">static</span> <a href="caml/platform.h.html#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a> <span class="linkable">signal_install_mutex</span> = <a href="caml/platform.h.html#L101" title="ocaml/runtime/caml/platform.h:101">CAML_PLAT_MUTEX_INITIALIZER</a>;<br/></li>
<li><br/></li>
<li><a id="L48">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_check_pending_signals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="caml/signals.h.html#L55" title="ocaml/runtime/caml/signals.h:55">NSIG_WORDS</a>; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;<a href="caml/signals.h.html#L57" title="ocaml/runtime/caml/signals.h:57">caml_pending_signals</a>[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Execute all pending signals */<br/></li>
<li></span><br/></li>
<li><a id="L60">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_process_pending_signals_exn</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i, j, signo;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> curr, mask ;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> exn;<br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; sigset_t set;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Check that there is indeed a pending signal before issuing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; syscall in [pthread_sigmask]. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (!<a href="#L48" title="ocaml/runtime/signals.c:48">caml_check_pending_signals</a>())<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; pthread_sigmask(<span class="Comment">/* dummy */</span> SIG_BLOCK, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, &amp;set);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="caml/signals.h.html#L55" title="ocaml/runtime/caml/signals.h:55">NSIG_WORDS</a>; i++) {<br/></li>
<li>&nbsp; &nbsp; curr = <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;<a href="caml/signals.h.html#L57" title="ocaml/runtime/caml/signals.h:57">caml_pending_signals</a>[i]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (curr == <span class="Constant">0</span>) <span class="Statement">goto</span> next_word;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan curr for bits set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; <a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a>; j++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; mask = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)<span class="Constant">1</span> &lt;&lt; j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((curr &amp; mask) == <span class="Constant">0</span>) <span class="Statement">goto</span> next_bit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; signo = i * <a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a> + j + <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sigismember(&amp;set, signo)) <span class="Statement">goto</span> next_bit;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (! <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(&amp;<a href="caml/signals.h.html#L57" title="ocaml/runtime/caml/signals.h:57">caml_pending_signals</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;curr, curr &amp; ~mask)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* curr was refreshed, test it again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curr == <span class="Constant">0</span>) <span class="Statement">goto</span> next_word;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((curr &amp; mask) == <span class="Constant">0</span>) <span class="Statement">goto</span> next_bit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; exn = <a href="#L206" title="ocaml/runtime/signals.c:206">caml_execute_signal_exn</a>(signo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L90" title="ocaml/runtime/caml/mlvalues.h:90">Is_exception_result</a>(exn)) <span class="Statement">return</span> exn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* curr probably changed during the evaluation of the signal handler;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; refresh it from memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; curr = <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;<a href="caml/signals.h.html#L57" title="ocaml/runtime/caml/signals.h:57">caml_pending_signals</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curr == <span class="Constant">0</span>) <span class="Statement">goto</span> next_word;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">next_bit</span><span class="cUserCont">:</span> <span class="Comment">/* skip */</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">next_word</span><span class="cUserCont">:</span> <span class="Comment">/* skip */</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Record the delivery of a signal, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> arrange for it to be processed<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as soon as possible:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - via <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending, processed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="#L360" title="ocaml/runtime/signals.c:360">caml_process_pending_actions</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - by playing with the allocation limit, processed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="minor_gc.c.html#L801" title="ocaml/runtime/minor_gc.c:801">caml_alloc_small_dispatch</a>.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L115">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_record_signal</span>(<span class="Type">int</span> signal_number)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (signal_number &lt;= <span class="Constant">0</span> || signal_number &gt;= <a href="caml/signals.h.html#L51" title="ocaml/runtime/caml/signals.h:51">NSIG</a>) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; i = signal_number - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L77" title="ocaml/runtime/caml/camlatomic.h:77">atomic_fetch_or</a>(&amp;<a href="caml/signals.h.html#L57" title="ocaml/runtime/caml/signals.h:57">caml_pending_signals</a>[i / <a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)<span class="Constant">1</span> &lt;&lt; (i % <a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a>));<br/></li>
<li>&nbsp; <span class="Comment">// </span><span class="Todo">FIXME</span><span class="Comment">: the TLS variable is not thread-safe<br/></li>
<li></span>&nbsp; <a href="domain.c.html#L1520" title="ocaml/runtime/domain.c:1520">caml_interrupt_self</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Management of blocking sections. */<br/></li>
<li></span><br/></li>
<li><a id="L128">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_enter_blocking_section_default</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="domain.c.html#L1706" title="ocaml/runtime/domain.c:1706">caml_bt_exit_ocaml</a>();<br/></li>
<li>&nbsp; <a href="domain.c.html#L1699" title="ocaml/runtime/domain.c:1699">caml_release_domain_lock</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L134">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_leave_blocking_section_default</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="domain.c.html#L1688" title="ocaml/runtime/domain.c:1688">caml_bt_enter_ocaml</a>();<br/></li>
<li>&nbsp; <a href="domain.c.html#L1681" title="ocaml/runtime/domain.c:1681">caml_acquire_domain_lock</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L140">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_enter_blocking_section_hook</span>)(<span class="Type">void</span>) =<br/></li>
<li>&nbsp;&nbsp; <a href="#L128" title="ocaml/runtime/signals.c:128">caml_enter_blocking_section_default</a>;<br/></li>
<li><a id="L142">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_leave_blocking_section_hook</span>)(<span class="Type">void</span>) =<br/></li>
<li>&nbsp;&nbsp; <a href="#L134" title="ocaml/runtime/signals.c:134">caml_leave_blocking_section_default</a>;<br/></li>
<li><br/></li>
<li><a id="L145">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_enter_blocking_section</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> * domain = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>){<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process all pending signals now */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L360" title="ocaml/runtime/signals.c:360">caml_process_pending_actions</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="caml/signals.h.html#L83" title="ocaml/runtime/caml/signals.h:83">caml_enter_blocking_section_hook</a> ();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check again if a signal arrived in the meanwhile. If none,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; done; otherwise, try again. Since we do not hold the domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; lock, we cannot read [young_ptr] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> we cannot call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; [<a href="caml/domain.h.html#L54" title="ocaml/runtime/caml/domain.h:54">Caml_check_gc_interrupt</a>]. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;domain-&gt;young_limit) != <a href="caml/config.h.html#L157" title="ocaml/runtime/caml/config.h:157">UINTNAT_MAX</a>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/signals.h.html#L84" title="ocaml/runtime/caml/signals.h:84">caml_leave_blocking_section_hook</a> ();<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L161">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_enter_blocking_section_no_pending</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/signals.h.html#L83" title="ocaml/runtime/caml/signals.h:83">caml_enter_blocking_section_hook</a> ();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L166">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_leave_blocking_section</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> saved_errno;<br/></li>
<li>&nbsp; <span class="Comment">/* Save the <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> of errno (PR#5982). */<br/></li>
<li></span>&nbsp; saved_errno = errno;<br/></li>
<li>&nbsp; <a href="caml/signals.h.html#L84" title="ocaml/runtime/caml/signals.h:84">caml_leave_blocking_section_hook</a> ();<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L72" title="ocaml/runtime/caml/domain_state.h:72">Caml_check_caml_state</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Some other thread may have switched [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; to 0 even though there are still pending actions, e.g. a signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; masked in the other thread.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Another case where this is necessary (even in a single threaded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; setting) is when the blocking section unmasks a pending signal:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; If the signal is pending <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> masked but signals have already been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; examined by [<a href="#L360" title="ocaml/runtime/signals.c:360">caml_process_pending_actions</a>], then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending] is 0 but the signal needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; handled at this point.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; So we force the examination of signals as soon as possible.<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending || <a href="#L48" title="ocaml/runtime/signals.c:48">caml_check_pending_signals</a>())<br/></li>
<li>&nbsp; &nbsp; <a href="#L289" title="ocaml/runtime/signals.c:289">caml_set_action_pending</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>);<br/></li>
<li><br/></li>
<li>&nbsp; errno = saved_errno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L193">&#x200c;</a><span class="Type">static</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_signal_handlers</span>;<br/></li>
<li><br/></li>
<li><a id="L195">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_init_signal_handling</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> i;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a> = <a href="memory.c.html#L359" title="ocaml/runtime/memory.c:359">caml_alloc_shr</a>(<a href="caml/signals.h.html#L51" title="ocaml/runtime/caml/signals.h:51">NSIG</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="caml/signals.h.html#L51" title="ocaml/runtime/caml/signals.h:51">NSIG</a>; i++)<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(<a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a>, i) = <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>&nbsp; <a href="globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>(&amp;<a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Execute a signal handler immediately */<br/></li>
<li></span><br/></li>
<li><a id="L206">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_execute_signal_exn</span>(<span class="Type">int</span> signal_number, <span class="Type">int</span> in_signal_handler)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> res;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> handler;<br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; sigset_t nsigs, sigs;<br/></li>
<li>&nbsp; <span class="Comment">/* Block the signal before executing the handler, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> record in sigs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the original signal mask */<br/></li>
<li></span>&nbsp; sigemptyset(&amp;nsigs);<br/></li>
<li>&nbsp; sigaddset(&amp;nsigs, signal_number);<br/></li>
<li>&nbsp; pthread_sigmask(SIG_BLOCK, &amp;nsigs, &amp;sigs);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; handler = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(<a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a>, signal_number);<br/></li>
<li>&nbsp; &nbsp; res = <a href="callback.c.html#L134" title="ocaml/runtime/callback.c:134">caml_callback_exn</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; handler,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<a href="#L467" title="ocaml/runtime/signals.c:467">caml_rev_convert_signal_number</a>(signal_number)));<br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (! in_signal_handler) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore the original signal mask */<br/></li>
<li></span>&nbsp; &nbsp; pthread_sigmask(SIG_SETMASK, &amp;sigs, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L90" title="ocaml/runtime/caml/mlvalues.h:90">Is_exception_result</a>(res)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore the original signal mask <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> unblock the signal itself */<br/></li>
<li></span>&nbsp; &nbsp; sigdelset(&amp;sigs, signal_number);<br/></li>
<li>&nbsp; &nbsp; pthread_sigmask(SIG_SETMASK, &amp;sigs, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Arrange for a garbage collection to be performed as soon as possible */<br/></li>
<li></span><br/></li>
<li><a id="L237">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_request_major_slice</span> (<span class="Type">int</span> global)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (global){<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;requested_global_major_slice = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;requested_major_slice = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="domain.c.html#L1520" title="ocaml/runtime/domain.c:1520">caml_interrupt_self</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L247">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_request_minor_gc</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;requested_minor_gc = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <a href="domain.c.html#L1520" title="ocaml/runtime/domain.c:1520">caml_interrupt_self</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Pending asynchronous actions ([<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending])<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ===<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; There are two kinds of asynchronous actions:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; - Those that cannot be delayed but never call OCaml code (STW<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; interrupts, requested minor <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> major GC, forced systhread yield).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; - Those that may raise OCaml exceptions but can be delayed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; (asynchronous callbacks, finalisers, memprof callbacks).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending] records whether an action of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; second kind is currently pending, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> is reset _at the beginning_<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of processing all actions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Hence, when a delayable action is pending, either<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending] is 1, <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> there is a function currently<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; running which is executing all actions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This is used to ensure [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;young_limit] is always set<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; appropriately.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; In case there are two different callbacks (say, a signal <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; finaliser) arriving at the same time, then the processing of one<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; awaits the return of the other. In case of long-running callbacks,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; we may want to run the second one without waiting the end of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; first one. We do this by provoking an additional polling every<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; minor collection <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> every major slice. To guarantee a low latency<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for signals, we avoid delaying signal handlers in that case by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; calling them first.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a href="caml/misc.h.html#L563" title="ocaml/runtime/caml/misc.h:563">CAMLno_tsan</a> <span class="Comment">/* When called from [<a href="#L115" title="ocaml/runtime/signals.c:115">caml_record_signal</a>], these memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; accesses may not be synchronized. Otherwise we assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; that we have unique access to dom_st. */<br/></li>
<li><a id="L289">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_set_action_pending</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> * dom_st)<br/></li>
<li>{<br/></li>
<li>&nbsp; dom_st-&gt;action_pending = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;dom_st-&gt;young_limit, (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)-<span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L295">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_check_pending_actions</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L72" title="ocaml/runtime/caml/domain_state.h:72">Caml_check_caml_state</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/domain.h.html#L54" title="ocaml/runtime/caml/domain.h:54">Caml_check_gc_interrupt</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>) || <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L301">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_do_pending_actions_exn</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* 1. Non-delayable actions that do not run OCaml code. */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Do any pending STW interrupt, minor collection <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> major slice */<br/></li>
<li></span>&nbsp; <a href="domain.c.html#L1650" title="ocaml/runtime/domain.c:1650">caml_handle_gc_interrupt</a>();<br/></li>
<li>&nbsp; <span class="Comment">/* [young_limit] has now been reset. */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* 2. Delayable actions that may raise OCaml exceptions. */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Call signal handlers first */<br/></li>
<li></span>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> exn = <a href="#L60" title="ocaml/runtime/signals.c:60">caml_process_pending_signals_exn</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L90" title="ocaml/runtime/caml/mlvalues.h:90">Is_exception_result</a>(exn)) <span class="Statement">goto</span> exception;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if 0<br/></li>
<li></span><span class="Comment">&nbsp; /* Call memprof callbacks */<br/></li>
<li></span><span class="Comment">&nbsp; exn = caml_memprof_handle_postponed_exn();<br/></li>
<li></span><span class="Comment">&nbsp; if (<a href="caml/mlvalues.h.html#L90" title="ocaml/runtime/caml/mlvalues.h:90">Is_exception_result</a>(exn)) goto exception;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Call finalisers */<br/></li>
<li></span>&nbsp; exn = <a href="finalise.c.html#L145" title="ocaml/runtime/finalise.c:145">caml_final_do_calls_exn</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L90" title="ocaml/runtime/caml/mlvalues.h:90">Is_exception_result</a>(exn)) <span class="Statement">goto</span> exception;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li><br/></li>
<li><span class="Statement">exception</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <span class="Comment">/* If an exception is raised during an asynchronous callback, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; it might be the case that we did not run all the callbacks we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; needed. Therefore, we set [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;action_pending] again in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; order to force reexamination of callbacks. */<br/></li>
<li></span>&nbsp; <a href="#L289" title="ocaml/runtime/signals.c:289">caml_set_action_pending</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> exn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L338">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_process_pending_actions_with_root_exn</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> root)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L295" title="ocaml/runtime/signals.c:295">caml_check_pending_actions</a>()) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a>(root);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> exn = <a href="#L301" title="ocaml/runtime/signals.c:301">caml_do_pending_actions_exn</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L90" title="ocaml/runtime/caml/mlvalues.h:90">Is_exception_result</a>(exn)) <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>(exn);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L404" title="ocaml/runtime/caml/memory.h:404">CAMLdrop</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> root;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L349">&#x200c;</a><a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_process_pending_actions_with_root</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> root)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="fail_nat.c.html#L188" title="ocaml/runtime/fail_nat.c:188">caml_raise_if_exception</a>(<br/></li>
<li>&nbsp; &nbsp; <a href="#L338" title="ocaml/runtime/signals.c:338">caml_process_pending_actions_with_root_exn</a>(root));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L355">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_process_pending_actions_exn</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L338" title="ocaml/runtime/signals.c:338">caml_process_pending_actions_with_root_exn</a>(<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L360">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_process_pending_actions</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L349" title="ocaml/runtime/signals.c:349">caml_process_pending_actions_with_root</a>(<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* OS-independent numbering of signals */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L368" title="ocaml/runtime/signals.c:368">SIGABRT</a><br/></li>
<li><a id="L368">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGABRT</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L371" title="ocaml/runtime/signals.c:371">SIGALRM</a><br/></li>
<li><a id="L371">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGALRM</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L374" title="ocaml/runtime/signals.c:374">SIGFPE</a><br/></li>
<li><a id="L374">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGFPE</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L377" title="ocaml/runtime/signals.c:377">SIGHUP</a><br/></li>
<li><a id="L377">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGHUP</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L380" title="ocaml/runtime/signals.c:380">SIGILL</a><br/></li>
<li><a id="L380">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGILL</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L383" title="ocaml/runtime/signals.c:383">SIGINT</a><br/></li>
<li><a id="L383">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGINT</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L386" title="ocaml/runtime/signals.c:386">SIGKILL</a><br/></li>
<li><a id="L386">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGKILL</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L389" title="ocaml/runtime/signals.c:389">SIGPIPE</a><br/></li>
<li><a id="L389">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGPIPE</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L392" title="ocaml/runtime/signals.c:392">SIGQUIT</a><br/></li>
<li><a id="L392">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGQUIT</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L395" title="ocaml/runtime/signals.c:395">SIGSEGV</a><br/></li>
<li><a id="L395">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGSEGV</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L398" title="ocaml/runtime/signals.c:398">SIGTERM</a><br/></li>
<li><a id="L398">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGTERM</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L401" title="ocaml/runtime/signals.c:401">SIGUSR1</a><br/></li>
<li><a id="L401">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGUSR1</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L404" title="ocaml/runtime/signals.c:404">SIGUSR2</a><br/></li>
<li><a id="L404">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGUSR2</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L407" title="ocaml/runtime/signals.c:407">SIGCHLD</a><br/></li>
<li><a id="L407">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGCHLD</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L410" title="ocaml/runtime/signals.c:410">SIGCONT</a><br/></li>
<li><a id="L410">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGCONT</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L413" title="ocaml/runtime/signals.c:413">SIGSTOP</a><br/></li>
<li><a id="L413">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGSTOP</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L416" title="ocaml/runtime/signals.c:416">SIGTSTP</a><br/></li>
<li><a id="L416">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGTSTP</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L419" title="ocaml/runtime/signals.c:419">SIGTTIN</a><br/></li>
<li><a id="L419">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGTTIN</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L422" title="ocaml/runtime/signals.c:422">SIGTTOU</a><br/></li>
<li><a id="L422">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGTTOU</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L425" title="ocaml/runtime/signals.c:425">SIGVTALRM</a><br/></li>
<li><a id="L425">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGVTALRM</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L428" title="ocaml/runtime/signals.c:428">SIGPROF</a><br/></li>
<li><a id="L428">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGPROF</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L431" title="ocaml/runtime/signals.c:431">SIGBUS</a><br/></li>
<li><a id="L431">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGBUS</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L434" title="ocaml/runtime/signals.c:434">SIGPOLL</a><br/></li>
<li><a id="L434">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGPOLL</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L437" title="ocaml/runtime/signals.c:437">SIGSYS</a><br/></li>
<li><a id="L437">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGSYS</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L440" title="ocaml/runtime/signals.c:440">SIGTRAP</a><br/></li>
<li><a id="L440">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGTRAP</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L443" title="ocaml/runtime/signals.c:443">SIGURG</a><br/></li>
<li><a id="L443">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGURG</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L446" title="ocaml/runtime/signals.c:446">SIGXCPU</a><br/></li>
<li><a id="L446">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGXCPU</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L449" title="ocaml/runtime/signals.c:449">SIGXFSZ</a><br/></li>
<li><a id="L449">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SIGXFSZ</span></span><span class="PreProc"> -</span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L452">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">posix_signals</span>[] = {<br/></li>
<li>&nbsp; <span class="Constant"><a href="#L368" title="ocaml/runtime/signals.c:368">SIGABRT</a></span>, <span class="Constant"><a href="#L371" title="ocaml/runtime/signals.c:371">SIGALRM</a></span>, <span class="Constant"><a href="#L374" title="ocaml/runtime/signals.c:374">SIGFPE</a></span>, <span class="Constant"><a href="#L377" title="ocaml/runtime/signals.c:377">SIGHUP</a></span>, <span class="Constant"><a href="#L380" title="ocaml/runtime/signals.c:380">SIGILL</a></span>, <span class="Constant"><a href="#L383" title="ocaml/runtime/signals.c:383">SIGINT</a></span>, <span class="Constant"><a href="#L386" title="ocaml/runtime/signals.c:386">SIGKILL</a></span>, <span class="Constant"><a href="#L389" title="ocaml/runtime/signals.c:389">SIGPIPE</a></span>,<br/></li>
<li>&nbsp; <span class="Constant"><a href="#L392" title="ocaml/runtime/signals.c:392">SIGQUIT</a></span>, <span class="Constant"><a href="#L395" title="ocaml/runtime/signals.c:395">SIGSEGV</a></span>, <span class="Constant"><a href="#L398" title="ocaml/runtime/signals.c:398">SIGTERM</a></span>, <span class="Constant"><a href="#L401" title="ocaml/runtime/signals.c:401">SIGUSR1</a></span>, <span class="Constant"><a href="#L404" title="ocaml/runtime/signals.c:404">SIGUSR2</a></span>, <span class="Constant"><a href="#L407" title="ocaml/runtime/signals.c:407">SIGCHLD</a></span>, <span class="Constant"><a href="#L410" title="ocaml/runtime/signals.c:410">SIGCONT</a></span>,<br/></li>
<li>&nbsp; <span class="Constant"><a href="#L413" title="ocaml/runtime/signals.c:413">SIGSTOP</a></span>, <span class="Constant"><a href="#L416" title="ocaml/runtime/signals.c:416">SIGTSTP</a></span>, <span class="Constant"><a href="#L419" title="ocaml/runtime/signals.c:419">SIGTTIN</a></span>, <span class="Constant"><a href="#L422" title="ocaml/runtime/signals.c:422">SIGTTOU</a></span>, <span class="Constant"><a href="#L425" title="ocaml/runtime/signals.c:425">SIGVTALRM</a></span>, <span class="Constant"><a href="#L428" title="ocaml/runtime/signals.c:428">SIGPROF</a></span>, <span class="Constant"><a href="#L431" title="ocaml/runtime/signals.c:431">SIGBUS</a></span>,<br/></li>
<li>&nbsp; <span class="Constant"><a href="#L434" title="ocaml/runtime/signals.c:434">SIGPOLL</a></span>, <span class="Constant"><a href="#L437" title="ocaml/runtime/signals.c:437">SIGSYS</a></span>, <span class="Constant"><a href="#L440" title="ocaml/runtime/signals.c:440">SIGTRAP</a></span>, <span class="Constant"><a href="#L443" title="ocaml/runtime/signals.c:443">SIGURG</a></span>, <span class="Constant"><a href="#L446" title="ocaml/runtime/signals.c:446">SIGXCPU</a></span>, <span class="Constant"><a href="#L449" title="ocaml/runtime/signals.c:449">SIGXFSZ</a><br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L459">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_convert_signal_number</span>(<span class="Type">int</span> signo)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (signo &lt; <span class="Constant">0</span> &amp;&amp; signo &gt;= -(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L452" title="ocaml/runtime/signals.c:452">posix_signals</a>) / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">int</span>)))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L452" title="ocaml/runtime/signals.c:452">posix_signals</a>[-signo-<span class="Constant">1</span>];<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> signo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L467">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_rev_convert_signal_number</span>(<span class="Type">int</span> signo)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L452" title="ocaml/runtime/signals.c:452">posix_signals</a>) / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">int</span>); i++)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (signo == <a href="#L452" title="ocaml/runtime/signals.c:452">posix_signals</a>[i]) <span class="Statement">return</span> -i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> signo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L475">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_init_signal_stack</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; stack_t stk;<br/></li>
<li>&nbsp; stk.ss_flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; stk.ss_size = SIGSTKSZ;<br/></li>
<li>&nbsp; <span class="Comment">/* The memory used for the alternate signal stack must not free'd before<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; calling sigaltstack with SS_DISABLE. malloc/mmap is therefore used rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; than <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a> so that if a shutdown path erroneously fails<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; to call <a href="#L511" title="ocaml/runtime/signals.c:511">caml_free_signal_stack</a> then we have a memory leak rather than a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; nasty piece of undefined behaviour forced on the caller. */<br/></li>
<li></span><span class="PreProc">#ifdef USE_MMAP_MAP_STACK<br/></li>
<li></span>&nbsp; stk.ss_sp =<br/></li>
<li>&nbsp; &nbsp; mmap(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, stk.ss_size, PROT_WRITE | PROT_READ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/platform.h.html#L31" title="ocaml/runtime/caml/platform.h:31">MAP_ANONYMOUS</a> | MAP_PRIVATE | MAP_STACK, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (stk.ss_sp == MAP_FAILED)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (sigaltstack(&amp;stk, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; munmap(stk.ss_sp, SIGSTKSZ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; stk.ss_sp = malloc(stk.ss_size);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (stk.ss_sp == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (sigaltstack(&amp;stk, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; free(stk.ss_sp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* USE_MMAP_MAP_STACK */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> stk.ss_sp;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* POSIX_SIGNALS */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L511">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_free_signal_stack</span>(<span class="Type">void</span> * signal_stack)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; stack_t stk, disable;<br/></li>
<li>&nbsp; disable.ss_flags = SS_DISABLE;<br/></li>
<li>&nbsp; disable.ss_sp = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;&nbsp; <span class="Comment">/* not required but avoids a valgrind false alarm */<br/></li>
<li></span>&nbsp; disable.ss_size = SIGSTKSZ; <span class="Comment">/* macOS wants a valid size here */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (sigaltstack(&amp;disable, &amp;stk) &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Failed to reset signal stack (err </span><span class="Special">%d</span><span class="Constant">)&quot;</span>, errno);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* Check whether someone else installed their own signal stack */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (!(stk.ss_flags &amp; SS_DISABLE) &amp;&amp; stk.ss_sp != signal_stack) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Re-activate their signal stack. */<br/></li>
<li></span>&nbsp; &nbsp; sigaltstack(&amp;stk, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* Memory was allocated with malloc/mmap directly (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="#L475" title="ocaml/runtime/signals.c:475">caml_init_signal_stack</a>) */<br/></li>
<li></span><span class="PreProc">#ifdef USE_MMAP_MAP_STACK<br/></li>
<li></span>&nbsp; munmap(signal_stack, SIGSTKSZ);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; free(signal_stack);<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* USE_MMAP_MAP_STACK */<br/></li>
<li></span><span class="PreProc">#endif</span> <span class="Comment">/* POSIX_SIGNALS */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span><span class="Comment">/* This is the alternate signal stack block for domain 0 */<br/></li>
<li><a id="L538">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> * <span class="linkable">caml_signal_stack_0</span> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L541">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_init_signals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* Bound-check trap handling for Power <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> S390x will go here eventually. */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Set up alternate signal stack for domain 0 */<br/></li>
<li></span><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; <a href="#L538" title="ocaml/runtime/signals.c:538">caml_signal_stack_0</a> = <a href="#L475" title="ocaml/runtime/signals.c:475">caml_init_signal_stack</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L538" title="ocaml/runtime/signals.c:538">caml_signal_stack_0</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Failed to allocate signal stack for domain 0&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* gprof installs a signal handler for <a href="#L428" title="ocaml/runtime/signals.c:428">SIGPROF</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Make it run on the alternate signal stack, to prevent segfaults. */<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sigaction act;<br/></li>
<li>&nbsp; &nbsp; sigaction(<span class="Constant"><a href="#L428" title="ocaml/runtime/signals.c:428">SIGPROF</a></span>, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, &amp;act);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((act.sa_flags &amp; SA_SIGINFO) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (act.sa_handler != <span class="Constant">SIG_IGN</span> &amp;&amp; act.sa_handler != <span class="Constant">SIG_DFL</span>)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* found a handler */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((act.sa_flags &amp; SA_ONSTACK) == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; act.sa_flags |= SA_ONSTACK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sigaction(<span class="Constant"><a href="#L428" title="ocaml/runtime/signals.c:428">SIGPROF</a></span>, &amp;act, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L569">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_terminate_signals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; <a href="#L511" title="ocaml/runtime/signals.c:511">caml_free_signal_stack</a>(<a href="#L538" title="ocaml/runtime/signals.c:538">caml_signal_stack_0</a>);<br/></li>
<li>&nbsp; <a href="#L538" title="ocaml/runtime/signals.c:538">caml_signal_stack_0</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Installation of a signal handler (as per [Sys.signal]) */<br/></li>
<li></span><br/></li>
<li><a id="L579">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">handle_signal</span>(<span class="Type">int</span> signal_number)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> saved_errno;<br/></li>
<li>&nbsp; <span class="Comment">/* Save the <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> of errno (PR#5982). */<br/></li>
<li></span>&nbsp; saved_errno = errno;<br/></li>
<li><span class="PreProc">#if !defined(POSIX_SIGNALS) &amp;&amp; !defined(BSD_SIGNALS)<br/></li>
<li></span>&nbsp; signal(signal_number, <a href="#L579" title="ocaml/runtime/signals.c:579">handle_signal</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <a href="#L115" title="ocaml/runtime/signals.c:115">caml_record_signal</a>(signal_number);<br/></li>
<li>&nbsp; errno = saved_errno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L591">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">caml_set_signal_action</span>(<span class="Type">int</span> signo, <span class="Type">int</span> action)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span> (*act)(<span class="Type">int</span> signo), (*oldact)(<span class="Type">int</span> signo);<br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> sigaction sigact, oldsigact;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">switch</span> (action) {<br/></li>
<li>&nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:&nbsp; act = <span class="Constant">SIG_DFL</span>; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:&nbsp; act = <span class="Constant">SIG_IGN</span>; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">default</span>: act = <a href="#L579" title="ocaml/runtime/signals.c:579">handle_signal</a>; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef POSIX_SIGNALS<br/></li>
<li></span>&nbsp; sigact.sa_handler = act;<br/></li>
<li>&nbsp; sigemptyset(&amp;sigact.sa_mask);<br/></li>
<li>&nbsp; sigact.sa_flags = SA_ONSTACK;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (sigaction(signo, &amp;sigact, &amp;oldsigact) == -<span class="Constant">1</span>) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; oldact = oldsigact.sa_handler;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; oldact = signal(signo, act);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (oldact == <span class="Constant">SIG_ERR</span>) <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (oldact == <a href="#L579" title="ocaml/runtime/signals.c:579">handle_signal</a>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span>;<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (oldact == <span class="Constant">SIG_IGN</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L622">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_install_signal_handler</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> signal_number, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> action)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a> (signal_number, action);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L380" title="ocaml/runtime/caml/memory.h:380">CAMLlocal2</a> (res, tmp_signal_handlers);<br/></li>
<li>&nbsp; <span class="Type">int</span> sig, act, oldact;<br/></li>
<li><br/></li>
<li>&nbsp; sig = <a href="#L459" title="ocaml/runtime/signals.c:459">caml_convert_signal_number</a>(<a href="caml/mlvalues.h.html#L82" title="ocaml/runtime/caml/mlvalues.h:82">Int_val</a>(signal_number));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (sig &lt;= <span class="Constant">0</span> || sig &gt;= <a href="caml/signals.h.html#L51" title="ocaml/runtime/caml/signals.h:51">NSIG</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L140" title="ocaml/runtime/fail_nat.c:140">caml_invalid_argument</a>(<span class="Constant">&quot;Sys.signal: unavailable signal&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">switch</span>(action) {<br/></li>
<li>&nbsp; <span class="Statement">case</span> <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">0</span>):&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Signal_default */<br/></li>
<li></span>&nbsp; &nbsp; act = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">case</span> <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">1</span>):&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Signal_ignore */<br/></li>
<li></span>&nbsp; &nbsp; act = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">default</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Signal_handle */<br/></li>
<li></span>&nbsp; &nbsp; act = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; oldact = <a href="#L591" title="ocaml/runtime/signals.c:591">caml_set_signal_action</a>(sig, act);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (oldact) {<br/></li>
<li>&nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* was Signal_default */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* was Signal_ignore */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* was Signal_handle */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="alloc.c.html#L158" title="ocaml/runtime/alloc.c:158">caml_alloc_small</a> (<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(res, <span class="Constant">0</span>) = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(<a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a>, sig);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">default</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> in <a href="#L591" title="ocaml/runtime/signals.c:591">caml_set_signal_action</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(action)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Speculatively allocate this so we don't hold the lock for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; a GC */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a> == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; tmp_signal_handlers = <a href="alloc.c.html#L33" title="ocaml/runtime/alloc.c:33">caml_alloc</a>(<a href="caml/signals.h.html#L51" title="ocaml/runtime/caml/signals.h:51">NSIG</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L46" title="ocaml/runtime/signals.c:46">signal_install_mutex</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a> == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="alloc.c.html#L33" title="ocaml/runtime/alloc.c:33">caml_alloc</a> cannot raise asynchronous exceptions from signals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so this is safe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a> = tmp_signal_handlers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="globroots.c.html#L67" title="ocaml/runtime/globroots.c:67">caml_register_global_root</a>(&amp;<a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L149" title="ocaml/runtime/memory.c:149">caml_modify</a>(&amp;<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(<a href="#L193" title="ocaml/runtime/signals.c:193">caml_signal_handlers</a>, sig), <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(action, <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L46" title="ocaml/runtime/signals.c:46">signal_install_mutex</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="fail_nat.c.html#L188" title="ocaml/runtime/fail_nat.c:188">caml_raise_if_exception</a>(<a href="#L60" title="ocaml/runtime/signals.c:60">caml_process_pending_signals_exn</a>());<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (res);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
