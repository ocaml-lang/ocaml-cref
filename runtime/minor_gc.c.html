<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/minor_gc.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/minor_gc.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L47">caml_major_slice_epoch</a></li>
<li><a href="#L46">caml_minor_collections_count</a></li>
<li><a href="#L51">caml_minor_cycles_started</a></li>
<li><a href="#L49">domains_finished_minor_gc</a></li>
<li><a href="#L232">oldify_scanning_flags</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L144">oldify_state</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L54">alloc_generic_table</a></li>
<li><a href="#L150">alloc_shared</a></li>
<li><a href="#L91">caml_alloc_minor_tables</a></li>
<li><a href="#L801">caml_alloc_small_dispatch</a></li>
<li><a href="#L72">caml_alloc_table</a></li>
<li><a href="#L866">caml_check_urgent_gc</a></li>
<li><a href="#L120">caml_debug_is_major</a></li>
<li><a href="#L116">caml_debug_is_minor</a></li>
<li><a href="#L661">caml_do_opportunistic_major_slice</a></li>
<li><a href="#L445">caml_empty_minor_heap_domain_clear</a></li>
<li><a href="#L748">caml_empty_minor_heap_no_major_slice_from_stw</a></li>
<li><a href="#L458">caml_empty_minor_heap_promote</a></li>
<li><a href="#L677">caml_empty_minor_heap_setup</a></li>
<li><a href="#L783">caml_empty_minor_heaps_once</a></li>
<li><a href="#L107">caml_free_minor_tables</a></li>
<li><a href="#L183">caml_get_header_val</a></li>
<li><a href="#L860">caml_minor_collection</a></li>
<li><a href="#L931">caml_realloc_custom_table</a></li>
<li><a href="#L921">caml_realloc_ephe_ref_table</a></li>
<li><a href="#L911">caml_realloc_ref_table</a></li>
<li><a href="#L125">caml_set_minor_heap_size</a></li>
<li><a href="#L739">caml_stw_empty_minor_heap</a></li>
<li><a href="#L685">caml_stw_empty_minor_heap_no_major_slice</a></li>
<li><a href="#L766">caml_try_stw_empty_minor_heap_on_all_domains</a></li>
<li><a href="#L85">clear_table</a></li>
<li><a href="#L174">get_header_val</a></li>
<li><a href="#L382">oldify_mopup</a></li>
<li><a href="#L237">oldify_one</a></li>
<li><a href="#L876">realloc_generic_table</a></li>
<li><a href="#L100">reset_minor_tables</a></li>
<li><a href="#L77">reset_table</a></li>
<li><a href="#L167">spin_on_header</a></li>
<li><a href="#L188">try_update_object_header</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L16">CAML_INTERNALS</a></li>
<li><a href="#L164">In_progress_update_val</a></li>
<li><a href="#L165">Is_update_in_progress</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Damien Doligez, projet Para, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/custom.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/domain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/runtime_events.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fiber.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/finalise.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/gc_ctrl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/globroots.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/major_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/minor_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/platform.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/roots.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/shared_heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/signals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/startup_aux.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/weak.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">extern</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="weak.c.html#L35" title="ocaml/runtime/weak.c:35">caml_ephe_none</a>; <span class="Comment">/* See weak.c */<br/></li>
<li></span><span class="Type">struct</span> generic_table <a href="caml/minor_gc.h.html#L32" title="ocaml/runtime/caml/minor_gc.h:32">CAML_TABLE_STRUCT</a>(<span class="Type">char</span>);<br/></li>
<li><br/></li>
<li><a id="L46">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">caml_minor_collections_count</span>;<br/></li>
<li><a id="L47">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">caml_major_slice_epoch</span>;<br/></li>
<li><br/></li>
<li><a id="L49">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L33" title="ocaml/runtime/caml/camlatomic.h:33">atomic_intnat</a> <span class="linkable">domains_finished_minor_gc</span>;<br/></li>
<li><br/></li>
<li><a id="L51">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">caml_minor_cycles_started</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* [sz] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [rsv] are numbers of entries */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">alloc_generic_table</span> (<span class="Type">struct</span> generic_table *tbl, <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> rsv, <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> element_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span> *new_table;<br/></li>
<li><br/></li>
<li>&nbsp; tbl-&gt;size = sz;<br/></li>
<li>&nbsp; tbl-&gt;reserve = rsv;<br/></li>
<li>&nbsp; new_table = (<span class="Type">void</span> *) <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>((tbl-&gt;size + tbl-&gt;reserve) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; element_size);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (new_table == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a> (<span class="Constant">&quot;not enough memory&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (tbl-&gt;base != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a> (tbl-&gt;base);<br/></li>
<li>&nbsp; tbl-&gt;base = new_table;<br/></li>
<li>&nbsp; tbl-&gt;ptr = tbl-&gt;base;<br/></li>
<li>&nbsp; tbl-&gt;threshold = tbl-&gt;base + tbl-&gt;size * element_size;<br/></li>
<li>&nbsp; tbl-&gt;limit = tbl-&gt;threshold;<br/></li>
<li>&nbsp; tbl-&gt;end = tbl-&gt;base + (tbl-&gt;size + tbl-&gt;reserve) * element_size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L72">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_alloc_table</span> (<span class="Type">struct</span> caml_ref_table *tbl, <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz, <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> rsv)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L54" title="ocaml/runtime/minor_gc.c:54">alloc_generic_table</a> ((<span class="Type">struct</span> generic_table *) tbl, sz, rsv, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L77">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">reset_table</span> (<span class="Type">struct</span> generic_table *tbl)<br/></li>
<li>{<br/></li>
<li>&nbsp; tbl-&gt;size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; tbl-&gt;reserve = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (tbl-&gt;base != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a> (tbl-&gt;base);<br/></li>
<li>&nbsp; tbl-&gt;base = tbl-&gt;ptr = tbl-&gt;threshold = tbl-&gt;limit = tbl-&gt;end = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L85">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">clear_table</span> (<span class="Type">struct</span> generic_table *tbl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;ptr = tbl-&gt;base;<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;limit = tbl-&gt;threshold;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a>* <span class="linkable">caml_alloc_minor_tables</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a> *r =<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a>));<br/></li>
<li>&nbsp; <span class="Statement">if</span>(r != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; memset(r, <span class="Constant">0</span>, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(*r));<br/></li>
<li>&nbsp; <span class="Statement">return</span> r;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">reset_minor_tables</span>(<span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a>* r)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L77" title="ocaml/runtime/minor_gc.c:77">reset_table</a>((<span class="Type">struct</span> generic_table *)&amp;r-&gt;major_ref);<br/></li>
<li>&nbsp; <a href="#L77" title="ocaml/runtime/minor_gc.c:77">reset_table</a>((<span class="Type">struct</span> generic_table *)&amp;r-&gt;ephe_ref);<br/></li>
<li>&nbsp; <a href="#L77" title="ocaml/runtime/minor_gc.c:77">reset_table</a>((<span class="Type">struct</span> generic_table *)&amp;r-&gt;custom);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L107">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_free_minor_tables</span>(<span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a>* r)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(r-&gt;major_ref.ptr == r-&gt;major_ref.base);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L100" title="ocaml/runtime/minor_gc.c:100">reset_minor_tables</a>(r);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(r);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="Type">extern</span> <span class="Type">int</span> <span class="linkable">caml_debug_is_minor</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> val) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L120">&#x200c;</a><span class="Type">extern</span> <span class="Type">int</span> <span class="linkable">caml_debug_is_major</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> val) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(val) &amp;&amp; !<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(val);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L125">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_set_minor_heap_size</span> (<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> wsize)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a> *r = domain_state-&gt;minor_tables;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (domain_state-&gt;young_ptr != domain_state-&gt;young_end) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a> (EV_C_FORCE_MINOR_SET_MINOR_HEAP_SIZE, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L860" title="ocaml/runtime/minor_gc.c:860">caml_minor_collection</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>(<a href="domain.c.html#L504" title="ocaml/runtime/domain.c:504">caml_reallocate_minor_heap</a>(wsize) &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Fatal <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>: No memory for minor heap&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L100" title="ocaml/runtime/minor_gc.c:100">reset_minor_tables</a>(r);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L144">&#x200c;</a><span class="Type">struct</span> <span class="linkable">oldify_state</span> {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> todo_list;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> live_bytes;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L150">&#x200c;</a><span class="Type">static</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">alloc_shared</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* d,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <a href="caml/mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a> tag, <a href="caml/mlvalues.h.html#L59" title="ocaml/runtime/caml/mlvalues.h:59">reserved_t</a> reserved)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span>* mem = <a href="shared_heap.c.html#L397" title="ocaml/runtime/shared_heap.c:397">caml_shared_try_alloc</a>(d-&gt;shared_heap, wosize, tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reserved, <span class="Constant">0</span> <span class="Comment">/* not pinned */</span>);<br/></li>
<li>&nbsp; d-&gt;allocated_words += <a href="caml/mlvalues.h.html#L178" title="ocaml/runtime/caml/mlvalues.h:178">Whsize_wosize</a>(wosize);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (mem == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;allocation failure during minor GC&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L167" title="ocaml/runtime/caml/mlvalues.h:167">Val_hp</a>(mem);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* in progress updates are zeros except for the lowest color bit set to 1<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that is a header with: wosize == 0 &amp;&amp; color == 1 &amp;&amp; tag == 0 */<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">In_progress_update_val</span> ((<a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a>)</span><span class="Constant">0x100</span><span class="PreProc">)<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Is_update_in_progress</span>(hd) ((hd) == <a href="#L164" title="ocaml/runtime/minor_gc.c:164">In_progress_update_val</a>)<br/></li>
<li></span><br/></li>
<li><a id="L167">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">spin_on_header</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v) {<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L75" title="ocaml/runtime/caml/platform.h:75">SPIN_WAIT</a> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(v)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L174">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> <span class="linkable">get_header_val</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v) {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> hd = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(v));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="#L165" title="ocaml/runtime/minor_gc.c:165">Is_update_in_progress</a>(hd))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hd;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L167" title="ocaml/runtime/minor_gc.c:167">spin_on_header</a>(v);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L183">&#x200c;</a><a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> <span class="linkable">caml_get_header_val</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L174" title="ocaml/runtime/minor_gc.c:174">get_header_val</a>(v);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L188">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">try_update_object_header</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v, <span class="Type">volatile</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *p, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> infix_offset) {<br/></li>
<li>&nbsp; <span class="Type">int</span> success = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>( <a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>() ) {<br/></li>
<li>&nbsp; &nbsp; *<a href="caml/mlvalues.h.html#L163" title="ocaml/runtime/caml/mlvalues.h:163">Hp_val</a> (v) = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>) = result;<br/></li>
<li>&nbsp; &nbsp; success = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> hd = <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(v));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>( hd == <span class="Constant">0</span> ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* in this case this has been updated by another domain, throw away result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> return the one in the object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; result = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> <span class="Statement">if</span>( <a href="#L165" title="ocaml/runtime/minor_gc.c:165">Is_update_in_progress</a>(hd) ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* here we've caught a domain in the process of moving a minor heap object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; we need to wait for it to finish */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L167" title="ocaml/runtime/minor_gc.c:167">spin_on_header</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Also throw away result <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> use the one from the other domain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; result = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Here the header is neither zero nor an in-progress update */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> desired_hd = <a href="#L164" title="ocaml/runtime/minor_gc.c:164">In_progress_update_val</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span>( <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(v), &amp;hd, desired_hd) ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success. Now we can write the forwarding pointer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L60" title="ocaml/runtime/caml/platform.h:60">atomic_store_relaxed</a>(<a href="caml/mlvalues.h.html#L226" title="ocaml/runtime/caml/mlvalues.h:226">Op_atomic_val</a>(v), result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And update header ('release' ensures after update of fwd pointer) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(v), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Let the caller know we were responsible for the update */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Updated by another domain. Spin for that update to complete <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; then throw away the result <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> use the one from the other domain. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="ocaml/runtime/minor_gc.c:167">spin_on_header</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; *p = result + infix_offset;<br/></li>
<li>&nbsp; <span class="Statement">return</span> success;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a> is a no-op outside the minor heap. */<br/></li>
<li><a id="L232">&#x200c;</a></span><span class="Type">static</span> <a href="caml/roots.h.html#L26" title="ocaml/runtime/caml/roots.h:26">scanning_action_flags</a> <span class="linkable">oldify_scanning_flags</span> =<br/></li>
<li>&nbsp; SCANNING_ONLY_YOUNG_VALUES;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Note that the tests on the tag depend on the fact that <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="caml/mlvalues.h.html#L239" title="ocaml/runtime/caml/mlvalues.h:239">Forward_tag</a>, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a> are contiguous. */<br/></li>
<li><a id="L237">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">oldify_one</span> (<span class="Type">void</span>* st_v, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v, <span class="Type">volatile</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *p)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L144" title="ocaml/runtime/minor_gc.c:144">oldify_state</a>* st = st_v;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> result;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> hd;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> sz, i;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> infix_offset;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a> tag;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">tail_call</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (!(<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(v) &amp;&amp; <a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(v))) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not a minor block */<br/></li>
<li></span>&nbsp; &nbsp; *p = v;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; infix_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; hd = <a href="#L174" title="ocaml/runtime/minor_gc.c:174">get_header_val</a>(v);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hd == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* already forwarded, another domain is likely working on this. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *p = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>) + infix_offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; tag = <a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a> (hd);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tag == <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Infix header, retry with the real block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (infix_offset == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; infix_offset = <a href="caml/mlvalues.h.html#L249" title="ocaml/runtime/caml/mlvalues.h:249">Infix_offset_hd</a> (hd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(infix_offset &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; v -= infix_offset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (tag == <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (tag == <a href="caml/mlvalues.h.html#L300" title="ocaml/runtime/caml/mlvalues.h:300">Cont_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> stack_value = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a>(hd) == <span class="Constant">1</span> &amp;&amp; infix_offset == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L150" title="ocaml/runtime/minor_gc.c:150">alloc_shared</a>(st-&gt;domain, <span class="Constant">1</span>, <a href="caml/mlvalues.h.html#L300" title="ocaml/runtime/caml/mlvalues.h:300">Cont_tag</a>, <a href="caml/mlvalues.h.html#L141" title="ocaml/runtime/caml/mlvalues.h:141">Reserved_hd</a>(hd));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>( <a href="#L188" title="ocaml/runtime/minor_gc.c:188">try_update_object_header</a>(v, p, result, <span class="Constant">0</span>) ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/fiber.h.html#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stk = <a href="caml/mlvalues.h.html#L268" title="ocaml/runtime/caml/mlvalues.h:268">Ptr_val</a>(stack_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, <span class="Constant">0</span>) = <a href="caml/mlvalues.h.html#L263" title="ocaml/runtime/caml/mlvalues.h:263">Val_ptr</a>(stk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stk != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="fiber.c.html#L277" title="ocaml/runtime/fiber.c:277">caml_scan_stack</a>(&amp;<a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>, <a href="#L232" title="ocaml/runtime/minor_gc.c:232">oldify_scanning_flags</a>, st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stk, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Conflict - fix up what we allocated on the major heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *<a href="caml/mlvalues.h.html#L163" title="ocaml/runtime/caml/mlvalues.h:163">Hp_val</a>(result) = <a href="caml/gc.h.html#L32" title="ocaml/runtime/caml/gc.h:32">Make_header</a>(<span class="Constant">1</span>, <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, <span class="Constant">0</span>) = <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (tag &lt; <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> field0;<br/></li>
<li>&nbsp; &nbsp; sz = <a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a> (hd);<br/></li>
<li>&nbsp; &nbsp; st-&gt;live_bytes += <a href="caml/mlvalues.h.html#L194" title="ocaml/runtime/caml/mlvalues.h:194">Bhsize_hd</a>(hd);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L150" title="ocaml/runtime/minor_gc.c:150">alloc_shared</a>(st-&gt;domain, sz, tag, <a href="caml/mlvalues.h.html#L141" title="ocaml/runtime/caml/mlvalues.h:141">Reserved_hd</a>(hd));<br/></li>
<li>&nbsp; &nbsp; field0 = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>( <a href="#L188" title="ocaml/runtime/minor_gc.c:188">try_update_object_header</a>(v, p, result, infix_offset) ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sz &gt; <span class="Constant">1</span>){<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, <span class="Constant">0</span>) = field0;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, <span class="Constant">1</span>) = st-&gt;todo_list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; st-&gt;todo_list = v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (sz == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a>(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = field0;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> tail_call;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Conflict - fix up what we allocated on the major heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *<a href="caml/mlvalues.h.html#L163" title="ocaml/runtime/caml/mlvalues.h:163">Hp_val</a>(result) = <a href="caml/gc.h.html#L32" title="ocaml/runtime/caml/gc.h:32">Make_header</a>(sz, <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span>( c = <span class="Constant">0</span>; c &lt; sz ; c++ ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, c) = <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (tag &gt;= <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; sz = <a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a> (hd);<br/></li>
<li>&nbsp; &nbsp; st-&gt;live_bytes += <a href="caml/mlvalues.h.html#L194" title="ocaml/runtime/caml/mlvalues.h:194">Bhsize_hd</a>(hd);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L150" title="ocaml/runtime/minor_gc.c:150">alloc_shared</a>(st-&gt;domain, sz, tag, <a href="caml/mlvalues.h.html#L141" title="ocaml/runtime/caml/mlvalues.h:141">Reserved_hd</a>(hd));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sz; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, i) = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, i);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (infix_offset == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>( !<a href="#L188" title="ocaml/runtime/minor_gc.c:188">try_update_object_header</a>(v, p, result, <span class="Constant">0</span>) ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Conflict */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *<a href="caml/mlvalues.h.html#L163" title="ocaml/runtime/caml/mlvalues.h:163">Hp_val</a>(result) = <a href="caml/gc.h.html#L32" title="ocaml/runtime/caml/gc.h:32">Make_header</a>(sz, <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span>( i = <span class="Constant">0</span>; i &lt; sz ; i++ ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, i) = <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> f;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a> ft;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (tag == <a href="caml/mlvalues.h.html#L239" title="ocaml/runtime/caml/mlvalues.h:239">Forward_tag</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (infix_offset == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; f = <a href="caml/mlvalues.h.html#L240" title="ocaml/runtime/caml/mlvalues.h:240">Forward_val</a> (v);<br/></li>
<li>&nbsp; &nbsp; ft = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a> (f)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; ft = <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a> (<a href="#L174" title="ocaml/runtime/minor_gc.c:174">get_header_val</a>(f) == <span class="Constant">0</span> ? <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(f, <span class="Constant">0</span>) : f);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ft == <a href="caml/mlvalues.h.html#L239" title="ocaml/runtime/caml/mlvalues.h:239">Forward_tag</a> || ft == <a href="caml/mlvalues.h.html#L297" title="ocaml/runtime/caml/mlvalues.h:297">Lazy_tag</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ft == <a href="caml/mlvalues.h.html#L304" title="ocaml/runtime/caml/mlvalues.h:304">Forcing_tag</a> || ft == <a href="caml/mlvalues.h.html#L336" title="ocaml/runtime/caml/mlvalues.h:336">Double_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Do not short-circuit the pointer.&nbsp; Copy as a normal block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a> (hd) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; st-&gt;live_bytes += <a href="caml/mlvalues.h.html#L194" title="ocaml/runtime/caml/mlvalues.h:194">Bhsize_hd</a>(hd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; result = <a href="#L150" title="ocaml/runtime/minor_gc.c:150">alloc_shared</a>(st-&gt;domain, <span class="Constant">1</span>, <a href="caml/mlvalues.h.html#L239" title="ocaml/runtime/caml/mlvalues.h:239">Forward_tag</a>, <a href="caml/mlvalues.h.html#L141" title="ocaml/runtime/caml/mlvalues.h:141">Reserved_hd</a>(hd));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span>( <a href="#L188" title="ocaml/runtime/minor_gc.c:188">try_update_object_header</a>(v, p, result, <span class="Constant">0</span>) ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a> (result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v = f;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> tail_call;<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="caml/mlvalues.h.html#L163" title="ocaml/runtime/caml/mlvalues.h:163">Hp_val</a>(result) = <a href="caml/gc.h.html#L32" title="ocaml/runtime/caml/gc.h:32">Make_header</a>(<span class="Constant">1</span>, <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, <span class="Constant">0</span>) = <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; v = f;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Follow the forwarding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> tail_call;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/*&nbsp; then oldify. */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Finish the work that was put off by [<a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Note that [<a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>] itself is called by <a href="#L382" title="ocaml/runtime/minor_gc.c:382">oldify_mopup</a>, so we<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; have to be careful to remove the first entry from the list before<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; oldifying its fields. */<br/></li>
<li><a id="L382">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">oldify_mopup</span> (<span class="Type">struct</span> <a href="#L144" title="ocaml/runtime/minor_gc.c:144">oldify_state</a>* st, <span class="Type">int</span> do_ephemerons)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v, new_v, f;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> i;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = st-&gt;domain;<br/></li>
<li>&nbsp; <span class="Type">struct</span> caml_ephe_ref_table ephe_ref_table =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;minor_tables-&gt;ephe_ref;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/minor_gc.h.html#L51" title="ocaml/runtime/caml/minor_gc.h:51">caml_ephe_ref_elt</a> *re;<br/></li>
<li>&nbsp; <span class="Type">int</span> redo;<br/></li>
<li><br/></li>
<li><span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; redo = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (st-&gt;todo_list != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; v = st-&gt;todo_list;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* Get the head. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="#L174" title="ocaml/runtime/minor_gc.c:174">get_header_val</a>(v) == <span class="Constant">0</span>); <span class="Comment">/* It must be forwarded. */<br/></li>
<li></span>&nbsp; &nbsp; new_v = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* Follow forward pointer. */<br/></li>
<li></span>&nbsp; &nbsp; st-&gt;todo_list = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a> (new_v, <span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* Remove from list. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; f = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(new_v, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!<a href="caml/misc.h.html#L508" title="ocaml/runtime/caml/misc.h:508">Is_debug_tag</a>(f));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a> (f) &amp;&amp; <a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(f)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a> (st, f, <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a> (new_v));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <a href="caml/mlvalues.h.html#L174" title="ocaml/runtime/caml/mlvalues.h:174">Wosize_val</a> (new_v); i++){<br/></li>
<li>&nbsp; &nbsp; &nbsp; f = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!<a href="caml/misc.h.html#L508" title="ocaml/runtime/caml/misc.h:508">Is_debug_tag</a>(f));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a> (f) &amp;&amp; <a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(f)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a> (st, f, <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a> (new_v) + i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(new_v, i) = f;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L174" title="ocaml/runtime/caml/mlvalues.h:174">Wosize_val</a>(new_v));<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Oldify the key <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> data in the minor heap of all ephemerons touched in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; cycle. We are doing this to avoid introducing a barrier for the end of all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; domains promoting reachable objects <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> having to handle the complexity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; of determining which ephemerons are dead when they <a href="globroots.c.html#L163" title="ocaml/runtime/globroots.c:163">link</a> across domains */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span>( do_ephemerons ) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (re = ephe_ref_table.base;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; re &lt; ephe_ref_table.ptr; re++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *data = re-&gt;offset == <a href="caml/weak.h.html#L70" title="ocaml/runtime/caml/weak.h:70">CAML_EPHE_DATA_OFFSET</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ? &amp;<a href="caml/weak.h.html#L75" title="ocaml/runtime/caml/weak.h:75">Ephe_data</a>(re-&gt;ephe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; : &amp;<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(re-&gt;ephe, re-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v = *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v != <a href="weak.c.html#L35" title="ocaml/runtime/weak.c:35">caml_ephe_none</a> &amp;&amp; <a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(v) &amp;&amp; <a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(v) ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> offs = <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(v) == <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a> ? <a href="caml/mlvalues.h.html#L250" title="ocaml/runtime/caml/mlvalues.h:250">Infix_offset_val</a>(v) : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v -= offs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L174" title="ocaml/runtime/minor_gc.c:174">get_header_val</a>(v) == <span class="Constant">0</span>) { <span class="Comment">/* Value copied to major heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *data = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">0</span>) + offs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>(st, *data, data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; redo = <span class="Constant">1</span>; <span class="Comment">/* oldify_todo_list can still be 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (redo) <span class="Statement">goto</span> again;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L445">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_empty_minor_heap_domain_clear</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a> *minor_tables = domain-&gt;minor_tables;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="finalise.c.html#L299" title="ocaml/runtime/finalise.c:299">caml_final_empty_young</a>(domain);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L85" title="ocaml/runtime/minor_gc.c:85">clear_table</a> ((<span class="Type">struct</span> generic_table *)&amp;minor_tables-&gt;major_ref);<br/></li>
<li>&nbsp; <a href="#L85" title="ocaml/runtime/minor_gc.c:85">clear_table</a> ((<span class="Type">struct</span> generic_table *)&amp;minor_tables-&gt;ephe_ref);<br/></li>
<li>&nbsp; <a href="#L85" title="ocaml/runtime/minor_gc.c:85">clear_table</a> ((<span class="Type">struct</span> generic_table *)&amp;minor_tables-&gt;custom);<br/></li>
<li><br/></li>
<li>&nbsp; domain-&gt;extra_heap_resources_minor = <span class="Constant">0.0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L458">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_empty_minor_heap_promote</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** participating)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a> *self_minor_tables = domain-&gt;minor_tables;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/minor_gc.h.html#L57" title="ocaml/runtime/caml/minor_gc.h:57">caml_custom_elt</a> *elt;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* young_ptr = domain-&gt;young_ptr;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* young_end = domain-&gt;young_end;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> minor_allocated_bytes = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)young_end - (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)young_ptr;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> prev_alloc_words;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L144" title="ocaml/runtime/minor_gc.c:144">oldify_state</a> st = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> **r;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> c, curr_idx;<br/></li>
<li>&nbsp; <span class="Type">int</span> remembered_roots = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="caml/roots.h.html#L29" title="ocaml/runtime/caml/roots.h:29">scan_roots_hook</a> <a href="caml/roots.h.html#L29" title="ocaml/runtime/caml/roots.h:29">scan_roots_hook</a>;<br/></li>
<li><br/></li>
<li>&nbsp; st.domain = domain;<br/></li>
<li><br/></li>
<li>&nbsp; prev_alloc_words = domain-&gt;allocated_words;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Minor collection of domain </span><span class="Special">%d</span><span class="Constant"> starting&quot;</span>, domain-&gt;id);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L207" title="ocaml/runtime/caml/misc.h:207">call_timing_hook</a>(&amp;<a href="misc.c.html#L42" title="ocaml/runtime/misc.c:42">caml_minor_gc_begin_hook</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>( participating[<span class="Constant">0</span>] == <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a> ) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_GLOBAL_ROOTS);<br/></li>
<li>&nbsp; &nbsp; <a href="globroots.c.html#L246" title="ocaml/runtime/globroots.c:246">caml_scan_global_young_roots</a>(<a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>, &amp;st);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_GLOBAL_ROOTS);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li> <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_REMEMBERED_SET);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>( participating_count &gt; <span class="Constant">1</span> ) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> participating_idx = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(domain == <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span>( <span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; participating_count ; i++ ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span>( participating[i] == domain ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; participating_idx = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(participating_idx != -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We use this rather odd scheme because it better smoothes the remainder */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span>( curr_idx = <span class="Constant">0</span>, c = participating_idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr_idx &lt; participating_count; curr_idx++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* foreign_domain = participating[c];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/minor_gc.h.html#L64" title="ocaml/runtime/caml/minor_gc.h:64">caml_minor_tables</a>* foreign_minor_tables =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreign_domain-&gt;minor_tables;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> caml_ref_table* foreign_major_ref =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;foreign_minor_tables-&gt;major_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* calculate the size of the remembered set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> major_ref_size = foreign_major_ref-&gt;ptr - foreign_major_ref-&gt;base;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* number of remembered set entries each domain takes here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> refs_per_domain = (major_ref_size / participating_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* where to start in the remembered set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>** ref_start = foreign_major_ref-&gt;base<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + (curr_idx * refs_per_domain);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* where to end in the remembered set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>** ref_end = foreign_major_ref-&gt;base<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ((curr_idx+<span class="Constant">1</span>) * refs_per_domain);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* if we're the last domain this time, cover all the remaining refs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span>( curr_idx == participating_count-<span class="Constant">1</span> ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;taking remainder&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref_end = foreign_major_ref-&gt;ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;idx: </span><span class="Special">%d</span><span class="Constant">, foreign_domain: </span><span class="Special">%d</span><span class="Constant">, ref_size: %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d, refs_per_domain: %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d, ref_base: </span><span class="Special">%p</span><span class="Constant">, ref_ptr: </span><span class="Special">%p</span><span class="Constant">, ref_start: </span><span class="Special">%p</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;, ref_end: </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; participating_idx, foreign_domain-&gt;id, major_ref_size, refs_per_domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreign_major_ref-&gt;base, foreign_major_ref-&gt;ptr, ref_start, ref_end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span>( r = ref_start ; r &lt; foreign_major_ref-&gt;ptr &amp;&amp; r &lt; ref_end ; r++ )<br/></li>
<li>&nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a> (&amp;st, **r, *r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remembered_roots++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; c = (c+<span class="Constant">1</span>) % participating_count;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we're alone, we just do our own remembered set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span>( r = self_minor_tables-&gt;major_ref.base ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; r &lt; self_minor_tables-&gt;major_ref.ptr ; r++ )<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a> (&amp;st, **r, *r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; remembered_roots++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <a href="domain.c.html#L1242" title="ocaml/runtime/domain.c:1242">caml_global_barrier</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At this point all domains should have gone through all remembered set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; entries. We need to verify that all our remembered set entries are now in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; the major heap <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> promoted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span>( r = self_minor_tables-&gt;major_ref.base ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r &lt; self_minor_tables-&gt;major_ref.ptr ; r++ ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Everything should be promoted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!(<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(**r)) || !(<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(**r)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; <span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* unconditionally promote custom blocks so accounting is correct */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (elt = self_minor_tables-&gt;custom.base;<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; elt &lt; self_minor_tables-&gt;custom.ptr; elt++) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *v = &amp;elt-&gt;block;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(*v) &amp;&amp; <a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(*v)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="memory.c.html#L190" title="ocaml/runtime/memory.c:190">caml_adjust_gc_speed</a>(elt-&gt;mem, elt-&gt;max);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L174" title="ocaml/runtime/minor_gc.c:174">get_header_val</a>(*v) == <span class="Constant">0</span>) { <span class="Comment">/* <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> copied to major heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *v = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(*v, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>(&amp;st, *v, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_FINALIZERS_OLDIFY);<br/></li>
<li>&nbsp; <span class="Comment">/* promote the finalizers unconditionally as we want to avoid barriers */<br/></li>
<li></span>&nbsp; <a href="finalise.c.html#L212" title="ocaml/runtime/finalise.c:212">caml_final_do_young_roots</a> (&amp;<a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>, <a href="#L232" title="ocaml/runtime/minor_gc.c:232">oldify_scanning_flags</a>, &amp;st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; domain, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_FINALIZERS_OLDIFY);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_REMEMBERED_SET_PROMOTE);<br/></li>
<li>&nbsp; <a href="#L382" title="ocaml/runtime/minor_gc.c:382">oldify_mopup</a> (&amp;st, <span class="Constant">1</span>); <span class="Comment">/* ephemerons promoted here */<br/></li>
<li></span>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_REMEMBERED_SET_PROMOTE);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_REMEMBERED_SET);<br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;promoted </span><span class="Special">%d</span><span class="Constant"> roots, %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remembered_roots, st.live_bytes);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <a href="domain.c.html#L1242" title="ocaml/runtime/domain.c:1242">caml_global_barrier</a>();<br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;ref_base: </span><span class="Special">%p</span><span class="Constant">, ref_ptr: </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; self_minor_tables-&gt;major_ref.base, self_minor_tables-&gt;major_ref.ptr);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (r = self_minor_tables-&gt;major_ref.base;<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; r &lt; self_minor_tables-&gt;major_ref.ptr; r++) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vnew = **r;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(vnew)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || (<a href="#L174" title="ocaml/runtime/minor_gc.c:174">get_header_val</a>(vnew) != <span class="Constant">0</span> &amp;&amp; !<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(vnew)));<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (elt = self_minor_tables-&gt;custom.base;<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; elt &lt; self_minor_tables-&gt;custom.ptr; elt++) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vnew = elt-&gt;block;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(vnew)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || (<a href="#L174" title="ocaml/runtime/minor_gc.c:174">get_header_val</a>(vnew) != <span class="Constant">0</span> &amp;&amp; !<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(vnew)));<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_LOCAL_ROOTS);<br/></li>
<li>&nbsp; <a href="roots.c.html#L49" title="ocaml/runtime/roots.c:49">caml_do_local_roots</a>(<br/></li>
<li>&nbsp; &nbsp; &amp;<a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>, <a href="#L232" title="ocaml/runtime/minor_gc.c:232">oldify_scanning_flags</a>, &amp;st,<br/></li>
<li>&nbsp; &nbsp; domain-&gt;local_roots, domain-&gt;current_stack, domain-&gt;gc_regs);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/roots.h.html#L29" title="ocaml/runtime/caml/roots.h:29">scan_roots_hook</a> = <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(&amp;<a href="roots.c.html#L32" title="ocaml/runtime/roots.c:32">caml_scan_roots_hook</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/roots.h.html#L29" title="ocaml/runtime/caml/roots.h:29">scan_roots_hook</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; (*<a href="caml/roots.h.html#L29" title="ocaml/runtime/caml/roots.h:29">scan_roots_hook</a>)(&amp;<a href="#L237" title="ocaml/runtime/minor_gc.c:237">oldify_one</a>, <a href="#L232" title="ocaml/runtime/minor_gc.c:232">oldify_scanning_flags</a>, &amp;st, domain);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_LOCAL_ROOTS_PROMOTE);<br/></li>
<li>&nbsp; <a href="#L382" title="ocaml/runtime/minor_gc.c:382">oldify_mopup</a> (&amp;st, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_LOCAL_ROOTS_PROMOTE);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_LOCAL_ROOTS);<br/></li>
<li><br/></li>
<li>&nbsp; domain-&gt;young_ptr = domain-&gt;young_end;<br/></li>
<li>&nbsp; <span class="Comment">/* Trigger a GC poll when half of the minor heap is filled. At that point, a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * major slice is scheduled. */<br/></li>
<li></span>&nbsp; domain-&gt;young_trigger = domain-&gt;young_start<br/></li>
<li>&nbsp; &nbsp; + (domain-&gt;young_end - domain-&gt;young_start) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; <a href="domain.c.html#L1524" title="ocaml/runtime/domain.c:1524">caml_reset_young_limit</a>(domain);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>( participating_count &gt; <span class="Constant">1</span> ) {<br/></li>
<li>&nbsp; &nbsp; atomic_fetch_add_explicit<br/></li>
<li>&nbsp; &nbsp; &nbsp; (&amp;<a href="#L49" title="ocaml/runtime/minor_gc.c:49">domains_finished_minor_gc</a>, <span class="Constant">1</span>, memory_order_release);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; domain-&gt;stat_minor_words += <a href="caml/mlvalues.h.html#L182" title="ocaml/runtime/caml/mlvalues.h:182">Wsize_bsize</a> (minor_allocated_bytes);<br/></li>
<li>&nbsp; domain-&gt;stat_promoted_words += domain-&gt;allocated_words - prev_alloc_words;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L207" title="ocaml/runtime/caml/misc.h:207">call_timing_hook</a>(&amp;<a href="misc.c.html#L43" title="ocaml/runtime/misc.c:43">caml_minor_gc_end_hook</a>);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_MINOR_PROMOTED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(domain-&gt;allocated_words - prev_alloc_words));<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_MINOR_ALLOCATED, minor_allocated_bytes);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR);<br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Minor collection of domain </span><span class="Special">%d</span><span class="Constant"> completed: </span><span class="Special">%2.0f%%</span><span class="Constant"> of </span><span class="Special">%u</span><span class="Constant"> KB live&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; domain-&gt;id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">100.0</span> * (<span class="Type">double</span>)st.live_bytes / (<span class="Type">double</span>)minor_allocated_bytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span>)(minor_allocated_bytes + <span class="Constant">512</span>)/<span class="Constant">1024</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L661">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_do_opportunistic_major_slice</span><br/></li>
<li>&nbsp; (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_unused, <span class="Type">void</span>* unused)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* NB: need to put guard around the ev logs to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; spam when we poll */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="major_gc.c.html#L1457" title="ocaml/runtime/major_gc.c:1457">caml_opportunistic_major_work_available</a>()) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> log_events = <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;<a href="misc.c.html#L79" title="ocaml/runtime/misc.c:79">caml_verb_gc</a>) &amp; <span class="Constant">0x40</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (log_events) <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_MARK_OPPORTUNISTIC);<br/></li>
<li>&nbsp; &nbsp; <a href="major_gc.c.html#L1697" title="ocaml/runtime/major_gc.c:1697">caml_opportunistic_major_collection_slice</a>(<a href="caml/config.h.html#L264" title="ocaml/runtime/caml/config.h:264">Major_slice_work_min</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (log_events) <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_MARK_OPPORTUNISTIC);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Make sure the minor heap is empty by performing a minor collection<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if needed.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L677">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_empty_minor_heap_setup</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_unused) {<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L49" title="ocaml/runtime/minor_gc.c:49">domains_finished_minor_gc</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Comment">/* Increment the total number of minor collections done in the program */<br/></li>
<li></span>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a> (&amp;<a href="#L46" title="ocaml/runtime/minor_gc.c:46">caml_minor_collections_count</a>, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* must be called within a STW section */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L685">&#x200c;</a></span><span class="linkable">caml_stw_empty_minor_heap_no_major_slice</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span>* unused,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** participating)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>* initial_young_ptr = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>*)domain-&gt;young_ptr;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="domain.c.html#L1310" title="ocaml/runtime/domain.c:1310">caml_domain_is_in_stw</a>());<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">if</span>( participating[<span class="Constant">0</span>] == <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a> ) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L51" title="ocaml/runtime/minor_gc.c:51">caml_minor_cycles_started</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;running stw empty_minor_heap_promote&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L458" title="ocaml/runtime/minor_gc.c:458">caml_empty_minor_heap_promote</a>(domain, participating_count, participating);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* collect gc stats before leaving the barrier */<br/></li>
<li></span>&nbsp; <a href="gc_stats.c.html#L111" title="ocaml/runtime/gc_stats.c:111">caml_collect_gc_stats_sample</a>(domain);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>( participating_count &gt; <span class="Constant">1</span> ) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_LEAVE_BARRIER);<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L75" title="ocaml/runtime/caml/platform.h:75">SPIN_WAIT</a> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L49" title="ocaml/runtime/minor_gc.c:49">domains_finished_minor_gc</a>) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; participating_count) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L661" title="ocaml/runtime/minor_gc.c:661">caml_do_opportunistic_major_slice</a>(domain, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_LEAVE_BARRIER);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_FINALIZERS_ADMIN);<br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;running finalizer data structure book-keeping&quot;</span>);<br/></li>
<li>&nbsp; <a href="finalise.c.html#L294" title="ocaml/runtime/finalise.c:294">caml_final_update_last_minor</a>(domain);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_FINALIZERS_ADMIN);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MINOR_CLEAR);<br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;running stw empty_minor_heap_domain_clear&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L445" title="ocaml/runtime/minor_gc.c:445">caml_empty_minor_heap_domain_clear</a>(domain);<br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>* p = initial_young_ptr; p &lt; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>*)domain-&gt;young_end; ++p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; *p = <a href="caml/misc.h.html#L529" title="ocaml/runtime/caml/misc.h:529">Debug_free_minor</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MINOR_CLEAR);<br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;finished stw empty_minor_heap&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L739">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_stw_empty_minor_heap</span> (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain, <span class="Type">void</span>* unused,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** participating)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L685" title="ocaml/runtime/minor_gc.c:685">caml_stw_empty_minor_heap_no_major_slice</a>(domain, unused,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; participating_count, participating);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* must be called within a STW section&nbsp; */<br/></li>
<li><a id="L748">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_empty_minor_heap_no_major_slice_from_stw</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>* unused,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** participating)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain.h.html#L115" title="ocaml/runtime/caml/domain.h:115">barrier_status</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> = <a href="domain.c.html#L1216" title="ocaml/runtime/domain.c:1216">caml_global_barrier_begin</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span>( <a href="domain.c.html#L1222" title="ocaml/runtime/domain.c:1222">caml_global_barrier_is_final</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>) ) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L677" title="ocaml/runtime/minor_gc.c:677">caml_empty_minor_heap_setup</a>(domain);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="domain.c.html#L1227" title="ocaml/runtime/domain.c:1227">caml_global_barrier_end</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* if we are entering from within a major GC STW section then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; we do not schedule another major collection slice */<br/></li>
<li></span>&nbsp; <a href="#L685" title="ocaml/runtime/minor_gc.c:685">caml_stw_empty_minor_heap_no_major_slice</a>(domain, (<span class="Type">void</span>*)<span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; participating_count, participating);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* must be called outside a STW section */<br/></li>
<li><a id="L766">&#x200c;</a></span><span class="Type">int</span> <span class="linkable">caml_try_stw_empty_minor_heap_on_all_domains</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!<a href="domain.c.html#L1310" title="ocaml/runtime/domain.c:1310">caml_domain_is_in_stw</a>());<br/></li>
<li>&nbsp; <span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;requesting stw empty_minor_heap&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="domain.c.html#L1376" title="ocaml/runtime/domain.c:1376">caml_try_run_on_all_domains_with_spin_work</a>(<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">1</span>, <span class="Comment">/* synchronous */<br/></li>
<li></span>&nbsp; &nbsp; &amp;<a href="#L739" title="ocaml/runtime/minor_gc.c:739">caml_stw_empty_minor_heap</a>, <span class="Constant">0</span>, <span class="Comment">/* stw handler */<br/></li>
<li></span>&nbsp; &nbsp; &amp;<a href="#L677" title="ocaml/runtime/minor_gc.c:677">caml_empty_minor_heap_setup</a>, <span class="Comment">/* leader setup */<br/></li>
<li></span>&nbsp; &nbsp; &amp;<a href="#L661" title="ocaml/runtime/minor_gc.c:661">caml_do_opportunistic_major_slice</a>, <span class="Constant">0</span> <span class="Comment">/* enter spin work */</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* leaves when done by default*/<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* must be called outside a STW section, will retry until we have emptied our<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; minor heap */<br/></li>
<li><a id="L783">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_empty_minor_heaps_once</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> saved_minor_cycle = <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(&amp;<a href="#L51" title="ocaml/runtime/minor_gc.c:51">caml_minor_cycles_started</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!<a href="domain.c.html#L1310" title="ocaml/runtime/domain.c:1310">caml_domain_is_in_stw</a>());<br/></li>
<li>&nbsp; <span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* To handle the case where multiple domains try to execute a minor gc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; STW section */<br/></li>
<li></span>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="#L766" title="ocaml/runtime/minor_gc.c:766">caml_try_stw_empty_minor_heap_on_all_domains</a>();<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (saved_minor_cycle == <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(&amp;<a href="#L51" title="ocaml/runtime/minor_gc.c:51">caml_minor_cycles_started</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Called by minor allocations when [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;young_ptr] reaches<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;young_limit]. We may have to either call memprof <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the gc. */<br/></li>
<li><a id="L801">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_alloc_small_dispatch</span> (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> * dom_st,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> wosize, <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nallocs, <span class="Type">unsigned</span> <span class="Type">char</span>* encoded_alloc_lens)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> whsize = <a href="caml/mlvalues.h.html#L178" title="ocaml/runtime/caml/mlvalues.h:178">Whsize_wosize</a>(wosize);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* First, we un-do the allocation performed in [<a href="caml/memory.h.html#L217" title="ocaml/runtime/caml/memory.h:217">Alloc_small</a>] */<br/></li>
<li></span>&nbsp; dom_st-&gt;young_ptr += whsize;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span>(<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might be here because of an async callback / urgent GC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; request. Take the opportunity to do what has been requested. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; CAML_FROM_CAML)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* In the case of allocations performed from OCaml, execute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; asynchronous callbacks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="fail_nat.c.html#L188" title="ocaml/runtime/fail_nat.c:188">caml_raise_if_exception</a>(<a href="signals.c.html#L301" title="ocaml/runtime/signals.c:301">caml_do_pending_actions_exn</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="domain.c.html#L1650" title="ocaml/runtime/domain.c:1650">caml_handle_gc_interrupt</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* In the case of long-running C code that regularly polls with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [<a href="signals.c.html#L360" title="ocaml/runtime/signals.c:360">caml_process_pending_actions</a>], still force a query of all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; callbacks at every minor collection <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> major slice. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; dom_st-&gt;action_pending = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now, there might be enough room in the minor heap to do our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; allocation. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dom_st-&gt;young_ptr - whsize &gt;= dom_st-&gt;young_start)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If not, then empty the minor heap, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> check again for async<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; callbacks. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_FORCE_MINOR_ALLOC_SMALL, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="domain.c.html#L1589" title="ocaml/runtime/domain.c:1589">caml_poll_gc_work</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Re-do the allocation: we now have enough space in the minor heap. */<br/></li>
<li></span>&nbsp; dom_st-&gt;young_ptr -= whsize;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if 0<br/></li>
<li></span><span class="Comment">&nbsp; /* Check if the allocated block has been sampled by memprof. */<br/></li>
<li></span><span class="Comment">&nbsp; if (dom_st-&gt;young_ptr &lt; caml_memprof_young_trigger) {<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; if(flags &amp; CAML_DO_TRACK) {<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; caml_memprof_track_young(wosize, flags &amp; CAML_FROM_CAML,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nallocs, encoded_alloc_lens);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; /* Until the allocation actually takes place, the heap is in an invalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state (see comments in [caml_memprof_track_young]). Hence, very little<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heap operations are allowed before the actual allocation.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Moreover, [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;young_ptr] should not be modified before the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; allocation, because its <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> has been used as the pointer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; the sampled block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; } else caml_memprof_renew_minor_sample();<br/></li>
<li></span><span class="Comment">&nbsp; }<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Request a minor collection <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> enter as if it were an interrupt.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L860">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_minor_collection</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="signals.c.html#L247" title="ocaml/runtime/signals.c:247">caml_request_minor_gc</a>();<br/></li>
<li>&nbsp; <a href="domain.c.html#L1650" title="ocaml/runtime/domain.c:1650">caml_handle_gc_interrupt</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L866">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_check_urgent_gc</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> extra_root)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain.h.html#L54" title="ocaml/runtime/caml/domain.h:54">Caml_check_gc_interrupt</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>)) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a>(extra_root);<br/></li>
<li>&nbsp; &nbsp; <a href="domain.c.html#L1650" title="ocaml/runtime/domain.c:1650">caml_handle_gc_interrupt</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="caml/memory.h.html#L404" title="ocaml/runtime/caml/memory.h:404">CAMLdrop</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> extra_root;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L876">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">realloc_generic_table</span><br/></li>
<li>(<span class="Type">struct</span> generic_table *tbl, <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> element_size,<br/></li>
<li> <a href="caml/runtime_events.h.html#L134" title="ocaml/runtime/caml/runtime_events.h:134">ev_runtime_counter</a> ev_counter_name,<br/></li>
<li> <span class="Type">char</span> *msg_threshold, <span class="Type">char</span> *msg_growing, <span class="Type">char</span> *msg_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (tbl-&gt;ptr == tbl-&gt;limit);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (tbl-&gt;limit &lt;= tbl-&gt;end);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (tbl-&gt;limit &gt;= tbl-&gt;threshold);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (tbl-&gt;base == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>){<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="ocaml/runtime/minor_gc.c:54">alloc_generic_table</a> (tbl, <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;minor_heap_wsz / <span class="Constant">8</span>, <span class="Constant">256</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; element_size);<br/></li>
<li>&nbsp; }<span class="Statement">else</span> <span class="Statement">if</span> (tbl-&gt;limit == tbl-&gt;threshold){<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a> (ev_counter_name, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x08</span>, msg_threshold, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;limit = tbl-&gt;end;<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L247" title="ocaml/runtime/signals.c:247">caml_request_minor_gc</a> ();<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> sz;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> cur_ptr = tbl-&gt;ptr - tbl-&gt;base;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tbl-&gt;size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; sz = (tbl-&gt;size + tbl-&gt;reserve) * element_size;<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x08</span>, msg_growing, (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>) sz/<span class="Constant">1024</span>);<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;base = <a href="memory.c.html#L573" title="ocaml/runtime/memory.c:573">caml_stat_resize_noexc</a> (tbl-&gt;base, sz);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tbl-&gt;base == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>){<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a> (<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, msg_error);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;end = tbl-&gt;base + (tbl-&gt;size + tbl-&gt;reserve) * element_size;<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;threshold = tbl-&gt;base + tbl-&gt;size * element_size;<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;ptr = tbl-&gt;base + cur_ptr;<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;limit = tbl-&gt;end;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L911">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_realloc_ref_table</span> (<span class="Type">struct</span> caml_ref_table *tbl)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L876" title="ocaml/runtime/minor_gc.c:876">realloc_generic_table</a><br/></li>
<li>&nbsp; &nbsp; ((<span class="Type">struct</span> generic_table *) tbl, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *),<br/></li>
<li>&nbsp; &nbsp;&nbsp; EV_C_REQUEST_MINOR_REALLOC_REF_TABLE,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ref_table threshold crossed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Growing ref_table to %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;dk bytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ref_table overflow&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L921">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_realloc_ephe_ref_table</span> (<span class="Type">struct</span> caml_ephe_ref_table *tbl)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L876" title="ocaml/runtime/minor_gc.c:876">realloc_generic_table</a><br/></li>
<li>&nbsp; &nbsp; ((<span class="Type">struct</span> generic_table *) tbl, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<span class="Type">struct</span> <a href="caml/minor_gc.h.html#L51" title="ocaml/runtime/caml/minor_gc.h:51">caml_ephe_ref_elt</a>),<br/></li>
<li>&nbsp; &nbsp;&nbsp; EV_C_REQUEST_MINOR_REALLOC_EPHE_REF_TABLE,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ephe_ref_table threshold crossed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Growing ephe_ref_table to %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;dk bytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ephe_ref_table overflow&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L931">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_realloc_custom_table</span> (<span class="Type">struct</span> caml_custom_table *tbl)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L876" title="ocaml/runtime/minor_gc.c:876">realloc_generic_table</a><br/></li>
<li>&nbsp; &nbsp; ((<span class="Type">struct</span> generic_table *) tbl, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> (<span class="Type">struct</span> <a href="caml/minor_gc.h.html#L57" title="ocaml/runtime/caml/minor_gc.h:57">caml_custom_elt</a>),<br/></li>
<li>&nbsp; &nbsp;&nbsp; EV_C_REQUEST_MINOR_REALLOC_CUSTOM_TABLE,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;custom_table threshold crossed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Growing custom_table to %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;dk bytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;custom_table overflow&quot;</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
