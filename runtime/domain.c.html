<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/domain.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/domain.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L208">all_domains</a></li>
<li><a href="#L205">all_domains_cond</a></li>
<li><a href="#L204">all_domains_lock</a></li>
<li><a href="#L1725">caml_atfork_hook</a></li>
<li><a href="#L1052">caml_domain_external_interrupt_hook</a></li>
<li><a href="#L1046">caml_domain_initialize_hook</a></li>
<li><a href="#L1049">caml_domain_stop_hook</a></li>
<li><a href="#L1055">caml_domain_terminated_hook</a></li>
<li><a href="#L215">caml_minor_heap_max_wsz</a></li>
<li><a href="#L232">caml_minor_heaps_end</a></li>
<li><a href="#L231">caml_minor_heaps_start</a></li>
<li><a href="#L210">caml_num_domains_running</a></li>
<li><a href="#L285">caml_state</a></li>
<li><a href="#L233">domain_self</a></li>
<li><a href="#L511">next_domain_unique_id</a></li>
<li><a href="#L243">stw_domains</a></li>
<li><a href="#L207">stw_leader</a></li>
<li><a href="#L192">stw_request</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L36">cpu_set_t</a></li>
<li><a href="#L156">dom_internal</a></li>
<li><a href="#L173">dom_internal</a></li>
<li><a href="#L896">domain_ml_values</a></li>
<li><a href="#L921">domain_startup_params</a></li>
<li><a href="#L894">domain_status</a></li>
<li><a href="#L143">interruptor</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L248">add_to_stw_domains</a></li>
<li><a href="#L1542">advance_global_major_slice_epoch</a></li>
<li><a href="#L460">allocate_minor_heap</a></li>
<li><a href="#L934">backup_thread_func</a></li>
<li><a href="#L1681">caml_acquire_domain_lock</a></li>
<li><a href="#L1720">caml_atfork_default</a></li>
<li><a href="#L1688">caml_bt_enter_ocaml</a></li>
<li><a href="#L1706">caml_bt_exit_ocaml</a></li>
<li><a href="#L1664">caml_bt_is_in_blocking_section</a></li>
<li><a href="#L1670">caml_bt_is_self</a></li>
<li><a href="#L1896">caml_domain_dls_get</a></li>
<li><a href="#L1889">caml_domain_dls_set</a></li>
<li><a href="#L1041">caml_domain_external_interrupt_hook_default</a></li>
<li><a href="#L1031">caml_domain_initialize_default</a></li>
<li><a href="#L1310">caml_domain_is_in_stw</a></li>
<li><a href="#L1675">caml_domain_is_multicore</a></li>
<li><a href="#L1758">caml_domain_is_terminating</a></li>
<li><a href="#L1126">caml_domain_spawn</a></li>
<li><a href="#L1036">caml_domain_stop_default</a></li>
<li><a href="#L289">caml_get_domain_state</a></li>
<li><a href="#L1242">caml_global_barrier</a></li>
<li><a href="#L1216">caml_global_barrier_begin</a></li>
<li><a href="#L1227">caml_global_barrier_end</a></li>
<li><a href="#L1222">caml_global_barrier_is_final</a></li>
<li><a href="#L1248">caml_global_barrier_num_domains</a></li>
<li><a href="#L1650">caml_handle_gc_interrupt</a></li>
<li><a href="#L325">caml_handle_incoming_interrupts</a></li>
<li><a href="#L300">caml_incoming_interrupts_queued</a></li>
<li><a href="#L888">caml_init_domain_self</a></li>
<li><a href="#L855">caml_init_domains</a></li>
<li><a href="#L1520">caml_interrupt_self</a></li>
<li><a href="#L1882">caml_ml_domain_cpu_relax</a></li>
<li><a href="#L1202">caml_ml_domain_id</a></li>
<li><a href="#L1208">caml_ml_domain_unique_token</a></li>
<li><a href="#L366">caml_norm_minor_heap_size</a></li>
<li><a href="#L1589">caml_poll_gc_work</a></li>
<li><a href="#L504">caml_reallocate_minor_heap</a></li>
<li><a href="#L1902">caml_recommended_domain_count</a></li>
<li><a href="#L1699">caml_release_domain_lock</a></li>
<li><a href="#L712">caml_reset_domain_lock</a></li>
<li><a href="#L1524">caml_reset_young_limit</a></li>
<li><a href="#L330">caml_send_interrupt</a></li>
<li><a href="#L1496">caml_try_run_on_all_domains</a></li>
<li><a href="#L1508">caml_try_run_on_all_domains_async</a></li>
<li><a href="#L1376">caml_try_run_on_all_domains_with_spin_work</a></li>
<li><a href="#L844">caml_update_minor_heap_max</a></li>
<li><a href="#L346">caml_wait_interrupt_serviced</a></li>
<li><a href="#L414">check_minor_heap</a></li>
<li><a href="#L1253">decrement_stw_domains_still_processing</a></li>
<li><a href="#L535">domain_create</a></li>
<li><a href="#L1764">domain_terminate</a></li>
<li><a href="#L1060">domain_thread_func</a></li>
<li><a href="#L910">free_domain_ml_values</a></li>
<li><a href="#L436">free_minor_heap</a></li>
<li><a href="#L521">fresh_domain_unique_id</a></li>
<li><a href="#L1579">global_major_slice_callback</a></li>
<li><a href="#L307">handle_incoming</a></li>
<li><a href="#L319">handle_incoming_otherwise_relax</a></li>
<li><a href="#L1727">handover_ephemerons</a></li>
<li><a href="#L1739">handover_finalisers</a></li>
<li><a href="#L901">init_domain_ml_values</a></li>
<li><a href="#L993">install_backup_thread</a></li>
<li><a href="#L295">interrupt_domain</a></li>
<li><a href="#L277">next_free_domain</a></li>
<li><a href="#L263">remove_from_stw_domains</a></li>
<li><a href="#L724">reserve_minor_heaps</a></li>
<li><a href="#L1271">stw_handler</a></li>
<li><a href="#L792">stw_resize_minor_heap_reservation</a></li>
<li><a href="#L761">unreserve_minor_heaps</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1214">BARRIER_SENSE_BIT</a></li>
<li><a href="#L138">BT_ENTERING_OCAML</a></li>
<li><a href="#L140">BT_INIT</a></li>
<li><a href="#L137">BT_IN_BLOCKING_SECTION</a></li>
<li><a href="#L139">BT_TERMINATE</a></li>
<li><a href="#L19">CAML_INTERNALS</a></li>
<li><a href="#L21">_GNU_SOURCE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; KC Sivaramakrishnan, Indian Institute of Technology, Madras&nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Stephen Dolan, University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Tom Kelly, OCaml Labs Consultancy&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2021 OCaml Labs Consultancy Ltd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2019 Indian Institute of Technology, Madras&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2019 University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L19">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><a id="L21">&#x200c;</a><span class="PreProc">#define <span class="linkable">_GNU_SOURCE</span>&nbsp; </span><span class="Comment">/* For sched.h CPU_ZERO(3) <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> CPU_COUNT(3) */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;pthread.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#ifdef HAS_GNU_GETAFFINITY_NP<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sched.h&gt;<br/></li>
<li></span><span class="PreProc">#ifdef HAS_PTHREAD_NP_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;pthread_np.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAS_BSD_GETAFFINITY_NP<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;pthread_np.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/cpuset.h&gt;<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="Type">typedef</span> cpuset_t <span class="linkable">cpu_set_t</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef _WIN32<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sysinfoapi.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/backtrace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/backtrace_prim.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/callback.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/debugger.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/domain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/domain_state.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/runtime_events.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fiber.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/finalise.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/gc_ctrl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/globroots.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/intext.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/major_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/minor_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/osdeps.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/platform.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/shared_heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/signals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/startup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/sync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/weak.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The runtime can run stop-the-world (STW) sections, during which all<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; active domains run the same callback in parallel (with a barrier<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mechanism to synchronize within the callback).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Stop-the-world sections are used to handle duties such as:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - minor GC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - major GC phase changes<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Code within the STW callback can have the guarantee that no mutator<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; code runs in parallel -- precisely, the guarantee holds only for<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; code that is followed by a barrier. Furthermore, new domains being<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; spawned are blocked from running any mutator code while a STW<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; section is in progress, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> terminating domains cannot stop until<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; they have participated to all STW sections currently in progress.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; To provide these guarantees:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - Domains must register as STW participants before running any<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; mutator code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - STW sections must not trigger other callbacks into mutator code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (eg. finalisers <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> signal handlers).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; See the comments on [<a href="#L1376" title="ocaml/runtime/domain.c:1376">caml_try_run_on_all_domains_with_spin_work</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; below for more details on the synchronization mechanisms involved.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* For timely handling of STW requests, domains registered as STW<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; participants must be careful to service STW interrupt requests. The<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; compiler inserts &quot;poll points&quot; in mutator code, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the runtime<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; uses a &quot;backup thread&quot; mechanism during blocking sections.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When the main C-stack for a domain enters a blocking call,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; a 'backup thread' becomes responsible for servicing the STW<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; sections on behalf of the domain. Care is needed to hand off duties<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for servicing STW sections between the main pthread <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the backup<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; pthread when <a href="signals.c.html#L145" title="ocaml/runtime/signals.c:145">caml_enter_blocking_section</a> <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a> are called.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When the state for the backup thread is <a href="#L137" title="ocaml/runtime/domain.c:137">BT_IN_BLOCKING_SECTION</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the backup thread will service the STW section.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The state machine for the backup thread (<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> its transitions)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="ocaml/runtime/domain.c:140">BT_INIT</a>&nbsp; &lt;---------------------------------------+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (<a href="#L993" title="ocaml/runtime/domain.c:993">install_backup_thread</a>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; [main pthread]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="#L138" title="ocaml/runtime/domain.c:138">BT_ENTERING_OCAML</a>&nbsp; &lt;-----------------+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">(<a href="signals.c.html#L145" title="ocaml/runtime/signals.c:145">caml_enter_blocking_section</a>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; [main pthread]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>) |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [main pthread]&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="#L137" title="ocaml/runtime/domain.c:137">BT_IN_BLOCKING_SECTION</a>&nbsp; ----------------+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; (<a href="#L1764" title="ocaml/runtime/domain.c:1764">domain_terminate</a>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; [main pthread]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="ocaml/runtime/domain.c:139">BT_TERMINATE</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L934" title="ocaml/runtime/domain.c:934">backup_thread_func</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [backup pthread]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +---------------------------------------------+<br/></li>
<li></span><br/></li>
<li><span class="Comment"> */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BT_IN_BLOCKING_SECTION</span> </span><span class="Constant">0<br/></li>
<li><a id="L138">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BT_ENTERING_OCAML</span> </span><span class="Constant">1<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BT_TERMINATE</span> </span><span class="Constant">2<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BT_INIT</span> </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* control of STW interrupts */<br/></li>
<li><a id="L143">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">interruptor</span> {<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a>* interrupt_word;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a> lock;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L109" title="ocaml/runtime/caml/platform.h:109">caml_plat_cond</a> cond;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Type">int</span> running;<br/></li>
<li>&nbsp; <span class="Type">int</span> terminating;<br/></li>
<li>&nbsp; <span class="Comment">/* unlike the domain ID, this ID number is not reused */<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> unique_id;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> interrupt_pending;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L156">&#x200c;</a><span class="Type">struct</span> <span class="linkable">dom_internal</span> {<br/></li>
<li>&nbsp; <span class="Comment">/* readonly fields, initialised <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> never modified */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> id;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* state;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* backup thread */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> backup_thread_running;<br/></li>
<li>&nbsp; pthread_t backup_thread;<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> backup_thread_msg;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a> domain_lock;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L109" title="ocaml/runtime/caml/platform.h:109">caml_plat_cond</a> domain_cond;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* modified only during STW sections */<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> minor_heap_area_start;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> minor_heap_area_end;<br/></li>
<li>};<br/></li>
<li><a id="L173">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">dom_internal</span> <span class="linkable">dom_internal</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> {<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> domains_still_running;<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> num_domains_still_processing;<br/></li>
<li>&nbsp; <span class="Type">void</span> (*callback)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span>*,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** others_participating);<br/></li>
<li>&nbsp; <span class="Type">void</span>* data;<br/></li>
<li>&nbsp; <span class="Type">void</span> (*enter_spin_callback)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*, <span class="Type">void</span>*);<br/></li>
<li>&nbsp; <span class="Type">void</span>* enter_spin_data;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* barrier state */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> num_domains;<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> barrier;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* participating[<a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>];<br/></li>
<li><a id="L192">&#x200c;</a>} <span class="linkable">stw_request</span> = {<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L31" title="ocaml/runtime/caml/camlatomic.h:31">ATOMIC_UINTNAT_INIT</a>(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L31" title="ocaml/runtime/caml/camlatomic.h:31">ATOMIC_UINTNAT_INIT</a>(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<br/></li>
<li>&nbsp; <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<br/></li>
<li>&nbsp; <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<br/></li>
<li>&nbsp; <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<br/></li>
<li>&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L31" title="ocaml/runtime/caml/camlatomic.h:31">ATOMIC_UINTNAT_INIT</a>(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; { <span class="Constant">0</span> },<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L204">&#x200c;</a><span class="Type">static</span> <a href="caml/platform.h.html#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a> <span class="linkable">all_domains_lock</span> = <a href="caml/platform.h.html#L101" title="ocaml/runtime/caml/platform.h:101">CAML_PLAT_MUTEX_INITIALIZER</a>;<br/></li>
<li><a id="L205">&#x200c;</a><span class="Type">static</span> <a href="caml/platform.h.html#L109" title="ocaml/runtime/caml/platform.h:109">caml_plat_cond</a> <span class="linkable">all_domains_cond</span> =<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L110" title="ocaml/runtime/caml/platform.h:110">CAML_PLAT_COND_INITIALIZER</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li><a id="L207">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="Comment">/* <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* */</span> <span class="linkable">stw_leader</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L208">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a> <span class="linkable">all_domains</span>[<a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>];<br/></li>
<li><br/></li>
<li><a id="L210">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">caml_num_domains_running</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* size of the virtual memory reservation for the minor heap, per domain */<br/></li>
<li><a id="L215">&#x200c;</a></span><a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">caml_minor_heap_max_wsz</span>;<br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; The amount of memory reserved for all minor heaps of all domains is<br/></li>
<li></span><span class="Comment">&nbsp; <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a> * <a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>. Individual domains can allocate<br/></li>
<li></span><span class="Comment">&nbsp; smaller minor heaps, but when a domain calls Gc.set to allocate a bigger minor<br/></li>
<li></span><span class="Comment">&nbsp; heap than this reservation, we perform a new virtual memory reservation based<br/></li>
<li></span><span class="Comment">&nbsp; on the increased minor heap size.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; New domains are created with a minor heap of size<br/></li>
<li></span><span class="Comment">&nbsp; <a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;init_minor_heap_wsz.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; To perform a new virtual memory reservation for the heaps, we stop the world<br/></li>
<li></span><span class="Comment">&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> do a minor collection on all domains.<br/></li>
<li></span><span class="Comment">&nbsp; See [<a href="#L792" title="ocaml/runtime/domain.c:792">stw_resize_minor_heap_reservation</a>].<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L231">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">caml_minor_heaps_start</span>;<br/></li>
<li><a id="L232">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">caml_minor_heaps_end</span>;<br/></li>
<li><a id="L233">&#x200c;</a><span class="Type">static</span> __thread <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* <span class="linkable">domain_self</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This structure is protected by <a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a><br/></li>
<li></span><span class="Comment"> * [0, participating_domains) are all the domains taking part in STW sections<br/></li>
<li></span><span class="Comment"> * [participating_domains, <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>) are all those domains free to be used<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> {<br/></li>
<li>&nbsp; <span class="Type">int</span> participating_domains;<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* domains[<a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>];<br/></li>
<li><a id="L243">&#x200c;</a>} <span class="linkable">stw_domains</span> = {<br/></li>
<li>&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; { <span class="Constant">0</span> }<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L248">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">add_to_stw_domains</span>(<a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* dom) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains &lt; <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>);<br/></li>
<li>&nbsp; <span class="Statement">for</span>(i=<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[i]!=dom; ++i) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(i&lt;<a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* swap passed domain with domain at <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains */<br/></li>
<li></span>&nbsp; dom = <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains];<br/></li>
<li>&nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[i];<br/></li>
<li>&nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[i] = dom;<br/></li>
<li>&nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L263">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">remove_from_stw_domains</span>(<a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* dom) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span>(i=<span class="Constant">0</span>; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[i]!=dom; ++i) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(i&lt;<a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(i &lt; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* swap passed domain to first free domain */<br/></li>
<li></span>&nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains--;<br/></li>
<li>&nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains];<br/></li>
<li>&nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains] = dom;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L277">&#x200c;</a><span class="Type">static</span> <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* <span class="linkable">next_free_domain</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains == <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains &lt; <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[<a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L285">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> __thread <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* <span class="linkable">caml_state</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef HAS_FULL_THREAD_VARIABLES<br/></li>
<li></span><span class="Comment">/* Export a getter for <a href="caml/domain_state.h.html#L52" title="ocaml/runtime/caml/domain_state.h:52">caml_state</a>, to be used in DLLs */<br/></li>
<li><a id="L289">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* <span class="linkable">caml_get_domain_state</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/domain_state.h.html#L52" title="ocaml/runtime/caml/domain_state.h:52">caml_state</a>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L295">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">interrupt_domain</span>(<span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* s)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(s-&gt;interrupt_word, (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)(-<span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L300">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_incoming_interrupts_queued</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.interrupt_pending);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* must NOT be called with s-&gt;lock held */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1271" title="ocaml/runtime/domain.c:1271">stw_handler</a>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain);<br/></li>
<li><a id="L307">&#x200c;</a><span class="Type">static</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">handle_incoming</span>(<span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* s)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> handled = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;s-&gt;interrupt_pending);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (s-&gt;running);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (handled) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;s-&gt;interrupt_pending, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1271" title="ocaml/runtime/domain.c:1271">stw_handler</a>(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;state);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> handled;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L319">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">handle_incoming_otherwise_relax</span> (<span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* self)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="#L307" title="ocaml/runtime/domain.c:307">handle_incoming</a>(self))<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L36" title="ocaml/runtime/caml/platform.h:36">cpu_relax</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L325">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_handle_incoming_interrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L307" title="ocaml/runtime/domain.c:307">handle_incoming</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L330">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_send_interrupt</span>(<span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* target)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* signal that there is an interrupt pending */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;target-&gt;interrupt_pending, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Signal the condition variable, in case the target is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; itself waiting for an interrupt to be processed elsewhere */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;target-&gt;lock);<br/></li>
<li>&nbsp; <a href="platform.c.html#L115" title="ocaml/runtime/platform.c:115">caml_plat_broadcast</a>(&amp;target-&gt;cond); <span class="Comment">// OPT before/after unlock? elide?<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;target-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L295" title="ocaml/runtime/domain.c:295">interrupt_domain</a>(target);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L346">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_wait_interrupt_serviced</span>(<span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* target)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Often, interrupt handlers are fast, so spin for a bit before waiting */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (i=<span class="Constant">0</span>; i&lt;<span class="Constant">1000</span>; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;target-&gt;interrupt_pending)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L36" title="ocaml/runtime/caml/platform.h:36">cpu_relax</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L75" title="ocaml/runtime/caml/platform.h:75">SPIN_WAIT</a> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;target-&gt;interrupt_pending))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L366">&#x200c;</a><a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> <span class="linkable">caml_norm_minor_heap_size</span> (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> wsize)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> bs;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (wsize &lt; <a href="caml/config.h.html#L227" title="ocaml/runtime/caml/config.h:227">Minor_heap_min</a>) wsize = <a href="caml/config.h.html#L227" title="ocaml/runtime/caml/config.h:227">Minor_heap_min</a>;<br/></li>
<li>&nbsp; bs = <a href="platform.c.html#L144" title="ocaml/runtime/platform.c:144">caml_mem_round_up_pages</a>(<a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a> (wsize));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L182" title="ocaml/runtime/caml/mlvalues.h:182">Wsize_bsize</a>(bs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* The current minor heap layout is as follows:<br/></li>
<li></span><br/></li>
<li><span class="Comment">- <a href="shared_heap.c.html#L657" title="ocaml/runtime/shared_heap.c:657">A</a> contiguous memory block of size<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a> * <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>]<br/></li>
<li></span><span class="Comment">&nbsp; is reserved by [<a href="#L855" title="ocaml/runtime/domain.c:855">caml_init_domains</a>]. The boundaries<br/></li>
<li></span><span class="Comment">&nbsp; of this reserved area are stored in the globals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="caml/address_class.h.html#L46" title="ocaml/runtime/caml/address_class.h:46">caml_minor_heaps_start</a>]<br/></li>
<li></span><span class="Comment">&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="caml/address_class.h.html#L47" title="ocaml/runtime/caml/address_class.h:47">caml_minor_heaps_end</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">- Each domain gets a reserved section of this block<br/></li>
<li></span><span class="Comment">&nbsp; of size [<a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>], whose boundaries are stored as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start]<br/></li>
<li></span><span class="Comment">&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_end]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; These variables accessed in [<a href="#L792" title="ocaml/runtime/domain.c:792">stw_resize_minor_heap_reservation</a>],<br/></li>
<li></span><span class="Comment">&nbsp; synchronized by a global barrier.<br/></li>
<li></span><br/></li>
<li><span class="Comment">- Each domain then commits a <a href="startup_nat.c.html#L50" title="ocaml/runtime/startup_nat.c:50">segment</a> of size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [domain_state-&gt;minor_heap_wsz]<br/></li>
<li></span><span class="Comment">&nbsp; starting at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [domain_state-&gt;minor_heap_area_start]<br/></li>
<li></span><span class="Comment">&nbsp; that it actually uses.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This is done below in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="#L504" title="ocaml/runtime/domain.c:504">caml_reallocate_minor_heap</a>]<br/></li>
<li></span><span class="Comment">&nbsp; which is called both at domain-initialization (by [<a href="#L535" title="ocaml/runtime/domain.c:535">domain_create</a>])<br/></li>
<li></span><span class="Comment">&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> if a request comes to change the minor heap size.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The boundaries of this committed memory area are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [domain_state-&gt;young_start]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [domain_state-&gt;young_end].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Those [young_{start,end}] variables are never accessed by another<br/></li>
<li></span><span class="Comment">&nbsp; domain, so they need no synchronization.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L414">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">check_minor_heap</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(domain_state-&gt;young_ptr == domain_state-&gt;young_end);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;young_start: </span><span class="Special">%p</span><span class="Constant">, young_end: </span><span class="Special">%p</span><span class="Constant">, minor_heap_area_start: </span><span class="Special">%p</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Constant">&quot; minor_heap_area_end: </span><span class="Special">%p</span><span class="Constant">, minor_heap_wsz: %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L75" title="ocaml/runtime/caml/config.h:75">ARCH_SIZET_PRINTF_FORMAT</a> <span class="Constant">&quot;u words&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain_state-&gt;young_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain_state-&gt;young_end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_end,<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain_state-&gt;minor_heap_wsz);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<br/></li>
<li>&nbsp; &nbsp; (<span class="Comment">/* uninitialized minor heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; domain_state-&gt;young_start == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &amp;&amp; domain_state-&gt;young_end == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; ||<br/></li>
<li>&nbsp; &nbsp; (<span class="Comment">/* initialized minor heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; domain_state-&gt;young_start == (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start<br/></li>
<li>&nbsp; &nbsp; &nbsp; &amp;&amp; domain_state-&gt;young_end &lt;= (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_end));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L436">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">free_minor_heap</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;trying to free old minor heap: %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L75" title="ocaml/runtime/caml/config.h:75">ARCH_SIZET_PRINTF_FORMAT</a> <span class="Constant">&quot;uk words&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;minor_heap_wsz / <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L414" title="ocaml/runtime/domain.c:414">check_minor_heap</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* free old minor heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; instead of unmapping the heap, we decommit it, so there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; no race whereby other code could attempt to reuse the memory. */<br/></li>
<li></span>&nbsp; <a href="platform.c.html#L199" title="ocaml/runtime/platform.c:199">caml_mem_decommit</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<span class="Type">void</span>*)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(domain_state-&gt;minor_heap_wsz));<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;young_start&nbsp;&nbsp; = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;young_end&nbsp; &nbsp;&nbsp; = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;young_ptr&nbsp; &nbsp;&nbsp; = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;young_trigger = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;domain_state-&gt;young_limit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) domain_state-&gt;young_start);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L460">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">allocate_minor_heap</span>(<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> wsize) {<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L414" title="ocaml/runtime/domain.c:414">check_minor_heap</a>();<br/></li>
<li><br/></li>
<li>&nbsp; wsize = <a href="#L366" title="ocaml/runtime/domain.c:366">caml_norm_minor_heap_size</a>(wsize);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (wsize &lt;= <a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;trying to allocate minor heap: %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L75" title="ocaml/runtime/caml/config.h:75">ARCH_SIZET_PRINTF_FORMAT</a> <span class="Constant">&quot;uk words&quot;</span>, wsize / <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="platform.c.html#L191" title="ocaml/runtime/platform.c:191">caml_mem_commit</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>*)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start, <a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(wsize))) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>* p = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>*)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;<br/></li>
<li>&nbsp; &nbsp; &nbsp; p &lt; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>*)(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start + <a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(wsize));<br/></li>
<li>&nbsp; &nbsp; &nbsp; p++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; *p = <a href="caml/misc.h.html#L529" title="ocaml/runtime/caml/misc.h:529">Debug_free_minor</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; domain_state-&gt;minor_heap_wsz = wsize;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;young_start = (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start;<br/></li>
<li>&nbsp; domain_state-&gt;young_end =<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;minor_heap_area_start + <a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(wsize));<br/></li>
<li>&nbsp; domain_state-&gt;young_ptr = domain_state-&gt;young_end;<br/></li>
<li>&nbsp; <span class="Comment">/* Trigger a GC poll when half of the minor heap is filled. At that point, a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * major slice is scheduled. */<br/></li>
<li></span>&nbsp; domain_state-&gt;young_trigger = domain_state-&gt;young_start<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + (domain_state-&gt;young_end - domain_state-&gt;young_start) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; <a href="#L1524" title="ocaml/runtime/domain.c:1524">caml_reset_young_limit</a>(domain_state);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L414" title="ocaml/runtime/domain.c:414">check_minor_heap</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L504">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_reallocate_minor_heap</span>(<a href="caml/misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> wsize)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L436" title="ocaml/runtime/domain.c:436">free_minor_heap</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L460" title="ocaml/runtime/domain.c:460">allocate_minor_heap</a>(wsize);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This variable is owned by [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>]. */<br/></li>
<li><a id="L511">&#x200c;</a></span><span class="Type">static</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">next_domain_unique_id</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Precondition: you must own [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Specification:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - returns 0 on the first call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; (we want the main domain to have unique_id 0)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - returns distinct ids unless there is an overflow<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - never returns 0 again, even in presence of overflow.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L521">&#x200c;</a></span><span class="Type">static</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">fresh_domain_unique_id</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> next = <a href="#L511" title="ocaml/runtime/domain.c:511">next_domain_unique_id</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* On 32-bit systems, there is a risk of wraparound of the unique<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; id counter. We have decided to let that happen <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> live with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; it, but we still ensure that id 0 is not reused, to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; having new domains believe that they are the main domain. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L511" title="ocaml/runtime/domain.c:511">next_domain_unique_id</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L511" title="ocaml/runtime/domain.c:511">next_domain_unique_id</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> next;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* must be run on the domain's thread */<br/></li>
<li><a id="L535">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">domain_create</span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> initial_minor_heap_wsize) {<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* d = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* s;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> stack_wsize = <a href="fiber.c.html#L51" title="ocaml/runtime/fiber.c:51">caml_get_init_stack_wsize</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a> == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* take the <a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a> so that we can alter the STW participant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; set atomically */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Wait until any in-progress STW sections end. */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* [<a href="platform.c.html#L109" title="ocaml/runtime/platform.c:109">caml_plat_wait</a>] releases [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>] until the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; STW section ends, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> then takes the lock again. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="platform.c.html#L109" title="ocaml/runtime/platform.c:109">caml_plat_wait</a>(&amp;<a href="#L205" title="ocaml/runtime/domain.c:205">all_domains_cond</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; d = <a href="#L277" title="ocaml/runtime/domain.c:277">next_free_domain</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (d == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">goto</span> domain_init_complete;<br/></li>
<li><br/></li>
<li>&nbsp; s = &amp;d-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!s-&gt;running);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!s-&gt;interrupt_pending);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a> = d;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* If the chosen domain slot has not been previously used, allocate a fresh<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; domain state. Otherwise, reuse it.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Reusing the slot ensures that the GC stats are not lost:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; - Heap stats are moved to the free list on domain termination,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; so we don't reuse those stats (<a href="shared_heap.c.html#L102" title="ocaml/runtime/shared_heap.c:102">caml_init_shared_heap</a> will reset them)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; - But currently there is no orphaning process for allocation stats,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; we just reuse the previous stats from the previous domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; with the same index.<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (d-&gt;state == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">FIXME</span><span class="Comment">: Never freed. Not clear when to. */<br/></li>
<li></span>&nbsp; &nbsp; domain_state = (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="memory.c.html#L609" title="ocaml/runtime/memory.c:609">caml_stat_calloc_noexc</a>(<span class="Constant">1</span>, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (domain_state == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> domain_init_complete;<br/></li>
<li>&nbsp; &nbsp; d-&gt;state = domain_state;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; domain_state = d-&gt;state;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L52" title="ocaml/runtime/caml/domain_state.h:52">caml_state</a> = domain_state;<br/></li>
<li><br/></li>
<li>&nbsp; s-&gt;unique_id = <a href="#L521" title="ocaml/runtime/domain.c:521">fresh_domain_unique_id</a>();<br/></li>
<li>&nbsp; s-&gt;interrupt_word = &amp;domain_state-&gt;young_limit;<br/></li>
<li>&nbsp; s-&gt;running = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="caml/domain.h.html#L91" title="ocaml/runtime/caml/domain.h:91">caml_num_domains_running</a>, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;d-&gt;domain_lock);<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;id = d-&gt;id;<br/></li>
<li>&nbsp; domain_state-&gt;unique_id = d-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.unique_id;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!d-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.interrupt_pending);<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;extra_heap_resources = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; domain_state-&gt;extra_heap_resources_minor = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;dependent_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain_state-&gt;dependent_allocated = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;major_work_done_between_slices = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* the minor heap will be initialized by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [<a href="#L504" title="ocaml/runtime/domain.c:504">caml_reallocate_minor_heap</a>] below. */<br/></li>
<li></span>&nbsp; domain_state-&gt;young_start = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;young_end = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;young_ptr = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;young_trigger = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;minor_tables = <a href="minor_gc.c.html#L91" title="ocaml/runtime/minor_gc.c:91">caml_alloc_minor_tables</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span>(domain_state-&gt;minor_tables == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">goto</span> alloc_minor_tables_failure;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; d-&gt;state-&gt;shared_heap = <a href="shared_heap.c.html#L102" title="ocaml/runtime/shared_heap.c:102">caml_init_shared_heap</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span>(d-&gt;state-&gt;shared_heap == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">goto</span> init_shared_heap_failure;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="major_gc.c.html#L1874" title="ocaml/runtime/major_gc.c:1874">caml_init_major_gc</a>(domain_state) &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">goto</span> init_major_gc_failure;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>(<a href="#L504" title="ocaml/runtime/domain.c:504">caml_reallocate_minor_heap</a>(initial_minor_heap_wsize) &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">goto</span> reallocate_minor_heap_failure;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;dls_root = <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>&nbsp; <a href="globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>(&amp;domain_state-&gt;dls_root);<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;stack_cache = <a href="fiber.c.html#L81" title="ocaml/runtime/fiber.c:81">caml_alloc_stack_cache</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span>(domain_state-&gt;stack_cache == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">goto</span> create_stack_cache_failure;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;extern_state = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;intern_state = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;current_stack =<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="fiber.c.html#L550" title="ocaml/runtime/fiber.c:550">caml_alloc_main_stack</a>(stack_wsize);<br/></li>
<li>&nbsp; <span class="Statement">if</span>(domain_state-&gt;current_stack == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">goto</span> alloc_main_stack_failure;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;c_stack = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;exn_handler = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;action_pending = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;gc_regs_buckets = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;gc_regs = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;allocated_words = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain_state-&gt;swept_words = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;local_roots = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;backtrace_buffer = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;backtrace_last_exn = <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>&nbsp; domain_state-&gt;backtrace_active = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>(&amp;domain_state-&gt;backtrace_last_exn);<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;compare_unordered = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain_state-&gt;oo_next_id_local = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;requested_major_slice = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain_state-&gt;requested_minor_gc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain_state-&gt;major_slice_epoch = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain_state-&gt;requested_external_interrupt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;parser_trace = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;backtrace_enabled) {<br/></li>
<li>&nbsp; &nbsp; <a href="backtrace.c.html#L33" title="ocaml/runtime/backtrace.c:33">caml_record_backtraces</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef NATIVE_CODE<br/></li>
<li></span>&nbsp; domain_state-&gt;external_raise = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain_state-&gt;trap_sp_off = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; domain_state-&gt;trap_barrier_off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain_state-&gt;trap_barrier_block = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <a href="#L1524" title="ocaml/runtime/domain.c:1524">caml_reset_young_limit</a>(domain_state);<br/></li>
<li>&nbsp; <a href="#L248" title="ocaml/runtime/domain.c:248">add_to_stw_domains</a>(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>);<br/></li>
<li>&nbsp; <span class="Statement">goto</span> domain_init_complete;<br/></li>
<li><br/></li>
<li><span class="Statement">alloc_main_stack_failure</span><span class="cUserCont">:<br/></li>
<li></span><span class="Statement">create_stack_cache_failure</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="globroots.c.html#L113" title="ocaml/runtime/globroots.c:113">caml_remove_generational_global_root</a>(&amp;domain_state-&gt;dls_root);<br/></li>
<li><span class="Statement">reallocate_minor_heap_failure</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="major_gc.c.html#L1917" title="ocaml/runtime/major_gc.c:1917">caml_teardown_major_gc</a>();<br/></li>
<li><span class="Statement">init_major_gc_failure</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="shared_heap.c.html#L134" title="ocaml/runtime/shared_heap.c:134">caml_teardown_shared_heap</a>(d-&gt;state-&gt;shared_heap);<br/></li>
<li><span class="Statement">init_shared_heap_failure</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="minor_gc.c.html#L107" title="ocaml/runtime/minor_gc.c:107">caml_free_minor_tables</a>(domain_state-&gt;minor_tables);<br/></li>
<li>&nbsp; domain_state-&gt;minor_tables = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><span class="Statement">alloc_minor_tables_failure</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Statement">domain_init_complete</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;domain init complete&quot;</span>);<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L712">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_reset_domain_lock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* self = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>;<br/></li>
<li>&nbsp; <span class="Comment">// This is only used to reset the domain_lock state on fork.<br/></li>
<li></span>&nbsp; <a href="platform.c.html#L47" title="ocaml/runtime/platform.c:47">caml_plat_mutex_init</a>(&amp;self-&gt;domain_lock);<br/></li>
<li>&nbsp; <a href="platform.c.html#L103" title="ocaml/runtime/platform.c:103">caml_plat_cond_init</a>(&amp;self-&gt;domain_cond, &amp;self-&gt;domain_lock);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* minor heap initialization <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> resizing */<br/></li>
<li></span><br/></li>
<li><a id="L724">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">reserve_minor_heaps</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <span class="Type">void</span>* heaps_base;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> minor_heap_reservation_bsize;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> minor_heap_max_bsz;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="platform.c.html#L144" title="ocaml/runtime/platform.c:144">caml_mem_round_up_pages</a>(<a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(<a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; == <a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(<a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>));<br/></li>
<li><br/></li>
<li>&nbsp; minor_heap_max_bsz = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)<a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(<a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>);<br/></li>
<li>&nbsp; minor_heap_reservation_bsize = minor_heap_max_bsz * <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* reserve memory space for minor heaps */<br/></li>
<li></span>&nbsp; heaps_base = <a href="platform.c.html#L158" title="ocaml/runtime/platform.c:158">caml_mem_map</a>(minor_heap_reservation_bsize, <a href="platform.c.html#L141" title="ocaml/runtime/platform.c:141">caml_plat_pagesize</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span> <span class="Comment">/* reserve_only */</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (heaps_base == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Not enough heap memory to reserve minor heaps&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/address_class.h.html#L46" title="ocaml/runtime/caml/address_class.h:46">caml_minor_heaps_start</a> = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) heaps_base;<br/></li>
<li>&nbsp; <a href="caml/address_class.h.html#L47" title="ocaml/runtime/caml/address_class.h:47">caml_minor_heaps_end</a> = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) heaps_base + minor_heap_reservation_bsize;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;new minor heap reserved from </span><span class="Special">%p</span><span class="Constant"> to </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)<a href="caml/address_class.h.html#L46" title="ocaml/runtime/caml/address_class.h:46">caml_minor_heaps_start</a>, (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)<a href="caml/address_class.h.html#L47" title="ocaml/runtime/caml/address_class.h:47">caml_minor_heaps_end</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* dom = &amp;<a href="#L208" title="ocaml/runtime/domain.c:208">all_domains</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> domain_minor_heap_area = <a href="caml/address_class.h.html#L46" title="ocaml/runtime/caml/address_class.h:46">caml_minor_heaps_start</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; minor_heap_max_bsz * (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dom-&gt;minor_heap_area_start = domain_minor_heap_area;<br/></li>
<li>&nbsp; &nbsp; dom-&gt;minor_heap_area_end =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; domain_minor_heap_area + minor_heap_max_bsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(dom-&gt;minor_heap_area_end &lt;= <a href="caml/address_class.h.html#L47" title="ocaml/runtime/caml/address_class.h:47">caml_minor_heaps_end</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L761">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">unreserve_minor_heaps</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;<a href="#L761" title="ocaml/runtime/domain.c:761">unreserve_minor_heaps</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* dom = &amp;<a href="#L208" title="ocaml/runtime/domain.c:208">all_domains</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* this domain is not running */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; !dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.running<br/></li>
<li>&nbsp; &nbsp; &nbsp; || (<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> its minor heap must already be uninitialized */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dom-&gt;state != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; dom-&gt;state-&gt;young_start == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; dom-&gt;state-&gt;young_end == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; ));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.running does not guarantee that dom-&gt;state is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; correctly initialized, but domain initialization cannot run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; concurrently with STW sections so we cannot observe partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; initialization states. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* uninitialize the minor heap area */<br/></li>
<li></span>&nbsp; &nbsp; dom-&gt;minor_heap_area_start = dom-&gt;minor_heap_area_end = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; size = <a href="caml/address_class.h.html#L47" title="ocaml/runtime/caml/address_class.h:47">caml_minor_heaps_end</a> - <a href="caml/address_class.h.html#L46" title="ocaml/runtime/caml/address_class.h:46">caml_minor_heaps_start</a>;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L181" title="ocaml/runtime/caml/mlvalues.h:181">Bsize_wsize</a>(<a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>) * <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a> == size);<br/></li>
<li>&nbsp; <a href="platform.c.html#L208" title="ocaml/runtime/platform.c:208">caml_mem_unmap</a>((<span class="Type">void</span> *) <a href="caml/address_class.h.html#L46" title="ocaml/runtime/caml/address_class.h:46">caml_minor_heaps_start</a>, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L792">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">stw_resize_minor_heap_reservation</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span>* minor_wsz_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** participating) {<br/></li>
<li>&nbsp; <a href="caml/domain.h.html#L115" title="ocaml/runtime/caml/domain.h:115">barrier_status</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> new_minor_wsz = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) minor_wsz_data;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;<a href="#L792" title="ocaml/runtime/domain.c:792">stw_resize_minor_heap_reservation</a>: &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="minor_gc.c.html#L748" title="ocaml/runtime/minor_gc.c:748">caml_empty_minor_heap_no_major_slice_from_stw</a>&quot;</span>);<br/></li>
<li>&nbsp; <a href="minor_gc.c.html#L748" title="ocaml/runtime/minor_gc.c:748">caml_empty_minor_heap_no_major_slice_from_stw</a>(domain, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; participating_count, participating);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;<a href="#L792" title="ocaml/runtime/domain.c:792">stw_resize_minor_heap_reservation</a>: <a href="#L436" title="ocaml/runtime/domain.c:436">free_minor_heap</a>&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L436" title="ocaml/runtime/domain.c:436">free_minor_heap</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> = <a href="#L1216" title="ocaml/runtime/domain.c:1216">caml_global_barrier_begin</a> ();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L1222" title="ocaml/runtime/domain.c:1222">caml_global_barrier_is_final</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_DOMAIN_RESIZE_HEAP_RESERVATION);<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;<a href="#L792" title="ocaml/runtime/domain.c:792">stw_resize_minor_heap_reservation</a>: &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L761" title="ocaml/runtime/domain.c:761">unreserve_minor_heaps</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L761" title="ocaml/runtime/domain.c:761">unreserve_minor_heaps</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* new_minor_wsz is page-aligned because <a href="#L366" title="ocaml/runtime/domain.c:366">caml_norm_minor_heap_size</a> has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; been called to normalize it earlier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a> = new_minor_wsz;<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;<a href="#L792" title="ocaml/runtime/domain.c:792">stw_resize_minor_heap_reservation</a>: <a href="#L724" title="ocaml/runtime/domain.c:724">reserve_minor_heaps</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L724" title="ocaml/runtime/domain.c:724">reserve_minor_heaps</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The call to [<a href="#L724" title="ocaml/runtime/domain.c:724">reserve_minor_heaps</a>] makes a new reservation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> it also updates the reservation boundaries of each domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; by mutating its [minor_heap_area_start{,_end}] variables.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; These variables are synchronized by the fact that we are inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; a STW section: no other domains are running in parallel, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; the participating domains will synchronize with this write by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; exiting the barrier, before they read those variables in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; [<a href="#L460" title="ocaml/runtime/domain.c:460">allocate_minor_heap</a>] below. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_DOMAIN_RESIZE_HEAP_RESERVATION);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L1227" title="ocaml/runtime/domain.c:1227">caml_global_barrier_end</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;<a href="#L792" title="ocaml/runtime/domain.c:792">stw_resize_minor_heap_reservation</a>: &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L460" title="ocaml/runtime/domain.c:460">allocate_minor_heap</a>&quot;</span>);<br/></li>
<li>&nbsp; <span class="Comment">/* Note: each domain allocates its own minor heap. This seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; important to get good NUMA behavior. We don't want a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; domain to allocate all minor heaps, which could create locality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; issues we don't understand very well. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L460" title="ocaml/runtime/domain.c:460">allocate_minor_heap</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;minor_heap_wsz) &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Fatal <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>: No memory for minor heap&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L844">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_update_minor_heap_max</span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> requested_wsz) {<br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Changing heap_max_wsz from %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;u to %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>, requested_wsz);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (requested_wsz &gt; <a href="caml/domain.h.html#L89" title="ocaml/runtime/caml/domain.h:89">caml_minor_heap_max_wsz</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L1496" title="ocaml/runtime/domain.c:1496">caml_try_run_on_all_domains</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &amp;<a href="#L792" title="ocaml/runtime/domain.c:792">stw_resize_minor_heap_reservation</a>, (<span class="Type">void</span>*)requested_wsz, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L414" title="ocaml/runtime/domain.c:414">check_minor_heap</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L855">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_init_domains</span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> minor_heap_wsz) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L724" title="ocaml/runtime/domain.c:724">reserve_minor_heaps</a>();<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* dom = &amp;<a href="#L208" title="ocaml/runtime/domain.c:208">all_domains</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[i] = dom;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dom-&gt;id = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.interrupt_word = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="platform.c.html#L47" title="ocaml/runtime/platform.c:47">caml_plat_mutex_init</a>(&amp;dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.lock);<br/></li>
<li>&nbsp; &nbsp; <a href="platform.c.html#L103" title="ocaml/runtime/platform.c:103">caml_plat_cond_init</a>(&amp;dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.cond,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.lock);<br/></li>
<li>&nbsp; &nbsp; dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.running = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.terminating = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.unique_id = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dom-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.interrupt_pending = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="platform.c.html#L47" title="ocaml/runtime/platform.c:47">caml_plat_mutex_init</a>(&amp;dom-&gt;domain_lock);<br/></li>
<li>&nbsp; &nbsp; <a href="platform.c.html#L103" title="ocaml/runtime/platform.c:103">caml_plat_cond_init</a>(&amp;dom-&gt;domain_cond, &amp;dom-&gt;domain_lock);<br/></li>
<li>&nbsp; &nbsp; dom-&gt;backup_thread_running = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dom-&gt;backup_thread_msg = <a href="#L140" title="ocaml/runtime/domain.c:140">BT_INIT</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L535" title="ocaml/runtime/domain.c:535">domain_create</a>(minor_heap_wsz);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>) <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Failed to create main domain&quot;</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;state-&gt;unique_id == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="signals.c.html#L195" title="ocaml/runtime/signals.c:195">caml_init_signal_handling</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L888">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_init_domain_self</span>(<span class="Type">int</span> domain_id) {<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (domain_id &gt;= <span class="Constant">0</span> &amp;&amp; domain_id &lt; <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>);<br/></li>
<li>&nbsp; <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a> = &amp;<a href="#L208" title="ocaml/runtime/domain.c:208">all_domains</a>[domain_id];<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L52" title="ocaml/runtime/caml/domain_state.h:52">caml_state</a> = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L894">&#x200c;</a><span class="Type">enum</span> <span class="linkable">domain_status</span> { Dom_starting, Dom_started, Dom_failed };<br/></li>
<li><br/></li>
<li><a id="L896">&#x200c;</a><span class="Type">struct</span> <span class="linkable">domain_ml_values</span> {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> callback;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> term_mutex;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L901">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">init_domain_ml_values</span>(<span class="Type">struct</span> <a href="#L896" title="ocaml/runtime/domain.c:896">domain_ml_values</a>* ml_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> callback, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> term_mutex)<br/></li>
<li>{<br/></li>
<li>&nbsp; ml_values-&gt;callback = callback;<br/></li>
<li>&nbsp; ml_values-&gt;term_mutex = term_mutex;<br/></li>
<li>&nbsp; <a href="globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>(&amp;ml_values-&gt;callback);<br/></li>
<li>&nbsp; <a href="globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>(&amp;ml_values-&gt;term_mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L910">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">free_domain_ml_values</span>(<span class="Type">struct</span> <a href="#L896" title="ocaml/runtime/domain.c:896">domain_ml_values</a>* ml_values) {<br/></li>
<li>&nbsp; <a href="globroots.c.html#L113" title="ocaml/runtime/globroots.c:113">caml_remove_generational_global_root</a>(&amp;ml_values-&gt;callback);<br/></li>
<li>&nbsp; <a href="globroots.c.html#L113" title="ocaml/runtime/globroots.c:113">caml_remove_generational_global_root</a>(&amp;ml_values-&gt;term_mutex);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(ml_values);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is the structure of the data exchanged between the parent<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; domain <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> child domain during domain_spawn. Some fields are 'in'<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; parameters, passed from the parent to the child, others are 'out'<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; parameters returned to the parent by the child.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L921">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">domain_startup_params</span> {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* parent; <span class="Comment">/* in */<br/></li>
<li></span>&nbsp; <span class="Type">enum</span> <a href="#L894" title="ocaml/runtime/domain.c:894">domain_status</a> <a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a>; <span class="Comment">/* in+out:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> child synchronize on this <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>. */<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="#L896" title="ocaml/runtime/domain.c:896">domain_ml_values</a>* ml_values; <span class="Comment">/* in */<br/></li>
<li></span>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* newdom; <span class="Comment">/* out */<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> unique_id; <span class="Comment">/* out */<br/></li>
<li></span><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; <span class="Comment">/* signal mask to set after it is safe to do so */<br/></li>
<li></span>&nbsp; sigset_t* mask; <span class="Comment">/* in */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L934">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span>* <span class="linkable">backup_thread_func</span>(<span class="Type">void</span>* v)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* di = (<a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>*)v;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> msg;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* s = &amp;di-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a> = di;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L52" title="ocaml/runtime/caml/domain_state.h:52">caml_state</a> = di-&gt;state;<br/></li>
<li><br/></li>
<li>&nbsp; msg = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;di-&gt;backup_thread_msg);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (msg != <a href="#L139" title="ocaml/runtime/domain.c:139">BT_TERMINATE</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (msg &lt;= <a href="#L139" title="ocaml/runtime/domain.c:139">BT_TERMINATE</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (msg) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L137" title="ocaml/runtime/domain.c:137">BT_IN_BLOCKING_SECTION</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle interrupts on behalf of the main thread:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; - must hold domain_lock to handle interrupts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; - need to guarantee no blocking so that backup thread<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; can be signalled from <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L300" title="ocaml/runtime/domain.c:300">caml_incoming_interrupts_queued</a>()) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L161" title="ocaml/runtime/caml/platform.h:161">caml_plat_try_lock</a>(&amp;di-&gt;domain_lock)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="ocaml/runtime/domain.c:325">caml_handle_incoming_interrupts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;di-&gt;domain_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait safely if there is nothing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Will be woken from <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;s-&gt;lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; msg = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;di-&gt;backup_thread_msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msg == <a href="#L137" title="ocaml/runtime/domain.c:137">BT_IN_BLOCKING_SECTION</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L300" title="ocaml/runtime/domain.c:300">caml_incoming_interrupts_queued</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="platform.c.html#L109" title="ocaml/runtime/platform.c:109">caml_plat_wait</a>(&amp;s-&gt;cond);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;s-&gt;lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L138" title="ocaml/runtime/domain.c:138">BT_ENTERING_OCAML</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Main thread wants to enter OCaml<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Will be woken from <a href="#L1706" title="ocaml/runtime/domain.c:1706">caml_bt_exit_ocaml</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> <a href="#L1764" title="ocaml/runtime/domain.c:1764">domain_terminate</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;di-&gt;domain_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; msg = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;di-&gt;backup_thread_msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msg == <a href="#L138" title="ocaml/runtime/domain.c:138">BT_ENTERING_OCAML</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="platform.c.html#L109" title="ocaml/runtime/platform.c:109">caml_plat_wait</a>(&amp;di-&gt;domain_cond);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;di-&gt;domain_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L36" title="ocaml/runtime/caml/platform.h:36">cpu_relax</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; msg = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;di-&gt;backup_thread_msg);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* doing terminate */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;di-&gt;backup_thread_msg, <a href="#L140" title="ocaml/runtime/domain.c:140">BT_INIT</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L993">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">install_backup_thread</span> (<a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* di)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> err;<br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; sigset_t mask, old_mask;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">if</span> (di-&gt;backup_thread_running == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (di-&gt;backup_thread_msg == <a href="#L140" title="ocaml/runtime/domain.c:140">BT_INIT</a> || <span class="Comment">/* Using fresh domain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; di-&gt;backup_thread_msg == <a href="#L139" title="ocaml/runtime/domain.c:139">BT_TERMINATE</a>); <span class="Comment">/* Reusing domain */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;di-&gt;backup_thread_msg) != <a href="#L140" title="ocaml/runtime/domain.c:140">BT_INIT</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Give a chance for backup thread on this domain to terminate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a> (&amp;di-&gt;domain_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L36" title="ocaml/runtime/caml/platform.h:36">cpu_relax</a> ();<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a> (&amp;di-&gt;domain_lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* No signals on the backup thread */<br/></li>
<li></span>&nbsp; &nbsp; sigfillset(&amp;mask);<br/></li>
<li>&nbsp; &nbsp; pthread_sigmask(SIG_BLOCK, &amp;mask, &amp;old_mask);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;di-&gt;backup_thread_msg, <a href="#L138" title="ocaml/runtime/domain.c:138">BT_ENTERING_OCAML</a>);<br/></li>
<li>&nbsp; &nbsp; err = pthread_create(&amp;di-&gt;backup_thread, <span class="Constant">0</span>, <a href="#L934" title="ocaml/runtime/domain.c:934">backup_thread_func</a>, (<span class="Type">void</span>*)di);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; &nbsp; pthread_sigmask(SIG_SETMASK, &amp;old_mask, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (err)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="fail_nat.c.html#L130" title="ocaml/runtime/fail_nat.c:130">caml_failwith</a>(<span class="Constant">&quot;failed to create domain backup thread&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; di-&gt;backup_thread_running = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; pthread_detach(di-&gt;backup_thread);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1031">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_domain_initialize_default</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1036">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_domain_stop_default</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1041">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_domain_external_interrupt_hook_default</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1046">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_domain_initialize_hook</span>)(<span class="Type">void</span>) =<br/></li>
<li>&nbsp;&nbsp; <a href="#L1031" title="ocaml/runtime/domain.c:1031">caml_domain_initialize_default</a>;<br/></li>
<li><br/></li>
<li><a id="L1049">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_domain_stop_hook</span>)(<span class="Type">void</span>) =<br/></li>
<li>&nbsp;&nbsp; <a href="#L1036" title="ocaml/runtime/domain.c:1036">caml_domain_stop_default</a>;<br/></li>
<li><br/></li>
<li><a id="L1052">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_domain_external_interrupt_hook</span>)(<span class="Type">void</span>) =<br/></li>
<li>&nbsp;&nbsp; <a href="#L1041" title="ocaml/runtime/domain.c:1041">caml_domain_external_interrupt_hook_default</a>;<br/></li>
<li><br/></li>
<li><a id="L1055">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">_Atomic</span> <a href="caml/misc.h.html#L190" title="ocaml/runtime/caml/misc.h:190">caml_timing_hook</a> <span class="linkable">caml_domain_terminated_hook</span> =<br/></li>
<li>&nbsp; (<a href="caml/misc.h.html#L190" title="ocaml/runtime/caml/misc.h:190">caml_timing_hook</a>)<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1764" title="ocaml/runtime/domain.c:1764">domain_terminate</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><a id="L1060">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span>* <span class="linkable">domain_thread_func</span>(<span class="Type">void</span>* v)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L921" title="ocaml/runtime/domain.c:921">domain_startup_params</a>* p = v;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L896" title="ocaml/runtime/domain.c:896">domain_ml_values</a> *ml_values = p-&gt;ml_values;<br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; sigset_t mask = *(p-&gt;mask);<br/></li>
<li>&nbsp; <span class="Type">void</span> * signal_stack;<br/></li>
<li><br/></li>
<li>&nbsp; signal_stack = <a href="signals.c.html#L475" title="ocaml/runtime/signals.c:475">caml_init_signal_stack</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (signal_stack == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Failed to create domain: signal stack&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <a href="#L535" title="ocaml/runtime/domain.c:535">domain_create</a>(<a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;init_minor_heap_wsz);<br/></li>
<li>&nbsp; <span class="Comment">/* this domain is now part of the STW participant set */<br/></li>
<li></span>&nbsp; p-&gt;newdom = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* handshake with the parent domain */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;p-&gt;parent-&gt;lock);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>) {<br/></li>
<li>&nbsp; &nbsp; p-&gt;<a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a> = Dom_started;<br/></li>
<li>&nbsp; &nbsp; p-&gt;unique_id = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.unique_id;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; p-&gt;<a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a> = Dom_failed;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="platform.c.html#L115" title="ocaml/runtime/platform.c:115">caml_plat_broadcast</a>(&amp;p-&gt;parent-&gt;cond);<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;p-&gt;parent-&gt;lock);<br/></li>
<li>&nbsp; <span class="Comment">/* Cannot access p below here. */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L993" title="ocaml/runtime/domain.c:993">install_backup_thread</a>(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* It is now safe for us to handle signals */<br/></li>
<li></span>&nbsp; &nbsp; pthread_sigmask(SIG_SETMASK, &amp;mask, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Domain starting (unique_id = %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;u)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.unique_id);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L45" title="ocaml/runtime/caml/runtime_events.h:45">CAML_EV_LIFECYCLE</a>(EV_DOMAIN_SPAWN, getpid());<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain.h.html#L82" title="ocaml/runtime/caml/domain.h:82">caml_domain_initialize_hook</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="callback.c.html#L291" title="ocaml/runtime/callback.c:291">caml_callback</a>(ml_values-&gt;callback, <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1764" title="ocaml/runtime/domain.c:1764">domain_terminate</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This domain currently holds the [term_mutex], <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> has signaled all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; waiting domains to be woken up. We unlock the [term_mutex] to release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; the joining domains. The unlock is done after [<a href="#L1764" title="ocaml/runtime/domain.c:1764">domain_terminate</a>] to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; ensure that this domain has released all of its runtime state. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="sync.c.html#L67" title="ocaml/runtime/sync.c:67">caml_mutex_unlock</a>(<a href="caml/sync.h.html#L27" title="ocaml/runtime/caml/sync.h:27">Mutex_val</a>(ml_values-&gt;term_mutex));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* [ml_values] must be freed after unlocking [term_mutex]. This ensures<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; that [term_mutex] is only removed from the root set after [term_mutex]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; is unlocked. Otherwise, there is a risk of [term_mutex] being destroyed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; by [<a href="sync.c.html#L34" title="ocaml/runtime/sync.c:34">caml_mutex_finalize</a>] finaliser while it remains locked, leading to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; undefined behaviour. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L910" title="ocaml/runtime/domain.c:910">free_domain_ml_values</a>(ml_values);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Failed to create domain&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; <a href="signals.c.html#L511" title="ocaml/runtime/signals.c:511">caml_free_signal_stack</a>(signal_stack);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1126">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_domain_spawn</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> callback, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> mutex)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a> (callback, mutex);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L921" title="ocaml/runtime/domain.c:921">domain_startup_params</a> p;<br/></li>
<li>&nbsp; pthread_t th;<br/></li>
<li>&nbsp; <span class="Type">int</span> err;<br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; sigset_t mask, old_mask;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef NATIVE_CODE<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="debugger.c.html#L36" title="ocaml/runtime/debugger.c:36">caml_debugger_in_use</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;ocamldebug does not support spawning multiple domains&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; p.parent = &amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>;<br/></li>
<li>&nbsp; p.<a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a> = Dom_starting;<br/></li>
<li><br/></li>
<li>&nbsp; p.ml_values =<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> <a href="#L896" title="ocaml/runtime/domain.c:896">domain_ml_values</a>*) <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="#L896" title="ocaml/runtime/domain.c:896">domain_ml_values</a>));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!p.ml_values) {<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L130" title="ocaml/runtime/fail_nat.c:130">caml_failwith</a>(<span class="Constant">&quot;failed to create ml values for domain thread&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L901" title="ocaml/runtime/domain.c:901">init_domain_ml_values</a>(p.ml_values, callback, mutex);<br/></li>
<li><br/></li>
<li><span class="Comment">/* We block all signals while we spawn the new domain. This is because<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; pthread_create inherits the current signals set, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> we want to avoid a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; signal handler being triggered in the new domain before the domain_state is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; fully populated. */<br/></li>
<li></span><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; sigfillset(&amp;mask);<br/></li>
<li>&nbsp; pthread_sigmask(SIG_BLOCK, &amp;mask, &amp;old_mask);<br/></li>
<li>&nbsp; p.mask = &amp;old_mask;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; err = pthread_create(&amp;th, <span class="Constant">0</span>, <a href="#L1060" title="ocaml/runtime/domain.c:1060">domain_thread_func</a>, (<span class="Type">void</span>*)&amp;p);<br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; <span class="Comment">/* We can restore the signal mask we had initially now. */<br/></li>
<li></span>&nbsp; pthread_sigmask(SIG_SETMASK, &amp;old_mask, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Statement">if</span> (err) {<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L130" title="ocaml/runtime/fail_nat.c:130">caml_failwith</a>(<span class="Constant">&quot;failed to create domain thread&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* While waiting for the child thread to start up, we need to service any<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; stop-the-world requests as they come in. */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.lock);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (p.<a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a> == Dom_starting) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L300" title="ocaml/runtime/domain.c:300">caml_incoming_interrupts_queued</a>()) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L307" title="ocaml/runtime/domain.c:307">handle_incoming</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.lock);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="platform.c.html#L109" title="ocaml/runtime/platform.c:109">caml_plat_wait</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.cond);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.lock);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (p.<a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a> == Dom_started) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* successfully created a domain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; p.ml_values is now owned by that domain */<br/></li>
<li></span>&nbsp; &nbsp; pthread_detach(th);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (p.<a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a> == Dom_failed);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* failed */<br/></li>
<li></span>&nbsp; &nbsp; pthread_join(th, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L910" title="ocaml/runtime/domain.c:910">free_domain_ml_values</a>(p.ml_values);<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L130" title="ocaml/runtime/fail_nat.c:130">caml_failwith</a>(<span class="Constant">&quot;failed to allocate domain&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* When domain 0 first spawns a domain, the backup thread is not active, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; ensure it is started here. */<br/></li>
<li></span>&nbsp; <a href="#L993" title="ocaml/runtime/domain.c:993">install_backup_thread</a>(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(p.unique_id));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1202">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_domain_id</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> unit)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.unique_id);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1208">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_domain_unique_token</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> unit)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* sense-reversing barrier */<br/></li>
<li><a id="L1214">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BARRIER_SENSE_BIT</span> </span><span class="Constant">0x100000<br/></li>
<li></span><br/></li>
<li><a id="L1216">&#x200c;</a><a href="caml/domain.h.html#L115" title="ocaml/runtime/caml/domain.h:115">barrier_status</a> <span class="linkable">caml_global_barrier_begin</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> = <span class="Constant">1</span> + <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.barrier, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1222">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_global_barrier_is_final</span>(<a href="caml/domain.h.html#L115" title="ocaml/runtime/caml/domain.h:115">barrier_status</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> ((<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> &amp; ~<a href="#L1214" title="ocaml/runtime/domain.c:1214">BARRIER_SENSE_BIT</a>) == <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.num_domains);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1227">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_global_barrier_end</span>(<a href="caml/domain.h.html#L115" title="ocaml/runtime/caml/domain.h:115">barrier_status</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> sense = <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> &amp; <a href="#L1214" title="ocaml/runtime/domain.c:1214">BARRIER_SENSE_BIT</a>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L1222" title="ocaml/runtime/domain.c:1222">caml_global_barrier_is_final</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* last domain into the barrier, flip sense */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.barrier, sense ^ <a href="#L1214" title="ocaml/runtime/domain.c:1214">BARRIER_SENSE_BIT</a>);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wait until another domain flips the sense */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L75" title="ocaml/runtime/caml/platform.h:75">SPIN_WAIT</a> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> barrier = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.barrier);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((barrier &amp; <a href="#L1214" title="ocaml/runtime/domain.c:1214">BARRIER_SENSE_BIT</a>) != sense) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1242">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_global_barrier</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain.h.html#L115" title="ocaml/runtime/caml/domain.h:115">barrier_status</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> = <a href="#L1216" title="ocaml/runtime/domain.c:1216">caml_global_barrier_begin</a>();<br/></li>
<li>&nbsp; <a href="#L1227" title="ocaml/runtime/domain.c:1227">caml_global_barrier_end</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1248">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_global_barrier_num_domains</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.num_domains;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1253">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">decrement_stw_domains_still_processing</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* we check if we are the last to leave a stw section<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; if so, clear the <a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a> to allow the new stw sections to start.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> am_last =<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.num_domains_still_processing, -<span class="Constant">1</span>) == <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>( am_last ) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release the STW lock to allow new STW sections */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="platform.c.html#L115" title="ocaml/runtime/platform.c:115">caml_plat_broadcast</a>(&amp;<a href="#L205" title="ocaml/runtime/domain.c:205">all_domains_cond</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;clearing stw leader&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1271">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">stw_handler</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_STW_HANDLER);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_STW_API_BARRIER);<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L75" title="ocaml/runtime/caml/platform.h:75">SPIN_WAIT</a> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.domains_still_running) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.enter_spin_callback)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.enter_spin_callback(domain, <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.enter_spin_data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_STW_API_BARRIER);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;inside_stw_handler = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.callback(<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.num_domains,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.participating);<br/></li>
<li>&nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;inside_stw_handler = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <a href="#L1253" title="ocaml/runtime/domain.c:1253">decrement_stw_domains_still_processing</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_STW_HANDLER);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* poll the GC to check for deferred work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; we do this here because blocking <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> waiting threads only execute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the interrupt handler <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> do not poll for deferred work*/<br/></li>
<li></span>&nbsp; <a href="#L1589" title="ocaml/runtime/domain.c:1589">caml_poll_gc_work</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li><a id="L1310">&#x200c;</a></span><span class="Type">int</span> <span class="linkable">caml_domain_is_in_stw</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;inside_stw_handler;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* During a stop-the-world (STW), all currently running domains stop<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; their usual work <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> synchronize to all call the same function.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; STW sections use [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the variable [<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (0 when no STW section is running, the <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* pointer of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; STW leader when a STW section is running) to guarantee that no<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; domain is running something else:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; - If two STW sections are attempted in parallel, only one will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; manage to take the lock, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the domain starting the other will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; join that winning STW section, without running its own STW<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; callback at all. (This is the [_try_] in the function name: if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; returns 0, the STW section did not run at all, so you should call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; this function in a loop.)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; - Domain initialization code from [<a href="#L535" title="ocaml/runtime/domain.c:535">domain_create</a>] will not run in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; parallel with a STW section, as [<a href="#L535" title="ocaml/runtime/domain.c:535">domain_create</a>] starts by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; looping until (1) it has the [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> (2) there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; no current STW section (using the [<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>] variable).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; - Domain cleanup code runs after the terminating domain may run in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; parallel to a STW section, but only after that domain has safely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; removed itself from the STW participant set: the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [<a href="#L1764" title="ocaml/runtime/domain.c:1764">domain_terminate</a>] function is careful to only leave the STW set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; when (1) it has the [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> (2) it hasn't received<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; any request to participate in a STW section.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Each domain leaves the section as soon as it is finished running<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the STW section callback. In particular, a mutator may resume while<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; some other domains are still in the section. Any code within the STW<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; callback that needs to happen before any mutator must be followed<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; by a barrier, forcing all STW participants to synchronize.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Taken together, these properties guarantee that STW sections act as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; a proper exclusion mechanism: for example, some mutable state<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; global to all domains can be &quot;protected by STW&quot; if it is only<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mutated within STW section, with a barrier before the next<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; read. Such state can be safely updated by domain initialization,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; but additional synchronization would be required to update it<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; during domain cleanup.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Note: in the case of both [<a href="#L535" title="ocaml/runtime/domain.c:535">domain_create</a>] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [<a href="#L1764" title="ocaml/runtime/domain.c:1764">domain_terminate</a>] it<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is important that the loops (waiting for STW sections to finish)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; regularly release [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>], to avoid deadlocks scenario<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; with in-progress STW sections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - For [<a href="#L1764" title="ocaml/runtime/domain.c:1764">domain_terminate</a>] we release the lock <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the STW section before resuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - For [<a href="#L535" title="ocaml/runtime/domain.c:535">domain_create</a>] we wait until the end of the section using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the condition variable [<a href="#L205" title="ocaml/runtime/domain.c:205">all_domains_cond</a>] over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>], which is broadcasted when a STW section<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; finishes.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The same logic would apply for any other situations in which a domain<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; wants to join <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> leave the set of STW participants.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The explanation above applies if [sync] = 1. When [sync] = 0, no<br/></li>
<li></span><span class="Comment">&nbsp; synchronization happens, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> we simply run the handler asynchronously on<br/></li>
<li></span><span class="Comment">&nbsp; all domains. We still hold the <a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a> field until we know that<br/></li>
<li></span><span class="Comment">&nbsp; every domain has run the handler, so another STW section cannot<br/></li>
<li></span><span class="Comment">&nbsp; interfere with this one.<br/></li>
<li></span><br/></li>
<li><span class="Comment">*/<br/></li>
<li><a id="L1376">&#x200c;</a></span><span class="Type">int</span> <span class="linkable">caml_try_run_on_all_domains_with_spin_work</span>(<br/></li>
<li>&nbsp; <span class="Type">int</span> sync,<br/></li>
<li>&nbsp; <span class="Type">void</span> (*handler)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*, <span class="Type">void</span>*, <span class="Type">int</span>, <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>**),<br/></li>
<li>&nbsp; <span class="Type">void</span>* data,<br/></li>
<li>&nbsp; <span class="Type">void</span> (*leader_setup)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*),<br/></li>
<li>&nbsp; <span class="Type">void</span> (*enter_spin_callback)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*, <span class="Type">void</span>*),<br/></li>
<li>&nbsp; <span class="Type">void</span>* enter_spin_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;state;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;requesting STW, sync=</span><span class="Special">%d</span><span class="Constant">&quot;</span>, sync);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Don't touch the lock if there's already a stw leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; OR we can't get the lock.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Note: this read on [<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>] is an optimization, giving up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; faster (before trying to take the lock) in contended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; situations. Without this read, [<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>] would be protected by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> could be a non-atomic variable.<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; !<a href="caml/platform.h.html#L161" title="ocaml/runtime/caml/platform.h:161">caml_plat_try_lock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>)) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L325" title="ocaml/runtime/domain.c:325">caml_handle_incoming_interrupts</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* see if there is a <a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a> already */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>)) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L325" title="ocaml/runtime/domain.c:325">caml_handle_incoming_interrupts</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* we have the lock <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> can claim the <a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a> */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L207" title="ocaml/runtime/domain.c:207">stw_leader</a>, (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_STW_LEADER);<br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;causing STW&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* setup all fields for this <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>, must have those needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; for domains waiting at the enter spin barrier */<br/></li>
<li></span>&nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.enter_spin_callback = enter_spin_callback;<br/></li>
<li>&nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.enter_spin_data = enter_spin_data;<br/></li>
<li>&nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.callback = handler;<br/></li>
<li>&nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.data = data;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.barrier, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.domains_still_running, sync);<br/></li>
<li>&nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.num_domains = <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.num_domains_still_processing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span>( leader_setup ) {<br/></li>
<li>&nbsp; &nbsp; leader_setup(domain_state);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> domains_participating = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span>(<a href="#L208" title="ocaml/runtime/domain.c:208">all_domains</a>[i].<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.running)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; domains_participating++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(domains_participating == <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(domains_participating &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* <a href="interp.c.html#L63" title="ocaml/runtime/interp.c:63">Next</a>, interrupt all domains */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span>(i = <span class="Constant">0</span>; i &lt; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains; i++) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a> * d = <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[i];<br/></li>
<li>&nbsp; &nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.participating[i] = d-&gt;state;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!d-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.interrupt_pending);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (d-&gt;state != domain_state) <a href="#L330" title="ocaml/runtime/domain.c:330">caml_send_interrupt</a>(&amp;d-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Domains now know they are part of the STW.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Note: releasing the lock will not allow new domain to be created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in parallel with the rest of the STW section, as new domains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; follow the protocol of waiting on [<a href="#L205" title="ocaml/runtime/domain.c:205">all_domains_cond</a>] which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; only broadcast at the end of the STW section.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The reason we use a condition variable [<a href="#L205" title="ocaml/runtime/domain.c:205">all_domains_cond</a>] instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; of just holding the lock until the end of the STW section is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the last domain to exit the section (<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> broadcast the condition)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; is not necessarily the same as the domain starting the section<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; (<a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> taking the lock) -- whereas POSIX mutexes must be unlocked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; by the same thread that locked them.<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span>(i = <span class="Constant">0</span>; i &lt; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.num_domains; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> id = <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.participating[i]-&gt;id;<br/></li>
<li>&nbsp; &nbsp; <a href="#L346" title="ocaml/runtime/domain.c:346">caml_wait_interrupt_serviced</a>(&amp;<a href="#L208" title="ocaml/runtime/domain.c:208">all_domains</a>[id].<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* release from the enter barrier */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.domains_still_running, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; domain_state-&gt;inside_stw_handler = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="PreProc">#endif<br/></li>
<li></span>&nbsp; handler(domain_state, data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.num_domains, <a href="#L192" title="ocaml/runtime/domain.c:192">stw_request</a>.participating);<br/></li>
<li>&nbsp; <span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; domain_state-&gt;inside_stw_handler = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Note: the last domain passing through this function will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; temporarily take [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>] again <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> use it to broadcast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [<a href="#L205" title="ocaml/runtime/domain.c:205">all_domains_cond</a>], waking up any domain waiting to be created. */<br/></li>
<li></span>&nbsp; <a href="#L1253" title="ocaml/runtime/domain.c:1253">decrement_stw_domains_still_processing</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_STW_LEADER);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1496">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_try_run_on_all_domains</span>(<br/></li>
<li>&nbsp; <span class="Type">void</span> (*handler)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*, <span class="Type">void</span>*, <span class="Type">int</span>, <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>**),<br/></li>
<li>&nbsp; <span class="Type">void</span>* data,<br/></li>
<li>&nbsp; <span class="Type">void</span> (*leader_setup)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*))<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1376" title="ocaml/runtime/domain.c:1376">caml_try_run_on_all_domains_with_spin_work</a>(<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; handler,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leader_setup, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1508">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_try_run_on_all_domains_async</span>(<br/></li>
<li>&nbsp; <span class="Type">void</span> (*handler)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*, <span class="Type">void</span>*, <span class="Type">int</span>, <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>**),<br/></li>
<li>&nbsp; <span class="Type">void</span>* data,<br/></li>
<li>&nbsp; <span class="Type">void</span> (*leader_setup)(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*))<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1376" title="ocaml/runtime/domain.c:1376">caml_try_run_on_all_domains_with_spin_work</a>(<span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; handler,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leader_setup, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1520">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_interrupt_self</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <a href="#L295" title="ocaml/runtime/domain.c:295">interrupt_domain</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1524">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_reset_young_limit</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> * dom_st)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> ((<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)dom_st-&gt;young_ptr &gt; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)dom_st-&gt;young_trigger);<br/></li>
<li>&nbsp; <span class="Comment">/* An interrupt might have been queued in the meanwhile; this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; achieves the proper synchronisation. */<br/></li>
<li></span>&nbsp; <a href="caml/camlatomic.h.html#L73" title="ocaml/runtime/caml/camlatomic.h:73">atomic_exchange</a>(&amp;dom_st-&gt;young_limit, (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)dom_st-&gt;young_trigger);<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a> * d = &amp;<a href="#L208" title="ocaml/runtime/domain.c:208">all_domains</a>[dom_st-&gt;id];<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;d-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>.interrupt_pending)<br/></li>
<li>&nbsp; &nbsp; &nbsp; || dom_st-&gt;requested_minor_gc<br/></li>
<li>&nbsp; &nbsp; &nbsp; || dom_st-&gt;requested_major_slice<br/></li>
<li>&nbsp; &nbsp; &nbsp; || dom_st-&gt;major_slice_epoch &lt; <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="minor_gc.c.html#L47" title="ocaml/runtime/minor_gc.c:47">caml_major_slice_epoch</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; || <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;dom_st-&gt;requested_external_interrupt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; || dom_st-&gt;action_pending) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;dom_st-&gt;young_limit, (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/domain.h.html#L41" title="ocaml/runtime/caml/domain.h:41">caml_check_gc_interrupt</a>(dom_st));<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1542">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">advance_global_major_slice_epoch</span> (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* d)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> old_value;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="minor_gc.c.html#L47" title="ocaml/runtime/minor_gc.c:47">caml_major_slice_epoch</a>) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="minor_gc.c.html#L46" title="ocaml/runtime/minor_gc.c:46">caml_minor_collections_count</a>));<br/></li>
<li><br/></li>
<li>&nbsp; old_value = <a href="caml/camlatomic.h.html#L73" title="ocaml/runtime/caml/camlatomic.h:73">atomic_exchange</a> (&amp;<a href="minor_gc.c.html#L47" title="ocaml/runtime/minor_gc.c:47">caml_major_slice_epoch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="minor_gc.c.html#L46" title="ocaml/runtime/minor_gc.c:46">caml_minor_collections_count</a>));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (old_value != <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="minor_gc.c.html#L46" title="ocaml/runtime/minor_gc.c:46">caml_minor_collections_count</a>)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This domain is the first one to use up half of its minor heap arena<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; in this minor cycle. Trigger major slice on other domains. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L161" title="ocaml/runtime/caml/platform.h:161">caml_plat_try_lock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Note that this interrupt is best-effort. If we get the lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; then interrupt all the domains. If not, either some other domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is calling for a stop-the-world section interrupting all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; domains, <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> a domain is being created <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> terminated. All of these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; actions also try to lock [<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>] mutex, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lock acquisition may fail.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; If we don't get the lock, we don't interrupt other domains. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; acceptable since it does not affect safety but only liveness -- the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; speed of the major gc. The other domains may themselves fill half of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; their minor heap triggering a major slice, <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> will certainly do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; major slice right after their next minor GC when they observe that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; their domain-local [<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;major_slice_epoch] is less than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; global one [<a href="minor_gc.c.html#L47" title="ocaml/runtime/minor_gc.c:47">caml_major_slice_epoch</a>]. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span>(<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.participating_domains; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a> * di = <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a>.domains[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (di-&gt;state != d) <a href="#L295" title="ocaml/runtime/domain.c:295">interrupt_domain</a>(&amp;di-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a> (&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1579">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">global_major_slice_callback</span> (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> *domain,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *unused,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> **participating)<br/></li>
<li>{<br/></li>
<li>&nbsp; domain-&gt;requested_major_slice = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Comment">/* Nothing else to do, as [stw_hander] will call [<a href="#L1589" title="ocaml/runtime/domain.c:1589">caml_poll_gc_work</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; right after the callback. */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L1589">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_poll_gc_work</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L278" title="ocaml/runtime/caml/misc.h:278">CAMLalloc_point_here</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* d = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> ((<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)d-&gt;young_ptr - <a href="caml/mlvalues.h.html#L183" title="ocaml/runtime/caml/mlvalues.h:183">Bhsize_wosize</a>(<a href="caml/config.h.html#L221" title="ocaml/runtime/caml/config.h:221">Max_young_wosize</a>) &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)d-&gt;young_trigger) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (d-&gt;young_trigger == d-&gt;young_start) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Trigger minor GC */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; d-&gt;requested_minor_gc = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (d-&gt;young_trigger ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;young_start + (d-&gt;young_end - d-&gt;young_start) / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* We have used half of our minor heap arena. Request a major slice on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; this domain. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1542" title="ocaml/runtime/domain.c:1542">advance_global_major_slice_epoch</a> (d);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance the [young_trigger] to [young_start] so that the allocation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fails when the minor heap is full. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; d-&gt;young_trigger = d-&gt;young_start;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (d-&gt;requested_minor_gc) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This domain has _not_ used up half of its minor heap arena, but a minor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; collection has been requested. Schedule a major collection slice so as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; to not lag behind. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1542" title="ocaml/runtime/domain.c:1542">advance_global_major_slice_epoch</a> (d);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (d-&gt;major_slice_epoch &lt; <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="minor_gc.c.html#L47" title="ocaml/runtime/minor_gc.c:47">caml_major_slice_epoch</a>)) {<br/></li>
<li>&nbsp; &nbsp; d-&gt;requested_major_slice = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (d-&gt;requested_minor_gc) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* out of minor heap <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> collection forced */<br/></li>
<li></span>&nbsp; &nbsp; d-&gt;requested_minor_gc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="minor_gc.c.html#L783" title="ocaml/runtime/minor_gc.c:783">caml_empty_minor_heaps_once</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (d-&gt;requested_major_slice || d-&gt;requested_global_major_slice) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR);<br/></li>
<li>&nbsp; &nbsp; d-&gt;requested_major_slice = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="major_gc.c.html#L1702" title="ocaml/runtime/major_gc.c:1702">caml_major_collection_slice</a>(<a href="caml/major_gc.h.html#L44" title="ocaml/runtime/caml/major_gc.h:44">AUTO_TRIGGERED_MAJOR_SLICE</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (d-&gt;requested_global_major_slice) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1508" title="ocaml/runtime/domain.c:1508">caml_try_run_on_all_domains_async</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L1579" title="ocaml/runtime/domain.c:1579">global_major_slice_callback</a>, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)){<br/></li>
<li>&nbsp; &nbsp; &nbsp; d-&gt;requested_global_major_slice = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If <a href="#L1508" title="ocaml/runtime/domain.c:1508">caml_try_run_on_all_domains_async</a> fails, we'll try again next time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1589" title="ocaml/runtime/domain.c:1589">caml_poll_gc_work</a> is called. */<br/></li>
<li></span>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;d-&gt;requested_external_interrupt)) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain.h.html#L84" title="ocaml/runtime/caml/domain.h:84">caml_domain_external_interrupt_hook</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L1524" title="ocaml/runtime/domain.c:1524">caml_reset_young_limit</a>(d);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1650">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_handle_gc_interrupt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L278" title="ocaml/runtime/caml/misc.h:278">CAMLalloc_point_here</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L300" title="ocaml/runtime/domain.c:300">caml_incoming_interrupts_queued</a>()) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* interrupt */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_INTERRUPT_REMOTE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L325" title="ocaml/runtime/domain.c:325">caml_handle_incoming_interrupts</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_INTERRUPT_REMOTE);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L1589" title="ocaml/runtime/domain.c:1589">caml_poll_gc_work</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1664">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_bt_is_in_blocking_section</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a> = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;backup_thread_msg);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a> == <a href="#L137" title="ocaml/runtime/domain.c:137">BT_IN_BLOCKING_SECTION</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1670">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_bt_is_self</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> pthread_equal(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;backup_thread, pthread_self());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1675">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">caml_domain_is_multicore</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a> *self = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> (!<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>() || self-&gt;backup_thread_running);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1681">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_acquire_domain_lock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* self = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;self-&gt;domain_lock);<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L52" title="ocaml/runtime/caml/domain_state.h:52">caml_state</a> = self-&gt;state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1688">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_bt_enter_ocaml</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* self = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>() || self-&gt;backup_thread_running);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (self-&gt;backup_thread_running) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;self-&gt;backup_thread_msg, <a href="#L138" title="ocaml/runtime/domain.c:138">BT_ENTERING_OCAML</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1699">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_release_domain_lock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* self = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L52" title="ocaml/runtime/caml/domain_state.h:52">caml_state</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;self-&gt;domain_lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1706">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_bt_exit_ocaml</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L156" title="ocaml/runtime/domain.c:156">dom_internal</a>* self = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a>() || self-&gt;backup_thread_running);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (self-&gt;backup_thread_running) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;self-&gt;backup_thread_msg, <a href="#L137" title="ocaml/runtime/domain.c:137">BT_IN_BLOCKING_SECTION</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wakeup backup thread if it is sleeping */<br/></li>
<li></span>&nbsp; &nbsp; <a href="platform.c.html#L121" title="ocaml/runtime/platform.c:121">caml_plat_signal</a>(&amp;self-&gt;domain_cond);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* default handler for unix_fork, will be called by unix_fork. */<br/></li>
<li><a id="L1720">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_atfork_default</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <a href="#L712" title="ocaml/runtime/domain.c:712">caml_reset_domain_lock</a>();<br/></li>
<li>&nbsp; <a href="#L1681" title="ocaml/runtime/domain.c:1681">caml_acquire_domain_lock</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1725">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_atfork_hook</span>)(<span class="Type">void</span>) = <a href="#L1720" title="ocaml/runtime/domain.c:1720">caml_atfork_default</a>;<br/></li>
<li><br/></li>
<li><a id="L1727">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">handover_ephemerons</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (domain_state-&gt;ephe_info-&gt;todo == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;live == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;must_sweep_ephe == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="major_gc.c.html#L332" title="ocaml/runtime/major_gc.c:332">caml_add_to_orphaned_ephe_list</a>(domain_state-&gt;ephe_info);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (domain_state-&gt;ephe_info-&gt;live == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (domain_state-&gt;ephe_info-&gt;todo == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1739">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">handover_finalisers</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/finalise.h.html#L58" title="ocaml/runtime/caml/finalise.h:58">caml_final_info</a>* f = domain_state-&gt;final_info;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (f-&gt;todo_head != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> || f-&gt;first.size != <span class="Constant">0</span> || f-&gt;last.size != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* have some <a href="caml/finalise.h.html#L24" title="ocaml/runtime/caml/finalise.h:24">final</a> structures */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="major_gc.c.html#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> != Phase_sweep_and_mark_main) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Force a major GC cycle to simplify constraints for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * handing over finalisers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="major_gc.c.html#L1746" title="ocaml/runtime/major_gc.c:1746">caml_finish_major_cycle</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="major_gc.c.html#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_sweep_and_mark_main);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="major_gc.c.html#L264" title="ocaml/runtime/major_gc.c:264">caml_add_orphaned_finalisers</a> (f);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a dummy <a href="caml/finalise.h.html#L24" title="ocaml/runtime/caml/finalise.h:24">final</a> info */<br/></li>
<li></span>&nbsp; &nbsp; domain_state-&gt;final_info = <a href="finalise.c.html#L413" title="ocaml/runtime/finalise.c:413">caml_alloc_final_info</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="major_gc.c.html#L278" title="ocaml/runtime/major_gc.c:278">caml_final_domain_terminate</a>(domain_state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1758">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_domain_is_terminating</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* s = &amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> s-&gt;terminating;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1764">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">domain_terminate</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;state;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* s = &amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>;<br/></li>
<li>&nbsp; <span class="Type">int</span> finished = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; sigset_t mask;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Domain terminating&quot;</span>);<br/></li>
<li>&nbsp; s-&gt;terminating = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef _WIN32<br/></li>
<li></span>&nbsp; <span class="Comment">/* Block all signals so that signal handlers do not run on this thread */<br/></li>
<li></span>&nbsp; sigfillset(&amp;mask);<br/></li>
<li>&nbsp; pthread_sigmask(SIG_BLOCK, &amp;mask, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Join ongoing systhreads, if necessary, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> then run user-defined<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; termination hooks. No OCaml code can run on this domain after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; this. */<br/></li>
<li></span>&nbsp; <a href="caml/domain.h.html#L83" title="ocaml/runtime/caml/domain.h:83">caml_domain_stop_hook</a>();<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L207" title="ocaml/runtime/caml/misc.h:207">call_timing_hook</a>(&amp;<a href="#L1055" title="ocaml/runtime/domain.c:1055">caml_domain_terminated_hook</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (!finished) {<br/></li>
<li>&nbsp; &nbsp; <a href="major_gc.c.html#L1781" title="ocaml/runtime/major_gc.c:1781">caml_finish_sweeping</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="minor_gc.c.html#L783" title="ocaml/runtime/minor_gc.c:783">caml_empty_minor_heaps_once</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: [<a href="minor_gc.c.html#L783" title="ocaml/runtime/minor_gc.c:783">caml_empty_minor_heaps_once</a>] will also join any ongoing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; STW sections that has sent an interrupt to this domain. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="major_gc.c.html#L1769" title="ocaml/runtime/major_gc.c:1769">caml_finish_marking</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1727" title="ocaml/runtime/domain.c:1727">handover_ephemerons</a>(domain_state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1739" title="ocaml/runtime/domain.c:1739">handover_finalisers</a>(domain_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take the <a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a> to try <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> exit the STW participant set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; without racing with a STW section being triggered */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The interaction of termination <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> major GC is quite subtle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At the end of the major GC, we decide the number of domains to <a href="major_gc.c.html#L993" title="ocaml/runtime/major_gc.c:993">mark</a> <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sweep for the next cycle. If a STW section has been started, it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require this domain to participate, which in turn could involve a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * major GC cycle. This would then require finish marking <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> sweeping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again in order to decrement the globals [<a href="major_gc.c.html#L81" title="ocaml/runtime/major_gc.c:81">num_domains_to_mark</a>] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * [<a href="major_gc.c.html#L80" title="ocaml/runtime/major_gc.c:80">num_domains_to_sweep</a>] (see major_gc.c).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L300" title="ocaml/runtime/domain.c:300">caml_incoming_interrupts_queued</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;marking_done &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;sweeping_done) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; finished = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; s-&gt;terminating = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; s-&gt;running = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove this domain from <a href="#L243" title="ocaml/runtime/domain.c:243">stw_domains</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L263" title="ocaml/runtime/domain.c:263">remove_from_stw_domains</a>(<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* signal the <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a> condition variable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * because the backup thread may be waiting on it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;s-&gt;lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="platform.c.html#L115" title="ocaml/runtime/platform.c:115">caml_plat_broadcast</a>(&amp;s-&gt;cond);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;s-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;backup_thread_running);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;backup_thread_running = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L204" title="ocaml/runtime/domain.c:204">all_domains_lock</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* We can not touch <a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a> after here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; because it may be reused */<br/></li>
<li></span>&nbsp; <a href="globroots.c.html#L113" title="ocaml/runtime/globroots.c:113">caml_remove_generational_global_root</a>(&amp;domain_state-&gt;dls_root);<br/></li>
<li>&nbsp; <a href="globroots.c.html#L113" title="ocaml/runtime/globroots.c:113">caml_remove_generational_global_root</a>(&amp;domain_state-&gt;backtrace_last_exn);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(domain_state-&gt;final_info);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(domain_state-&gt;ephe_info);<br/></li>
<li>&nbsp; <a href="intern.c.html#L117" title="ocaml/runtime/intern.c:117">caml_free_intern_state</a>();<br/></li>
<li>&nbsp; <a href="extern.c.html#L149" title="ocaml/runtime/extern.c:149">caml_free_extern_state</a>();<br/></li>
<li>&nbsp; <a href="major_gc.c.html#L1917" title="ocaml/runtime/major_gc.c:1917">caml_teardown_major_gc</a>();<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L45" title="ocaml/runtime/caml/runtime_events.h:45">CAML_EV_LIFECYCLE</a>(EV_DOMAIN_TERMINATE, getpid());<br/></li>
<li><br/></li>
<li>&nbsp; <a href="shared_heap.c.html#L134" title="ocaml/runtime/shared_heap.c:134">caml_teardown_shared_heap</a>(domain_state-&gt;shared_heap);<br/></li>
<li>&nbsp; domain_state-&gt;shared_heap = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="minor_gc.c.html#L107" title="ocaml/runtime/minor_gc.c:107">caml_free_minor_tables</a>(domain_state-&gt;minor_tables);<br/></li>
<li>&nbsp; domain_state-&gt;minor_tables = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="gc_stats.c.html#L90" title="ocaml/runtime/gc_stats.c:90">caml_orphan_alloc_stats</a>(domain_state);<br/></li>
<li>&nbsp; <span class="Comment">/* Heap stats were orphaned by <a href="shared_heap.c.html#L134" title="ocaml/runtime/shared_heap.c:134">caml_teardown_shared_heap</a> above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; At this point, the stats of the domain must be empty;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; we also clear the sampled copy.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Note: We cannot call <a href="gc_stats.c.html#L111" title="ocaml/runtime/gc_stats.c:111">caml_collect_gc_stats_sample</a> to clear the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; sample at this point as the shared heap is gone. */<br/></li>
<li></span>&nbsp; <a href="gc_stats.c.html#L118" title="ocaml/runtime/gc_stats.c:118">caml_clear_gc_stats_sample</a>(domain_state);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment">: can this ever be <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a>? can we remove this check? */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span>(domain_state-&gt;current_stack != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="fiber.c.html#L558" title="ocaml/runtime/fiber.c:558">caml_free_stack</a>(domain_state-&gt;current_stack);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="backtrace_nat.c.html#L80" title="ocaml/runtime/backtrace_nat.c:80">caml_free_backtrace_buffer</a>(domain_state-&gt;backtrace_buffer);<br/></li>
<li>&nbsp; <a href="fiber.c.html#L585" title="ocaml/runtime/fiber.c:585">caml_free_gc_regs_buckets</a>(domain_state-&gt;gc_regs_buckets);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* signal the domain termination to the backup thread<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; NB: for a program with no additional domains, the backup thread<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; will not have been started */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;backup_thread_msg, <a href="#L139" title="ocaml/runtime/domain.c:139">BT_TERMINATE</a>);<br/></li>
<li>&nbsp; <a href="platform.c.html#L121" title="ocaml/runtime/platform.c:121">caml_plat_signal</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;domain_cond);<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;domain_lock);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="platform.c.html#L78" title="ocaml/runtime/platform.c:78">caml_plat_assert_all_locks_unlocked</a>();<br/></li>
<li>&nbsp; <span class="Comment">/* This is the last thing we do because we need to be able to rely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; on <a href="caml/domain.h.html#L93" title="ocaml/runtime/caml/domain.h:93">caml_domain_alone</a> (which uses <a href="caml/domain.h.html#L91" title="ocaml/runtime/caml/domain.h:91">caml_num_domains_running</a>) in at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the shared_heap lockfree fast paths */<br/></li>
<li></span>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="caml/domain.h.html#L91" title="ocaml/runtime/caml/domain.h:91">caml_num_domains_running</a>, -<span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1882">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_domain_cpu_relax</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> t)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>* self = &amp;<a href="#L233" title="ocaml/runtime/domain.c:233">domain_self</a>-&gt;<a href="#L143" title="ocaml/runtime/domain.c:143">interruptor</a>;<br/></li>
<li>&nbsp; <a href="#L319" title="ocaml/runtime/domain.c:319">handle_incoming_otherwise_relax</a> (self);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1889">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_domain_dls_set</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> t)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li>&nbsp; <a href="globroots.c.html#L129" title="ocaml/runtime/globroots.c:129">caml_modify_generational_global_root</a>(&amp;<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;dls_root, t);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1896">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_domain_dls_get</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> unused)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L274" title="ocaml/runtime/caml/misc.h:274">CAMLnoalloc</a>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;dls_root;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1902">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_recommended_domain_count</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> unused)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> n = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(HAS_GNU_GETAFFINITY_NP) || defined(HAS_BSD_GETAFFINITY_NP)<br/></li>
<li></span>&nbsp; <a href="#L36" title="ocaml/runtime/domain.c:36">cpu_set_t</a> cpuset;<br/></li>
<li><br/></li>
<li>&nbsp; CPU_ZERO(&amp;cpuset);<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> case fallsback into next method */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (pthread_getaffinity_np(pthread_self(), <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(cpuset), &amp;cpuset) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; n = CPU_COUNT(&amp;cpuset);<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* HAS_GNU_GETAFFINITY_NP || HAS_BSD_GETAFFINITY_NP */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef _SC_NPROCESSORS_ONLN<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (n == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; n = sysconf(_SC_NPROCESSORS_ONLN);<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* _SC_NPROCESSORS_ONLN */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef _WIN32<br/></li>
<li></span>&nbsp; SYSTEM_INFO sysinfo;<br/></li>
<li>&nbsp; GetSystemInfo(&amp;sysinfo);<br/></li>
<li>&nbsp; n = sysinfo.dwNumberOfProcessors;<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* _WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* At least one, even if system says zero */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (n &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; n = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n &gt; <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>)<br/></li>
<li>&nbsp; &nbsp; n = <a href="caml/domain.h.html#L35" title="ocaml/runtime/caml/domain.h:35">Max_domains</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> (<a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(n));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
