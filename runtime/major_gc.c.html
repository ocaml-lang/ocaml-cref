<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/major_gc.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/major_gc.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L97">alloc_counter</a></li>
<li><a href="#L106">caml_gc_phase</a></li>
<li><a href="#L78">caml_major_cycles_completed</a></li>
<li><a href="#L74">caml_percent_free</a></li>
<li><a href="#L424">caml_stat_space_overhead</a></li>
<li><a href="#L981">chunk_mask</a></li>
<li><a href="#L1026">darken_scanning_flags</a></li>
<li><a href="#L104">domain_global_roots_started</a></li>
<li><a href="#L120">ephe_cycle_info</a></li>
<li><a href="#L126">ephe_lock</a></li>
<li><a href="#L82">num_domains_to_ephe_sweep</a></li>
<li><a href="#L83">num_domains_to_final_update_first</a></li>
<li><a href="#L84">num_domains_to_final_update_last</a></li>
<li><a href="#L81">num_domains_to_mark</a></li>
<li><a href="#L80">num_domains_to_sweep</a></li>
<li><a href="#L260">orph_structs</a></li>
<li><a href="#L262">orphaned_lock</a></li>
<li><a href="#L98">work_counter</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L414">buf_list_t</a></li>
<li><a href="#L636">collection_slice_mode</a></li>
<li><a href="#L110">ephe_cycle_info_t</a></li>
<li><a href="#L100">global_roots_status</a></li>
<li><a href="#L64">mark_entry</a></li>
<li><a href="#L66">mark_stack</a></li>
<li><a href="#L132">prefetch_buffer</a></li>
<li><a href="#L137">prefetch_buffer_t</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1798">add_addr</a></li>
<li><a href="#L264">caml_add_orphaned_finalisers</a></li>
<li><a href="#L332">caml_add_to_orphaned_ephe_list</a></li>
<li><a href="#L361">caml_adopt_orphaned_work</a></li>
<li><a href="#L1052">caml_darken</a></li>
<li><a href="#L1028">caml_darken_cont</a></li>
<li><a href="#L1756">caml_empty_mark_stack</a></li>
<li><a href="#L278">caml_final_domain_terminate</a></li>
<li><a href="#L1931">caml_finalise_heap</a></li>
<li><a href="#L1746">caml_finish_major_cycle</a></li>
<li><a href="#L1769">caml_finish_marking</a></li>
<li><a href="#L1781">caml_finish_sweeping</a></li>
<li><a href="#L1874">caml_init_major_gc</a></li>
<li><a href="#L1702">caml_major_collection_slice</a></li>
<li><a href="#L426">caml_mean_space_overhead</a></li>
<li><a href="#L1697">caml_opportunistic_major_collection_slice</a></li>
<li><a href="#L1457">caml_opportunistic_major_work_available</a></li>
<li><a href="#L786">caml_shrink_mark_stack</a></li>
<li><a href="#L1917">caml_teardown_major_gc</a></li>
<li><a href="#L988">chunk_and_offset_to_ptr</a></li>
<li><a href="#L1463">collection_slice_mode_char</a></li>
<li><a href="#L654">commit_major_slice_work</a></li>
<li><a href="#L1192">cycle_all_domains_callback</a></li>
<li><a href="#L489">diffmod</a></li>
<li><a href="#L852">do_some_marking</a></li>
<li><a href="#L298">ephe_list_tail</a></li>
<li><a href="#L1080">ephe_mark</a></li>
<li><a href="#L206">ephe_next_cycle</a></li>
<li><a href="#L1169">ephe_sweep</a></li>
<li><a href="#L218">ephe_todo_list_emptied</a></li>
<li><a href="#L1728">finish_major_cycle_callback</a></li>
<li><a href="#L638">get_major_slice_work</a></li>
<li><a href="#L1408">is_complete_phase_mark_final</a></li>
<li><a href="#L1394">is_complete_phase_sweep_and_mark_main</a></li>
<li><a href="#L1423">is_complete_phase_sweep_ephe</a></li>
<li><a href="#L1477">major_collection_slice</a></li>
<li><a href="#L993">mark</a></li>
<li><a href="#L808">mark_slice_darken</a></li>
<li><a href="#L1820">mark_stack_prune</a></li>
<li><a href="#L739">mark_stack_push_block</a></li>
<li><a href="#L725">mark_stack_push_range</a></li>
<li><a href="#L457">max2</a></li>
<li><a href="#L475">max3</a></li>
<li><a href="#L466">min2</a></li>
<li><a href="#L291">no_orphaned_work</a></li>
<li><a href="#L310">orph_ephe_list_verify_status</a></li>
<li><a href="#L149">pb_above_waterline</a></li>
<li><a href="#L154">pb_drain_mode</a></li>
<li><a href="#L159">pb_fill_mode</a></li>
<li><a href="#L139">pb_full</a></li>
<li><a href="#L174">pb_pop</a></li>
<li><a href="#L164">pb_push</a></li>
<li><a href="#L144">pb_size</a></li>
<li><a href="#L183">prefetch_block</a></li>
<li><a href="#L982">ptr_to_chunk</a></li>
<li><a href="#L985">ptr_to_chunk_offset</a></li>
<li><a href="#L680">realloc_mark_stack</a></li>
<li><a href="#L238">record_ephe_marking_done</a></li>
<li><a href="#L1435">try_complete_gc_phase</a></li>
<li><a href="#L494">update_major_slice_work</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L412">BUFFER_SIZE</a></li>
<li><a href="#L16">CAML_INTERNALS</a></li>
<li><a href="#L630">Chunk_size</a></li>
<li><a href="#L327">EPHE_MARK_DEFAULT</a></li>
<li><a href="#L328">EPHE_MARK_FORCE_ALIVE</a></li>
<li><a href="#L673">Is_markable</a></li>
<li><a href="#L677">Is_markable</a></li>
<li><a href="#L44">MARK_STACK_INIT_SIZE</a></li>
<li><a href="#L130">PREFETCH_BUFFER_MASK</a></li>
<li><a href="#L129">PREFETCH_BUFFER_MIN</a></li>
<li><a href="#L128">PREFETCH_BUFFER_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Damien Doligez, projet Para, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdbool.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;caml/<a href="caml/addrmap.h.html#L23" title="ocaml/runtime/caml/addrmap.h:23">addrmap</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/codefrag.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/domain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/runtime_events.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fiber.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/finalise.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/globroots.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/<a href="caml/gc_stats.h.html#L68" title="ocaml/runtime/caml/gc_stats.h:68">gc_stats</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/platform.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/roots.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/signals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/shared_heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/startup_aux.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/weak.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* NB the <a href="#L44" title="ocaml/runtime/major_gc.c:44">MARK_STACK_INIT_SIZE</a> must be larger than the number of objects<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that can be in a <a href="memory.c.html#L425" title="ocaml/runtime/memory.c:425">pool</a>, see <a href="caml/sizeclasses.h.html#L2" title="ocaml/runtime/caml/sizeclasses.h:2">POOL_WSIZE</a> */<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MARK_STACK_INIT_SIZE</span> (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">12</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack consists of two parts:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; 1. the stack - a dynamic array of spans of fields that need to be marked, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; 2. the compressed stack - a bitset of fields that need to be marked.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The stack is bounded relative to the heap size. When the stack<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; overflows the bound, then entries from the stack are compressed <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; transferred into the compressed stack, expect for &quot;large&quot; entries,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; spans of more than <a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a> entries, that are more compactly<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; represented as spans <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> remain on the uncompressed stack.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When the stack is empty, the compressed stack is processed.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The compressed stack iterator marks the point up to which<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; compressed stack entries have already been processed.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct</span> {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> start;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> end;<br/></li>
<li><a id="L64">&#x200c;</a>} <span class="linkable">mark_entry</span>; <span class="Comment">/* represents fields in the span [start, end) */<br/></li>
<li></span><br/></li>
<li><a id="L66">&#x200c;</a><span class="Type">struct</span> <span class="linkable">mark_stack</span> {<br/></li>
<li>&nbsp; <a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>* stack;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> count;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/addrmap.h.html#L23" title="ocaml/runtime/caml/addrmap.h:23">addrmap</a> compressed_stack;<br/></li>
<li>&nbsp; <a href="caml/addrmap.h.html#L48" title="ocaml/runtime/caml/addrmap.h:48">addrmap_iterator</a> compressed_stack_iter;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L74">&#x200c;</a><a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">caml_percent_free</span> = <a href="caml/config.h.html#L240" title="ocaml/runtime/caml/config.h:240">Percent_free_def</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* This variable is only written with the world stopped,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; so it need not be atomic */<br/></li>
<li><a id="L78">&#x200c;</a></span><a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">caml_major_cycles_completed</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L80">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">num_domains_to_sweep</span>;<br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">num_domains_to_mark</span>;<br/></li>
<li><a id="L82">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">num_domains_to_ephe_sweep</span>;<br/></li>
<li><a id="L83">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">num_domains_to_final_update_first</span>;<br/></li>
<li><a id="L84">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">num_domains_to_final_update_last</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* These two counters keep track of how much work the GC is supposed to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; do in order to keep up with allocation. Both are in GC work units.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; `<a href="#L97" title="ocaml/runtime/major_gc.c:97">alloc_counter</a>` increases when we allocate: the number of words allocated<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is converted to GC work units <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> added to this counter.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; `<a href="#L98" title="ocaml/runtime/major_gc.c:98">work_counter</a>` increases when the GC has done some work.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The difference between the two is how much the GC is lagging behind<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (<a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> in advance of) allocations.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; These counters can wrap around (see function `<a href="#L489" title="ocaml/runtime/major_gc.c:489">diffmod</a>`) as long as they<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; don't get too far apart, which is guaranteed by the limited size of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; memory.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">alloc_counter</span>;<br/></li>
<li><a id="L98">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">work_counter</span>;<br/></li>
<li><br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">enum</span> <span class="linkable">global_roots_status</span>{<br/></li>
<li>&nbsp; WORK_UNSTARTED,<br/></li>
<li>&nbsp; WORK_STARTED<br/></li>
<li>};<br/></li>
<li><a id="L104">&#x200c;</a><span class="Type">static</span> <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> <span class="linkable">domain_global_roots_started</span>;<br/></li>
<li><br/></li>
<li><a id="L106">&#x200c;</a><a href="caml/major_gc.h.html#L25" title="ocaml/runtime/caml/major_gc.h:25">gc_phase_t</a> <span class="linkable">caml_gc_phase</span>;<br/></li>
<li><br/></li>
<li><span class="Type">extern</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="weak.c.html#L35" title="ocaml/runtime/weak.c:35">caml_ephe_none</a>; <span class="Comment">/* See weak.c */<br/></li>
<li></span><br/></li>
<li><a id="L110">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <span class="linkable">ephe_cycle_info_t</span> {<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> num_domains_todo;<br/></li>
<li>&nbsp; <span class="Comment">/* Number of domains that need to scan their ephemerons in the current major<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * GC cycle. This field is decremented when ephe_info-&gt;todo list at a domain<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * becomes empty.&nbsp; */<br/></li>
<li></span>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> ephe_cycle;<br/></li>
<li>&nbsp; <span class="Comment">/* Ephemeron cycle count */<br/></li>
<li></span>&nbsp; <a href="caml/camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a> num_domains_done;<br/></li>
<li>&nbsp; <span class="Comment">/* Number of domains that have marked their ephemerons in the current<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * ephemeron cycle. */<br/></li>
<li><a id="L120">&#x200c;</a></span>} <span class="linkable">ephe_cycle_info</span>;<br/></li>
<li>&nbsp; <span class="Comment">/* In the first major cycle, there is no ephemeron marking to be done. */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a> is always updated with the critical section protected by<br/></li>
<li></span><span class="Comment"> * <a href="#L126" title="ocaml/runtime/major_gc.c:126">ephe_lock</a> <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> in the global barrier. However, the fields may be read without<br/></li>
<li></span><span class="Comment"> * the lock. */<br/></li>
<li><a id="L126">&#x200c;</a></span><span class="Type">static</span> <a href="caml/platform.h.html#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a> <span class="linkable">ephe_lock</span> = <a href="caml/platform.h.html#L101" title="ocaml/runtime/caml/platform.h:101">CAML_PLAT_MUTEX_INITIALIZER</a>;<br/></li>
<li><br/></li>
<li><a id="L128">&#x200c;</a><span class="PreProc">#define <span class="linkable">PREFETCH_BUFFER_SIZE</span>&nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; </span><span class="Constant">8</span><span class="PreProc">)<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PREFETCH_BUFFER_MIN</span>&nbsp;&nbsp; </span><span class="Constant">64</span><span class="PreProc"> </span><span class="Comment">/* keep pb at least this full */<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PREFETCH_BUFFER_MASK</span>&nbsp; (<a href="#L128" title="ocaml/runtime/major_gc.c:128">PREFETCH_BUFFER_SIZE</a> - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L132">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">prefetch_buffer</span> {<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> enqueued;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> dequeued;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> waterline;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>&nbsp;&nbsp; buffer[<a href="#L128" title="ocaml/runtime/major_gc.c:128">PREFETCH_BUFFER_SIZE</a>];<br/></li>
<li><a id="L137">&#x200c;</a>} <span class="linkable">prefetch_buffer_t</span>;<br/></li>
<li><br/></li>
<li><a id="L139">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">bool</span> <span class="linkable">pb_full</span>(<span class="Type">const</span> <a href="#L137" title="ocaml/runtime/major_gc.c:137">prefetch_buffer_t</a> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> pb-&gt;enqueued == (pb-&gt;dequeued + <a href="#L128" title="ocaml/runtime/major_gc.c:128">PREFETCH_BUFFER_SIZE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L144">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">pb_size</span>(<span class="Type">const</span> <a href="#L137" title="ocaml/runtime/major_gc.c:137">prefetch_buffer_t</a> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> pb-&gt;enqueued - pb-&gt;dequeued;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L149">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">bool</span> <span class="linkable">pb_above_waterline</span>(<span class="Type">const</span> <a href="#L137" title="ocaml/runtime/major_gc.c:137">prefetch_buffer_t</a> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> ((pb-&gt;enqueued - pb-&gt;dequeued) &gt; pb-&gt;waterline);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L154">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">pb_drain_mode</span>(<a href="#L137" title="ocaml/runtime/major_gc.c:137">prefetch_buffer_t</a> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; pb-&gt;waterline = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L159">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">pb_fill_mode</span>(<a href="#L137" title="ocaml/runtime/major_gc.c:137">prefetch_buffer_t</a> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; pb-&gt;waterline = <a href="#L129" title="ocaml/runtime/major_gc.c:129">PREFETCH_BUFFER_MIN</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L164">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">pb_push</span>(<a href="#L137" title="ocaml/runtime/major_gc.c:137">prefetch_buffer_t</a>* pb, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(v) &amp;&amp; !<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(v));<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(v != <a href="caml/misc.h.html#L530" title="ocaml/runtime/caml/misc.h:530">Debug_free_major</a>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(pb-&gt;enqueued &lt; pb-&gt;dequeued + <a href="#L128" title="ocaml/runtime/major_gc.c:128">PREFETCH_BUFFER_SIZE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; pb-&gt;buffer[pb-&gt;enqueued &amp; <a href="#L130" title="ocaml/runtime/major_gc.c:130">PREFETCH_BUFFER_MASK</a>] = v;<br/></li>
<li>&nbsp; pb-&gt;enqueued += <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L174">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">pb_pop</span>(<a href="#L137" title="ocaml/runtime/major_gc.c:137">prefetch_buffer_t</a> *pb)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(pb-&gt;enqueued &gt; pb-&gt;dequeued);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v = pb-&gt;buffer[pb-&gt;dequeued &amp; <a href="#L130" title="ocaml/runtime/major_gc.c:130">PREFETCH_BUFFER_MASK</a>];<br/></li>
<li>&nbsp; pb-&gt;dequeued += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> v;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L183">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">prefetch_block</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* Prefetch a block so that scanning it later avoids cache misses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; We will access at least the header, but we don't yet know how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; many of the fields we will access - the block might be already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; marked, not scannable, <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> very short. The compromise here is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; prefetch the header <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the first few fields.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; We issue two prefetches, with the second being a few words ahead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; of the first. Most of the time, these will land in the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; cacheline, be coalesced by hardware, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> so not cost any more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; than a single prefetch. Two memory operations are issued only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; when the two prefetches land in different cachelines.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; In the case where the block is not already in cache, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> yet is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; already marked, not markable, <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> extremely short, then we waste<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; somewhere between 1/8-1/2 of a prefetch operation (in expectation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; depending on alignment, word size, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> cache line size), which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; cheap enough to make this worthwhile. */<br/></li>
<li></span>&nbsp; <a href="caml/misc.h.html#L156" title="ocaml/runtime/caml/misc.h:156">caml_prefetch</a>(<a href="caml/mlvalues.h.html#L163" title="ocaml/runtime/caml/mlvalues.h:163">Hp_val</a>(v));<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L156" title="ocaml/runtime/caml/misc.h:156">caml_prefetch</a>((<span class="Type">void</span>*)&amp;<a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, <span class="Constant">3</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L206">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">ephe_next_cycle</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L126" title="ocaml/runtime/major_gc.c:126">ephe_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.ephe_cycle, +<span class="Constant">1</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_todo));<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L67" title="ocaml/runtime/caml/camlatomic.h:67">atomic_store</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L126" title="ocaml/runtime/major_gc.c:126">ephe_lock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L218">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">ephe_todo_list_emptied</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L126" title="ocaml/runtime/major_gc.c:126">ephe_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Force next ephemeron marking cycle in order to avoid reasoning about<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * whether the domain has already incremented<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * [<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done] counter. */<br/></li>
<li></span>&nbsp; <a href="caml/camlatomic.h.html#L67" title="ocaml/runtime/caml/camlatomic.h:67">atomic_store</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.ephe_cycle, +<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Since the todo list is empty, this domain does not need to participate in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * further ephemeron cycles. */<br/></li>
<li></span>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_todo, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_todo));<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L126" title="ocaml/runtime/major_gc.c:126">ephe_lock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Record that ephemeron marking was done for the given ephemeron cycle. */<br/></li>
<li><a id="L238">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">record_ephe_marking_done</span> (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> ephe_cycle)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (ephe_cycle &lt;= <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.ephe_cycle));<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;marking_done);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (ephe_cycle &lt; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.ephe_cycle))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L126" title="ocaml/runtime/major_gc.c:126">ephe_lock</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ephe_cycle == <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.ephe_cycle)) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;ephe_info-&gt;cycle = ephe_cycle;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done, +<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_todo));<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L126" title="ocaml/runtime/major_gc.c:126">ephe_lock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* These are biased data structures left over from terminating domains. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ephe_list_live;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/finalise.h.html#L58" title="ocaml/runtime/caml/finalise.h:58">caml_final_info</a> *final_info;<br/></li>
<li><a id="L260">&#x200c;</a>} <span class="linkable">orph_structs</span> = {<span class="Constant">0</span>, <span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li><a id="L262">&#x200c;</a><span class="Type">static</span> <a href="caml/platform.h.html#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a> <span class="linkable">orphaned_lock</span> = <a href="caml/platform.h.html#L101" title="ocaml/runtime/caml/platform.h:101">CAML_PLAT_MUTEX_INITIALIZER</a>;<br/></li>
<li><br/></li>
<li><a id="L264">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_add_orphaned_finalisers</span> (<span class="Type">struct</span> <a href="caml/finalise.h.html#L58" title="ocaml/runtime/caml/finalise.h:58">caml_final_info</a>* f)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_sweep_and_mark_main);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!f-&gt;updated_first);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!f-&gt;updated_last);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L262" title="ocaml/runtime/major_gc.c:262">orphaned_lock</a>);<br/></li>
<li>&nbsp; f-&gt;next = <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.final_info;<br/></li>
<li>&nbsp; <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.final_info = f;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L262" title="ocaml/runtime/major_gc.c:262">orphaned_lock</a>);<br/></li>
<li><br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Called by terminating domain from <a href="domain.c.html#L1739" title="ocaml/runtime/domain.c:1739">handover_finalisers</a> */<br/></li>
<li><a id="L278">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_final_domain_terminate</span> (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> *domain_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/finalise.h.html#L58" title="ocaml/runtime/caml/finalise.h:58">caml_final_info</a> *f = domain_state-&gt;final_info;<br/></li>
<li>&nbsp; <span class="Statement">if</span>(!f-&gt;updated_first) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L83" title="ocaml/runtime/major_gc.c:83">num_domains_to_final_update_first</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; f-&gt;updated_first = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span>(!f-&gt;updated_last) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L84" title="ocaml/runtime/major_gc.c:84">num_domains_to_final_update_last</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; f-&gt;updated_last = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L291">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">no_orphaned_work</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.ephe_list_live == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.final_info == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L298">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">ephe_list_tail</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> e)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> last = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (e != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(e) == <a href="caml/mlvalues.h.html#L324" title="ocaml/runtime/caml/mlvalues.h:324">Abstract_tag</a>);<br/></li>
<li>&nbsp; &nbsp; last = e;<br/></li>
<li>&nbsp; &nbsp; e = <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(e);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> last;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li><a id="L310">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">orph_ephe_list_verify_status</span> (<span class="Type">int</span> <a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L262" title="ocaml/runtime/major_gc.c:262">orphaned_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; v = <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.ephe_list_live;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (v) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(v) == <a href="caml/mlvalues.h.html#L324" title="ocaml/runtime/caml/mlvalues.h:324">Abstract_tag</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/shared_heap.h.html#L67" title="ocaml/runtime/caml/shared_heap.h:67">Has_status_val</a>(v, <a href="caml/shared_heap.h.html#L54" title="ocaml/runtime/caml/shared_heap.h:54">status</a>));<br/></li>
<li>&nbsp; &nbsp; v = <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(v);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L262" title="ocaml/runtime/major_gc.c:262">orphaned_lock</a>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L327">&#x200c;</a><span class="PreProc">#define <span class="linkable">EPHE_MARK_DEFAULT</span> </span><span class="Constant">0<br/></li>
<li><a id="L328">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EPHE_MARK_FORCE_ALIVE</span> </span><span class="Constant">1<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <a href="#L1080" title="ocaml/runtime/major_gc.c:1080">ephe_mark</a> (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> budget, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> for_cycle, <span class="Type">int</span> force_alive);<br/></li>
<li><br/></li>
<li><a id="L332">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_add_to_orphaned_ephe_list</span>(<span class="Type">struct</span> <a href="caml/weak.h.html#L31" title="ocaml/runtime/caml/weak.h:31">caml_ephe_info</a>* ephe_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L262" title="ocaml/runtime/major_gc.c:262">orphaned_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Force all ephemerons <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> their data on todo list to be alive */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (ephe_info-&gt;todo) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (ephe_info-&gt;todo) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L1080" title="ocaml/runtime/major_gc.c:1080">ephe_mark</a> (<span class="Constant">100000</span>, <span class="Constant">0</span>, <a href="#L328" title="ocaml/runtime/major_gc.c:328">EPHE_MARK_FORCE_ALIVE</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="ocaml/runtime/major_gc.c:218">ephe_todo_list_emptied</a> ();<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (ephe_info-&gt;todo == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (ephe_info-&gt;live) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> live_tail = <a href="#L298" title="ocaml/runtime/major_gc.c:298">ephe_list_tail</a>(ephe_info-&gt;live);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(live_tail) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(live_tail) = <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.ephe_list_live;<br/></li>
<li>&nbsp; &nbsp; <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.ephe_list_live = ephe_info-&gt;live;<br/></li>
<li>&nbsp; &nbsp; ephe_info-&gt;live = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L262" title="ocaml/runtime/major_gc.c:262">orphaned_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (ephe_info-&gt;must_sweep_ephe) {<br/></li>
<li>&nbsp; &nbsp; ephe_info-&gt;must_sweep_ephe = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L82" title="ocaml/runtime/major_gc.c:82">num_domains_to_ephe_sweep</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L361">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_adopt_orphaned_work</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> last;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/finalise.h.html#L58" title="ocaml/runtime/caml/finalise.h:58">caml_final_info</a> *f, *myf, *temp;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L291" title="ocaml/runtime/major_gc.c:291">no_orphaned_work</a>() || <a href="domain.c.html#L1758" title="ocaml/runtime/domain.c:1758">caml_domain_is_terminating</a>())<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;<a href="#L262" title="ocaml/runtime/major_gc.c:262">orphaned_lock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.ephe_list_live) {<br/></li>
<li>&nbsp; &nbsp; last = <a href="#L298" title="ocaml/runtime/major_gc.c:298">ephe_list_tail</a>(<a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.ephe_list_live);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(last) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(last) = domain_state-&gt;ephe_info-&gt;live;<br/></li>
<li>&nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;live = <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.ephe_list_live;<br/></li>
<li>&nbsp; &nbsp; <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.ephe_list_live = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; f = <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.final_info;<br/></li>
<li>&nbsp; myf = domain_state-&gt;final_info;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (f != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!f-&gt;updated_first);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!f-&gt;updated_last);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!myf-&gt;updated_first);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (!myf-&gt;updated_last);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_sweep_and_mark_main);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (f-&gt;todo_head) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (myf-&gt;todo_tail == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(myf-&gt;todo_head == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myf-&gt;todo_head = f-&gt;todo_head;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myf-&gt;todo_tail = f-&gt;todo_tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myf-&gt;todo_tail-&gt;next = f-&gt;todo_head;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myf-&gt;todo_tail = f-&gt;todo_tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (f-&gt;first.young &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="finalise.c.html#L306" title="ocaml/runtime/finalise.c:306">caml_final_merge_finalisable</a> (&amp;f-&gt;first, &amp;myf-&gt;first);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (f-&gt;last.young &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="finalise.c.html#L306" title="ocaml/runtime/finalise.c:306">caml_final_merge_finalisable</a> (&amp;f-&gt;last, &amp;myf-&gt;last);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; temp = f;<br/></li>
<li>&nbsp; &nbsp; f = f-&gt;next;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a> (temp);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L260" title="ocaml/runtime/major_gc.c:260">orph_structs</a>.final_info = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;<a href="#L262" title="ocaml/runtime/major_gc.c:262">orphaned_lock</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L412">&#x200c;</a><span class="PreProc">#define <span class="linkable">BUFFER_SIZE</span> </span><span class="Constant">64<br/></li>
<li></span><br/></li>
<li><a id="L414">&#x200c;</a><span class="Type">struct</span> <span class="linkable">buf_list_t</span> {<br/></li>
<li>&nbsp; <span class="Type">double</span> buffer[<a href="#L412" title="ocaml/runtime/major_gc.c:412">BUFFER_SIZE</a>];<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L414" title="ocaml/runtime/major_gc.c:414">buf_list_t</a> *next;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> {<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> heap_words_last_cycle;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> not_garbage_words_last_cycle;<br/></li>
<li>&nbsp; <span class="Type">int</span> index;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L414" title="ocaml/runtime/major_gc.c:414">buf_list_t</a> *l;<br/></li>
<li><a id="L424">&#x200c;</a> } <span class="linkable">caml_stat_space_overhead</span> = {<span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>};<br/></li>
<li><br/></li>
<li><a id="L426">&#x200c;</a><span class="Type">double</span> <span class="linkable">caml_mean_space_overhead</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> index = <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.index;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L414" title="ocaml/runtime/major_gc.c:414">buf_list_t</a> *t, *l = <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.l;<br/></li>
<li>&nbsp; <span class="Comment">/* Use Welford's online algorithm for calculating running variance to remove<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * outliers from mean calculation. */<br/></li>
<li></span>&nbsp; <span class="Type">double</span> mean = <span class="Constant">0.0</span>, m2 = <span class="Constant">0.0</span>, stddev = <span class="Constant">0.0</span>, v;<br/></li>
<li>&nbsp; <span class="Type">double</span> delta, delta2;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (l) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (index &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; v = l-&gt;buffer[--index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &gt; <span class="Constant">5</span> &amp;&amp; (v &lt; mean - <span class="Constant">3</span> * stddev || v &gt; mean + <span class="Constant">3</span> * stddev)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; delta = v - mean;<br/></li>
<li>&nbsp; &nbsp; &nbsp; mean = mean + delta / count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; delta2 = v - mean;<br/></li>
<li>&nbsp; &nbsp; &nbsp; m2 = m2 + delta * delta2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; stddev = sqrt (m2 / count);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; t = l;<br/></li>
<li>&nbsp; &nbsp; l = l-&gt;next;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(t);<br/></li>
<li>&nbsp; &nbsp; index = <a href="#L412" title="ocaml/runtime/major_gc.c:412">BUFFER_SIZE</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> mean;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L457">&#x200c;</a><span class="Type">static</span> <span class="Type">inline</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">max2</span> (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> a, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (a &gt; <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>){<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L466">&#x200c;</a><span class="Type">static</span> <span class="Type">inline</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">min2</span> (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> a, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (a &lt; <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>){<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> a;<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L475">&#x200c;</a><span class="Type">static</span> <span class="Type">inline</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">max3</span>(<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> a, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> c)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (a &gt; <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>){<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L457" title="ocaml/runtime/major_gc.c:457">max2</a> (a, c);<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L457" title="ocaml/runtime/major_gc.c:457">max2</a> (<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>, c);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Take two natural numbers n1 <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> n2 <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> let N = 2^{64}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Assume that n1 <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> n2 are not too far apart (less than N/2).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Given unsigned numbers x1 = n1 modulo N <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> x2 = n2 modulo N, return<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the (signed) difference between n1 <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> n2.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L489">&#x200c;</a></span><span class="Type">static</span> <span class="Type">inline</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">diffmod</span> (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> x1, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> x2)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>) (x1 - x2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L494">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">update_major_slice_work</span>(<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> howmuch) {<br/></li>
<li>&nbsp; <span class="Type">double</span> heap_words;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> alloc_work, dependent_work, extra_work, new_work;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> my_alloc_count, my_dependent_count;<br/></li>
<li>&nbsp; <span class="Type">double</span> my_extra_count;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> *dom_st = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> heap_size, heap_sweep_words, total_cycle_work;<br/></li>
<li><br/></li>
<li>&nbsp; my_alloc_count = dom_st-&gt;allocated_words;<br/></li>
<li>&nbsp; my_dependent_count = dom_st-&gt;dependent_allocated;<br/></li>
<li>&nbsp; my_extra_count = dom_st-&gt;extra_heap_resources;<br/></li>
<li>&nbsp; dom_st-&gt;stat_major_words += dom_st-&gt;allocated_words;<br/></li>
<li>&nbsp; dom_st-&gt;allocated_words = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; dom_st-&gt;dependent_allocated = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; dom_st-&gt;extra_heap_resources = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Free memory at the start of the GC cycle (garbage + free list) (assumed):<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FM = heap_words * <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / (100 + <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Assuming steady state <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> enforcing a constant allocation rate, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; FM is divided in 2/3 for garbage <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> 1/3 for free list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; G = 2 * FM / 3<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; G is also the amount of memory that will be used during this cycle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; (still assuming steady state).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Proportion of G consumed since the previous slice:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PH = dom_st-&gt;allocated_words / G<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = dom_st-&gt;allocated_words * 3 * (100 + <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / (2 * heap_words * <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Proportion of extra-heap resources consumed since the previous slice:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PE = dom_st-&gt;extra_heap_resources<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Proportion of total work to do in this slice:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P&nbsp; = max (PH, PE)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Amount of marking work for the GC cycle:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MW = heap_words * 100 / (100 + <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Amount of sweeping work for the GC cycle:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SW = heap_sweep_words<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Amount of total work for the GC cycle:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TW = MW + SW<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = heap_words * 100 / (100 + <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>) + heap_sweep_words<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Amount of time to spend on this slice:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/misc.h.html#L363" title="ocaml/runtime/caml/misc.h:363">T</a> = P * TT<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Since we must do TW amount of work in TT time, the amount of work done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; for this slice is:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; S = P * TW<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span>&nbsp; heap_size = <a href="shared_heap.c.html#L580" title="ocaml/runtime/shared_heap.c:580">caml_heap_size</a>(dom_st-&gt;shared_heap);<br/></li>
<li>&nbsp; heap_words = (<span class="Type">double</span>)<a href="caml/mlvalues.h.html#L182" title="ocaml/runtime/caml/mlvalues.h:182">Wsize_bsize</a>(heap_size);<br/></li>
<li>&nbsp; heap_sweep_words = heap_words;<br/></li>
<li><br/></li>
<li>&nbsp; total_cycle_work =<br/></li>
<li>&nbsp; &nbsp; heap_sweep_words + (heap_words * <span class="Constant">100</span> / (<span class="Constant">100</span> + <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (heap_words &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span> alloc_ratio =<br/></li>
<li>&nbsp; &nbsp; &nbsp; total_cycle_work<br/></li>
<li>&nbsp; &nbsp; &nbsp; * <span class="Constant">3.0</span> * (<span class="Constant">100</span> + <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; / heap_words / <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a> / <span class="Constant">2.0</span>;<br/></li>
<li>&nbsp; &nbsp; alloc_work = (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>) (my_alloc_count * alloc_ratio);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; alloc_work = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (dom_st-&gt;dependent_size &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span> dependent_ratio =<br/></li>
<li>&nbsp; &nbsp; &nbsp; total_cycle_work<br/></li>
<li>&nbsp; &nbsp; &nbsp; * (<span class="Constant">100</span> + <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; / dom_st-&gt; dependent_size / <a href="#L74" title="ocaml/runtime/major_gc.c:74">caml_percent_free</a>;<br/></li>
<li>&nbsp; &nbsp; dependent_work = (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>) (my_dependent_count * dependent_ratio);<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; dependent_work = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; extra_work = (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>) (my_extra_count * (<span class="Type">double</span>) total_cycle_work);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x40</span>, <span class="Constant">&quot;heap_words = %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)heap_words);<br/></li>
<li>&nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x40</span>, <span class="Constant">&quot;allocated_words = %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dom_st-&gt;allocated_words);<br/></li>
<li>&nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x40</span>, <span class="Constant">&quot;alloc work-to-do = %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; alloc_work);<br/></li>
<li>&nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x40</span>, <span class="Constant">&quot;dependent_words = %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dom_st-&gt;dependent_allocated);<br/></li>
<li>&nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x40</span>, <span class="Constant">&quot;dependent work-to-do = %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dependent_work);<br/></li>
<li>&nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x40</span>, <span class="Constant">&quot;extra_heap_resources = %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;uu</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) (dom_st-&gt;extra_heap_resources * <span class="Constant">1000000</span>));<br/></li>
<li>&nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a> (<span class="Constant">0x40</span>, <span class="Constant">&quot;extra work-to-do = %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra_work);<br/></li>
<li><br/></li>
<li>&nbsp; new_work = <a href="#L475" title="ocaml/runtime/major_gc.c:475">max3</a> (alloc_work, dependent_work, extra_work);<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a> (&amp;<a href="#L98" title="ocaml/runtime/major_gc.c:98">work_counter</a>, dom_st-&gt;major_work_done_between_slices);<br/></li>
<li>&nbsp; dom_st-&gt;major_work_done_between_slices = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a> (&amp;<a href="#L97" title="ocaml/runtime/major_gc.c:97">alloc_counter</a>, new_work);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (howmuch == <a href="caml/major_gc.h.html#L44" title="ocaml/runtime/caml/major_gc.h:44">AUTO_TRIGGERED_MAJOR_SLICE</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; howmuch == <a href="caml/major_gc.h.html#L46" title="ocaml/runtime/caml/major_gc.h:46">GC_CALCULATE_MAJOR_SLICE</a>) {<br/></li>
<li>&nbsp; &nbsp; dom_st-&gt;slice_target = <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="#L97" title="ocaml/runtime/major_gc.c:97">alloc_counter</a>);<br/></li>
<li>&nbsp; &nbsp; dom_st-&gt;slice_budget = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* forced <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> opportunistic GC slice with explicit quantity */<br/></li>
<li></span>&nbsp; &nbsp; dom_st-&gt;slice_target = <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="#L98" title="ocaml/runtime/major_gc.c:98">work_counter</a>);&nbsp; <span class="Comment">/* already reached */<br/></li>
<li></span>&nbsp; &nbsp; dom_st-&gt;slice_budget = howmuch;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Updated major work: [</span><span class="Special">%c</span><span class="Constant">] &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u heap_words, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u allocated, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d alloc_work, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d dependent_work, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d extra_work,&nbsp; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u work counter </span><span class="Special">%s</span><span class="Constant">,&nbsp; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u alloc counter,&nbsp; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;u slice target,&nbsp; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d slice budget&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/major_gc.h.html#L28" title="ocaml/runtime/caml/major_gc.h:28">caml_gc_phase_char</a>(<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)heap_words, dom_st-&gt;allocated_words,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alloc_work, dependent_work, extra_work,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="#L98" title="ocaml/runtime/major_gc.c:98">work_counter</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="#L98" title="ocaml/runtime/major_gc.c:98">work_counter</a>) &gt; <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="#L97" title="ocaml/runtime/major_gc.c:97">alloc_counter</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <span class="Constant">&quot;[ahead]&quot;</span> : <span class="Constant">&quot;[behind]&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="#L97" title="ocaml/runtime/major_gc.c:97">alloc_counter</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dom_st-&gt;slice_target, dom_st-&gt;slice_budget<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L630">&#x200c;</a><span class="PreProc">#define <span class="linkable">Chunk_size</span> </span><span class="Constant">0x4000<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">enum</span> {<br/></li>
<li>&nbsp; Slice_uninterruptible,<br/></li>
<li>&nbsp; Slice_interruptible,<br/></li>
<li>&nbsp; Slice_opportunistic<br/></li>
<li><a id="L636">&#x200c;</a>} <span class="linkable">collection_slice_mode</span>;<br/></li>
<li><br/></li>
<li><a id="L638">&#x200c;</a><span class="Type">static</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">get_major_slice_work</span>(<a href="#L636" title="ocaml/runtime/major_gc.c:636">collection_slice_mode</a> mode){<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> *dom_st = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (mode == Slice_interruptible &amp;&amp; <a href="domain.c.html#L300" title="ocaml/runtime/domain.c:300">caml_incoming_interrupts_queued</a>())<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* calculate how much work remains to do for this slice */<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> budget =<br/></li>
<li>&nbsp; &nbsp; <a href="#L457" title="ocaml/runtime/major_gc.c:457">max2</a> (<a href="#L489" title="ocaml/runtime/major_gc.c:489">diffmod</a> (dom_st-&gt;slice_target, <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="#L98" title="ocaml/runtime/major_gc.c:98">work_counter</a>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dom_st-&gt;slice_budget);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L466" title="ocaml/runtime/major_gc.c:466">min2</a>(budget, <a href="#L630" title="ocaml/runtime/major_gc.c:630">Chunk_size</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Register the work done by a chunk of slice.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Clear requested_global_major_slice if the work counter has caught up with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the slice's target counter. */<br/></li>
<li><a id="L654">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">commit_major_slice_work</span>(<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> words_done) {<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> *dom_st = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Commit major slice work: &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d words_done, &quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; words_done);<br/></li>
<li><br/></li>
<li>&nbsp; dom_st-&gt;slice_budget -= words_done;<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a> (&amp;<a href="#L98" title="ocaml/runtime/major_gc.c:98">work_counter</a>, words_done);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L489" title="ocaml/runtime/major_gc.c:489">diffmod</a> (dom_st-&gt;slice_target, <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="#L98" title="ocaml/runtime/major_gc.c:98">work_counter</a>)) &lt;= <span class="Constant">0</span>){<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We've done enough work by ourselves, no need to interrupt the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; domains. */<br/></li>
<li></span>&nbsp; &nbsp; dom_st-&gt;requested_global_major_slice = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1820" title="ocaml/runtime/major_gc.c:1820">mark_stack_prune</a>(<span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* stk);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li><a id="L673">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Is_markable</span>(v) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (v != <a href="caml/misc.h.html#L530" title="ocaml/runtime/caml/misc.h:530">Debug_free_major</a>), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(v) &amp;&amp; !<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(v))<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L677">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Is_markable</span>(v) (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(v) &amp;&amp; !<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(v))<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L680">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">realloc_mark_stack</span> (<span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* stk)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>* new;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> mark_stack_large_bsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> mark_stack_bsize = stk-&gt;size * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> local_heap_bsize = <a href="shared_heap.c.html#L580" title="ocaml/runtime/shared_heap.c:580">caml_heap_size</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;shared_heap);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* When the <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack might not increase, we count the large <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; to adjust our alloaction. This is needed because large <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; will not compress <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> because we are using a domain local heap bound we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; need to fit large blocks into the local <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack. See PR#11284 */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (mark_stack_bsize &gt;= local_heap_bsize / <span class="Constant">32</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> i;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; stk-&gt;count; ++i) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>* me = &amp;stk-&gt;stack[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (me-&gt;end - me-&gt;start &gt; <a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mark_stack_large_bsize += <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (mark_stack_bsize - mark_stack_large_bsize &lt; local_heap_bsize / <span class="Constant">32</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> target_bsize = (mark_stack_bsize - mark_stack_large_bsize) * <span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + mark_stack_large_bsize;<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Growing <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack to %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;uk bytes&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;(large block %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;uk bytes)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target_bsize / <span class="Constant">1024</span>, mark_stack_large_bsize / <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new = (<a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>*) <a href="memory.c.html#L573" title="ocaml/runtime/memory.c:573">caml_stat_resize_noexc</a> ((<span class="Type">char</span>*) stk-&gt;stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_bsize);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; stk-&gt;stack = new;<br/></li>
<li>&nbsp; &nbsp; &nbsp; stk-&gt;size = target_bsize / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;No room for growing <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack. Compressing..</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Mark stack size is %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;u &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;bytes (&gt; major heap size of this domain %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;u bytes / 32). Compressing..</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mark_stack_bsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_heap_bsize);<br/></li>
<li>&nbsp; <a href="#L1820" title="ocaml/runtime/major_gc.c:1820">mark_stack_prune</a>(stk);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L725">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">mark_stack_push_range</span>(<span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* stk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> start, <a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> end)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>* me;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (stk-&gt;count == stk-&gt;size)<br/></li>
<li>&nbsp; &nbsp; <a href="#L680" title="ocaml/runtime/major_gc.c:680">realloc_mark_stack</a>(stk);<br/></li>
<li><br/></li>
<li>&nbsp; me = &amp;stk-&gt;stack[stk-&gt;count++];<br/></li>
<li>&nbsp; me-&gt;start = start;<br/></li>
<li>&nbsp; me-&gt;end = end;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* returns the work done by skipping unmarkable objects */<br/></li>
<li><a id="L739">&#x200c;</a></span><span class="Type">static</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">mark_stack_push_block</span>(<span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* stk, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> block)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i, end;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> block_wsz = <a href="caml/mlvalues.h.html#L174" title="ocaml/runtime/caml/mlvalues.h:174">Wosize_val</a>(block), offset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(block) == <a href="caml/mlvalues.h.html#L275" title="ocaml/runtime/caml/mlvalues.h:275">Closure_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip the code pointers <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> integers at beginning of closure;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; start scanning at the first word of the environment part. */<br/></li>
<li></span>&nbsp; &nbsp; offset = <a href="caml/mlvalues.h.html#L285" title="ocaml/runtime/caml/mlvalues.h:285">Start_env_closinfo</a>(<a href="caml/mlvalues.h.html#L277" title="ocaml/runtime/caml/mlvalues.h:277">Closinfo_val</a>(block));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(offset &lt;= <a href="caml/mlvalues.h.html#L174" title="ocaml/runtime/caml/mlvalues.h:174">Wosize_val</a>(block)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &amp;&amp; offset &gt;= <a href="caml/mlvalues.h.html#L285" title="ocaml/runtime/caml/mlvalues.h:285">Start_env_closinfo</a>(<a href="caml/mlvalues.h.html#L277" title="ocaml/runtime/caml/mlvalues.h:277">Closinfo_val</a>(block)));<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/shared_heap.h.html#L67" title="ocaml/runtime/caml/shared_heap.h:67">Has_status_val</a>(block, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED));<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(block) &amp;&amp; !<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(block));<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(block) != <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(block) &lt; <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(block) != <a href="caml/mlvalues.h.html#L300" title="ocaml/runtime/caml/mlvalues.h:300">Cont_tag</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Optimisation to avoid pushing small, unmarkable objects such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [Some 42] into the <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack. */<br/></li>
<li></span>&nbsp; end = (block_wsz &lt; <span class="Constant">8</span> ? block_wsz : <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = offset; i &lt; end; i++) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(block, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L673" title="ocaml/runtime/major_gc.c:673">Is_markable</a>(v))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (i == block_wsz){<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing left to <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> credit header */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L178" title="ocaml/runtime/caml/mlvalues.h:178">Whsize_wosize</a>(block_wsz - offset);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L725" title="ocaml/runtime/major_gc.c:725">mark_stack_push_range</a>(stk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a>(block) + i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a>(block) + block_wsz);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* take credit for the work we skipped due to the optimisation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; we will take credit for the header later as part of marking. */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> i - offset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* This function shrinks the <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack back to the <a href="#L44" title="ocaml/runtime/major_gc.c:44">MARK_STACK_INIT_SIZE</a> size<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> is called at domain termination via <a href="#L1769" title="ocaml/runtime/major_gc.c:1769">caml_finish_marking</a>. */<br/></li>
<li><a id="L786">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">caml_shrink_mark_stack</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* stk = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> init_stack_bsize = <a href="#L44" title="ocaml/runtime/major_gc.c:44">MARK_STACK_INIT_SIZE</a> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>);<br/></li>
<li>&nbsp; <a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>* shrunk_stack;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Shrinking <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack to %&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;uk bytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; init_stack_bsize / <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; shrunk_stack = (<a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>*) <a href="memory.c.html#L573" title="ocaml/runtime/memory.c:573">caml_stat_resize_noexc</a> ((<span class="Type">char</span>*) stk-&gt;stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; init_stack_bsize);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (shrunk_stack != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; stk-&gt;stack = shrunk_stack;<br/></li>
<li>&nbsp; &nbsp; stk-&gt;size = <a href="#L44" title="ocaml/runtime/major_gc.c:44">MARK_STACK_INIT_SIZE</a>;<br/></li>
<li>&nbsp; }<span class="Statement">else</span>{<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;Mark stack shrinking failed&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void</span> <a href="#L1028" title="ocaml/runtime/major_gc.c:1028">caml_darken_cont</a>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont);<br/></li>
<li><br/></li>
<li><a id="L808">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">mark_slice_darken</span>(<span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* stk, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> child,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>* work)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> chd;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L673" title="ocaml/runtime/major_gc.c:673">Is_markable</a>(child)){<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* This part of the code is duplicated in <a href="#L852" title="ocaml/runtime/major_gc.c:852">do_some_marking</a> for performance<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * reasons.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * Changes here should probably be reflected in <a href="#L852" title="ocaml/runtime/major_gc.c:852">do_some_marking</a>. */<br/></li>
<li></span>&nbsp; &nbsp; chd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(child);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(chd) == <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; child -= <a href="caml/mlvalues.h.html#L249" title="ocaml/runtime/caml/mlvalues.h:249">Infix_offset_hd</a>(chd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; chd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(child);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!<a href="caml/shared_heap.h.html#L63" title="ocaml/runtime/caml/shared_heap.h:63">Has_status_hd</a>(chd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.GARBAGE));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/shared_heap.h.html#L63" title="ocaml/runtime/caml/shared_heap.h:63">Has_status_hd</a>(chd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.UNMARKED)){<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stat_blocks_marked++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(chd) == <a href="caml/mlvalues.h.html#L300" title="ocaml/runtime/caml/mlvalues.h:300">Cont_tag</a>){<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1028" title="ocaml/runtime/major_gc.c:1028">caml_darken_cont</a>(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *work -= <a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a>(chd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(chd) == <a href="caml/mlvalues.h.html#L297" title="ocaml/runtime/caml/mlvalues.h:297">Lazy_tag</a> || <a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(chd) == <a href="caml/mlvalues.h.html#L304" title="ocaml/runtime/caml/mlvalues.h:304">Forcing_tag</a>){<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span>(!<a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(child), &amp;chd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/shared_heap.h.html#L71" title="ocaml/runtime/caml/shared_heap.h:71">With_status_hd</a>(chd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED))){<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L60" title="ocaml/runtime/caml/platform.h:60">atomic_store_relaxed</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(child),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/shared_heap.h.html#L71" title="ocaml/runtime/caml/shared_heap.h:71">With_status_hd</a>(chd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span>(<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(chd) &lt; <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>){<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *work -= <a href="#L739" title="ocaml/runtime/major_gc.c:739">mark_stack_push_block</a>(stk, child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *work -= <a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a>(chd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L852">&#x200c;</a><a href="caml/misc.h.html#L105" title="ocaml/runtime/caml/misc.h:105">Caml_noinline</a> <span class="Type">static</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">do_some_marking</span>(<span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* stk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> budget) {<br/></li>
<li>&nbsp; <a href="#L137" title="ocaml/runtime/major_gc.c:137">prefetch_buffer_t</a> pb = { .enqueued = <span class="Constant">0</span>, .dequeued = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .waterline = <a href="#L129" title="ocaml/runtime/major_gc.c:129">PREFETCH_BUFFER_MIN</a> };<br/></li>
<li>&nbsp; <a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a> me;<br/></li>
<li>&nbsp; <span class="Comment">/* These global values are cached in locals,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; so that they can be stored in registers */<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="caml/shared_heap.h.html#L55" title="ocaml/runtime/caml/shared_heap.h:55">global_heap_state</a> heap_state = <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> blocks_marked = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L149" title="ocaml/runtime/major_gc.c:149">pb_above_waterline</a>(&amp;pb)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Dequeue from prefetch buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> block = <a href="#L174" title="ocaml/runtime/major_gc.c:174">pb_pop</a>(&amp;pb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="#L673" title="ocaml/runtime/major_gc.c:673">Is_markable</a>(block));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* This part of the code is a duplicate of <a href="#L808" title="ocaml/runtime/major_gc.c:808">mark_slice_darken</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * performance reasons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; * Changes here should probably be reflected here in <a href="#L808" title="ocaml/runtime/major_gc.c:808">mark_slice_darken</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> hd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) == <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block -= <a href="caml/mlvalues.h.html#L249" title="ocaml/runtime/caml/mlvalues.h:249">Infix_offset_hd</a>(hd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!<a href="caml/shared_heap.h.html#L63" title="ocaml/runtime/caml/shared_heap.h:63">Has_status_hd</a>(hd, heap_state.GARBAGE));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="caml/shared_heap.h.html#L63" title="ocaml/runtime/caml/shared_heap.h:63">Has_status_hd</a>(hd, heap_state.UNMARKED)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Already black, nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; blocks_marked++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) == <a href="caml/mlvalues.h.html#L300" title="ocaml/runtime/caml/mlvalues.h:300">Cont_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1028" title="ocaml/runtime/major_gc.c:1028">caml_darken_cont</a>(block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; budget -= <a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a>(hd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) == <a href="caml/mlvalues.h.html#L297" title="ocaml/runtime/caml/mlvalues.h:297">Lazy_tag</a> || <a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) == <a href="caml/mlvalues.h.html#L304" title="ocaml/runtime/caml/mlvalues.h:304">Forcing_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(block), &amp;hd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/shared_heap.h.html#L71" title="ocaml/runtime/caml/shared_heap.h:71">With_status_hd</a>(hd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED))) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L60" title="ocaml/runtime/caml/platform.h:60">atomic_store_relaxed</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(block),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/shared_heap.h.html#L71" title="ocaml/runtime/caml/shared_heap.h:71">With_status_hd</a>(hd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED));<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; budget--; <span class="Comment">/* header word */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) &gt;= <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to scan here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; budget -= <a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a>(hd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; me.start = <a href="caml/mlvalues.h.html#L225" title="ocaml/runtime/caml/mlvalues.h:225">Op_val</a>(block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; me.end = me.start + <a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a>(hd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) == <a href="caml/mlvalues.h.html#L275" title="ocaml/runtime/caml/mlvalues.h:275">Closure_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> env_offset = <a href="caml/mlvalues.h.html#L285" title="ocaml/runtime/caml/mlvalues.h:285">Start_env_closinfo</a>(<a href="caml/mlvalues.h.html#L277" title="ocaml/runtime/caml/mlvalues.h:277">Closinfo_val</a>(block));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; budget -= env_offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; me.start += env_offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (budget &lt;= <span class="Constant">0</span> || stk-&gt;count == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pb.waterline &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Dequeue from pb even when close to empty, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; we have nothing else to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L154" title="ocaml/runtime/major_gc.c:154">pb_drain_mode</a>(&amp;pb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Couldn't find work with pb in draining mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so there's nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; me = stk-&gt;stack[--stk-&gt;count];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> scan_end = me.end;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan_end - me.start &gt; budget) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> scan_len = budget &lt; <span class="Constant">0</span> ? <span class="Constant">0</span> : budget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; scan_end = me.start + scan_len;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; me.start &lt; scan_end; me.start++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(budget &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> child = *me.start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; budget--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L673" title="ocaml/runtime/major_gc.c:673">Is_markable</a>(child)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L139" title="ocaml/runtime/major_gc.c:139">pb_full</a>(&amp;pb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L183" title="ocaml/runtime/major_gc.c:183">prefetch_block</a>(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L164" title="ocaml/runtime/major_gc.c:164">pb_push</a>(&amp;pb, child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (me.start &lt; me.end) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Didn't finish scanning this object, either because budget &lt;= 0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> the prefetch buffer filled up. Leave the rest on the stack. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L725" title="ocaml/runtime/major_gc.c:725">mark_stack_push_range</a>(stk, me.start, me.end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L156" title="ocaml/runtime/caml/misc.h:156">caml_prefetch</a>((<span class="Type">void</span>*)(me.start + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L144" title="ocaml/runtime/major_gc.c:144">pb_size</a>(&amp;pb) &gt; <a href="#L129" title="ocaml/runtime/major_gc.c:129">PREFETCH_BUFFER_MIN</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We may have just discovered more work when we were about to run out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Reset waterline so that we try to refill the buffer again. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="ocaml/runtime/major_gc.c:159">pb_fill_mode</a>(&amp;pb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stat_blocks_marked += blocks_marked;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="#L144" title="ocaml/runtime/major_gc.c:144">pb_size</a>(&amp;pb) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> budget;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Compressed <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; We use a bitset, implemented as a hashtable storing word-sized<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; integers (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>). Each integer represents a &quot;chunk&quot; of addresses<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that may <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> may not be present in the stack.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L981">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">chunk_mask</span> = ~(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)(<a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a>-<span class="Constant">1</span>);<br/></li>
<li><a id="L982">&#x200c;</a><span class="Type">static</span> <span class="Type">inline</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">ptr_to_chunk</span>(<a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> ptr) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> ((<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)(ptr) / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)) &amp; <a href="#L981" title="ocaml/runtime/major_gc.c:981">chunk_mask</a>;<br/></li>
<li>}<br/></li>
<li><a id="L985">&#x200c;</a><span class="Type">static</span> <span class="Type">inline</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">ptr_to_chunk_offset</span>(<a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> ptr) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> ((<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)(ptr) / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)) &amp; ~<a href="#L981" title="ocaml/runtime/major_gc.c:981">chunk_mask</a>;<br/></li>
<li>}<br/></li>
<li><a id="L988">&#x200c;</a><span class="Type">static</span> <span class="Type">inline</span> <a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> <span class="linkable">chunk_and_offset_to_ptr</span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> chunk, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> offset) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a>)((chunk + offset) * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> until the budget runs out <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> marking is done */<br/></li>
<li><a id="L993">&#x200c;</a></span><span class="Type">static</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">mark</span>(<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> budget) {<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a> *domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (budget &gt; <span class="Constant">0</span> &amp;&amp; !domain_state-&gt;marking_done) {<br/></li>
<li>&nbsp; &nbsp; budget = <a href="#L852" title="ocaml/runtime/major_gc.c:852">do_some_marking</a>(domain_state-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>, budget);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (budget &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* mstk = domain_state-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/addrmap.h.html#L48" title="ocaml/runtime/caml/addrmap.h:48">addrmap_iterator</a> it = mstk-&gt;compressed_stack_iter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/addrmap.h.html#L49" title="ocaml/runtime/caml/addrmap.h:49">caml_addrmap_iter_ok</a>(&amp;mstk-&gt;compressed_stack, it)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> chunk = <a href="caml/addrmap.h.html#L71" title="ocaml/runtime/caml/addrmap.h:71">caml_addrmap_iter_key</a>(&amp;mstk-&gt;compressed_stack, it);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> bitset = <a href="caml/addrmap.h.html#L78" title="ocaml/runtime/caml/addrmap.h:78">caml_addrmap_iter_value</a>(&amp;mstk-&gt;compressed_stack, it);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NB: must update the iterator here, as possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L808" title="ocaml/runtime/major_gc.c:808">mark_slice_darken</a> could lead to the <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack being pruned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> invalidation of the iterator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mstk-&gt;compressed_stack_iter =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/addrmap.h.html#L59" title="ocaml/runtime/caml/addrmap.h:59">caml_addrmap_next</a>(&amp;mstk-&gt;compressed_stack, it);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span>(<span class="Type">int</span> ofs=<span class="Constant">0</span>; ofs&lt;<a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a>; ofs++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span>(bitset &amp; ((<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)<span class="Constant">1</span> &lt;&lt; ofs)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> p = <a href="#L988" title="ocaml/runtime/major_gc.c:988">chunk_and_offset_to_ptr</a>(chunk, ofs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L808" title="ocaml/runtime/major_gc.c:808">mark_slice_darken</a>(domain_state-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>, *p, &amp;budget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="ocaml/runtime/major_gc.c:206">ephe_next_cycle</a> ();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;marking_done = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L81" title="ocaml/runtime/major_gc.c:81">num_domains_to_mark</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> budget;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1026">&#x200c;</a><span class="Type">static</span> <a href="caml/roots.h.html#L26" title="ocaml/runtime/caml/roots.h:26">scanning_action_flags</a> <span class="linkable">darken_scanning_flags</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L1028">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_darken_cont</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(cont) &amp;&amp; !<a href="caml/address_class.h.html#L51" title="ocaml/runtime/caml/address_class.h:51">Is_young</a>(cont) &amp;&amp; <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(cont) == <a href="caml/mlvalues.h.html#L300" title="ocaml/runtime/caml/mlvalues.h:300">Cont_tag</a>);<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L75" title="ocaml/runtime/caml/platform.h:75">SPIN_WAIT</a> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> hd = <a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(cont));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!<a href="caml/shared_heap.h.html#L63" title="ocaml/runtime/caml/shared_heap.h:63">Has_status_hd</a>(hd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.GARBAGE));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/shared_heap.h.html#L63" title="ocaml/runtime/caml/shared_heap.h:63">Has_status_hd</a>(hd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/shared_heap.h.html#L63" title="ocaml/runtime/caml/shared_heap.h:63">Has_status_hd</a>(hd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.UNMARKED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(cont), &amp;hd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/shared_heap.h.html#L71" title="ocaml/runtime/caml/shared_heap.h:71">With_status_hd</a>(hd, NOT_MARKABLE))) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> stk = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(cont, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L268" title="ocaml/runtime/caml/mlvalues.h:268">Ptr_val</a>(stk) != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fiber.c.html#L277" title="ocaml/runtime/fiber.c:277">caml_scan_stack</a>(&amp;<a href="#L1052" title="ocaml/runtime/major_gc.c:1052">caml_darken</a>, <a href="#L1026" title="ocaml/runtime/major_gc.c:1026">darken_scanning_flags</a>, <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L268" title="ocaml/runtime/caml/mlvalues.h:268">Ptr_val</a>(stk), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(<a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(cont),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/shared_heap.h.html#L71" title="ocaml/runtime/caml/shared_heap.h:71">With_status_hd</a>(hd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED));<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1052">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_darken</span>(<span class="Type">void</span>* state, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v, <span class="Type">volatile</span> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* ignored) {<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> hd;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="#L673" title="ocaml/runtime/major_gc.c:673">Is_markable</a> (v)) <span class="Statement">return</span>; <span class="Comment">/* foreign stack, at least */<br/></li>
<li></span><br/></li>
<li>&nbsp; hd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(v);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) == <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; v -= <a href="caml/mlvalues.h.html#L249" title="ocaml/runtime/caml/mlvalues.h:249">Infix_offset_hd</a>(hd);<br/></li>
<li>&nbsp; &nbsp; hd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(v);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/shared_heap.h.html#L63" title="ocaml/runtime/caml/shared_heap.h:63">Has_status_hd</a>(hd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.UNMARKED)) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>*)state;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (domain_state-&gt;marking_done) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L81" title="ocaml/runtime/major_gc.c:81">num_domains_to_mark</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain_state-&gt;marking_done = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) == <a href="caml/mlvalues.h.html#L300" title="ocaml/runtime/caml/mlvalues.h:300">Cont_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L1028" title="ocaml/runtime/major_gc.c:1028">caml_darken_cont</a>(v);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L60" title="ocaml/runtime/caml/platform.h:60">atomic_store_relaxed</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/mlvalues.h.html#L156" title="ocaml/runtime/caml/mlvalues.h:156">Hp_atomic_val</a>(v),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/shared_heap.h.html#L71" title="ocaml/runtime/caml/shared_heap.h:71">With_status_hd</a>(hd, <a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L129" title="ocaml/runtime/caml/mlvalues.h:129">Tag_hd</a>(hd) &lt; <a href="caml/mlvalues.h.html#L219" title="ocaml/runtime/caml/mlvalues.h:219">No_scan_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L739" title="ocaml/runtime/major_gc.c:739">mark_stack_push_block</a>(domain_state-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1080">&#x200c;</a><span class="Type">static</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">ephe_mark</span> (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> budget, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> for_cycle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* Forces ephemerons <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> their data to be alive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> force_alive)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v, data, key, f, todo;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* prev_linkp;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L58" title="ocaml/runtime/caml/mlvalues.h:58">header_t</a> hd;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> size, i;<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <span class="Type">int</span> alive_data;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> marked = <span class="Constant">0</span>, made_live = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (domain_state-&gt;ephe_info-&gt;cursor.cycle == for_cycle &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; !force_alive) {<br/></li>
<li>&nbsp; &nbsp; prev_linkp = domain_state-&gt;ephe_info-&gt;cursor.todop;<br/></li>
<li>&nbsp; &nbsp; todo = *prev_linkp;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; todo = domain_state-&gt;ephe_info-&gt;todo;<br/></li>
<li>&nbsp; &nbsp; prev_linkp = &amp;domain_state-&gt;ephe_info-&gt;todo;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">while</span> (todo != <span class="Constant">0</span> &amp;&amp; budget &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; v = todo;<br/></li>
<li>&nbsp; &nbsp; todo = <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(v);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(v) == <a href="caml/mlvalues.h.html#L324" title="ocaml/runtime/caml/mlvalues.h:324">Abstract_tag</a>);<br/></li>
<li>&nbsp; &nbsp; hd = <a href="caml/mlvalues.h.html#L157" title="ocaml/runtime/caml/mlvalues.h:157">Hd_val</a>(v);<br/></li>
<li>&nbsp; &nbsp; data = <a href="caml/weak.h.html#L75" title="ocaml/runtime/caml/weak.h:75">Ephe_data</a>(v);<br/></li>
<li>&nbsp; &nbsp; alive_data = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (force_alive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L1052" title="ocaml/runtime/major_gc.c:1052">caml_darken</a> (domain_state, v, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If ephemeron is unmarked, data is dead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/shared_heap.h.html#L79" title="ocaml/runtime/caml/shared_heap.h:79">is_unmarked</a>(v)) alive_data = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="caml/mlvalues.h.html#L131" title="ocaml/runtime/caml/mlvalues.h:131">Wosize_hd</a>(hd);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="caml/weak.h.html#L71" title="ocaml/runtime/caml/weak.h:71">CAML_EPHE_FIRST_KEY</a>; alive_data &amp;&amp; i &lt; size; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; key = <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, i);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">ephemeron_again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key != <a href="weak.c.html#L35" title="ocaml/runtime/weak.c:35">caml_ephe_none</a> &amp;&amp; <a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(key)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(key) == <a href="caml/mlvalues.h.html#L239" title="ocaml/runtime/caml/mlvalues.h:239">Forward_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f = <a href="caml/mlvalues.h.html#L240" title="ocaml/runtime/caml/mlvalues.h:240">Forward_val</a>(key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(f)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(f) == <a href="caml/mlvalues.h.html#L239" title="ocaml/runtime/caml/mlvalues.h:239">Forward_tag</a> || <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(f) == <a href="caml/mlvalues.h.html#L297" title="ocaml/runtime/caml/mlvalues.h:297">Lazy_tag</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(f) == <a href="caml/mlvalues.h.html#L304" title="ocaml/runtime/caml/mlvalues.h:304">Forcing_tag</a> || <a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(f) == <a href="caml/mlvalues.h.html#L336" title="ocaml/runtime/caml/mlvalues.h:336">Double_tag</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do not short-circuit the pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(v, i) = key = f;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> ephemeron_again;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a> (key) == <a href="caml/mlvalues.h.html#L248" title="ocaml/runtime/caml/mlvalues.h:248">Infix_tag</a>) key -= <a href="caml/mlvalues.h.html#L250" title="ocaml/runtime/caml/mlvalues.h:250">Infix_offset_val</a> (key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/shared_heap.h.html#L79" title="ocaml/runtime/caml/shared_heap.h:79">is_unmarked</a> (key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alive_data = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; budget -= <a href="caml/mlvalues.h.html#L178" title="ocaml/runtime/caml/mlvalues.h:178">Whsize_wosize</a>(i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (force_alive || alive_data) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (data != <a href="weak.c.html#L35" title="ocaml/runtime/weak.c:35">caml_ephe_none</a> &amp;&amp; <a href="caml/mlvalues.h.html#L73" title="ocaml/runtime/caml/mlvalues.h:73">Is_block</a>(data)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1052" title="ocaml/runtime/major_gc.c:1052">caml_darken</a> (domain_state, data, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(v) = domain_state-&gt;ephe_info-&gt;live;<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;live = v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; *prev_linkp = todo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; made_live++;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Leave this ephemeron on the todo list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; prev_linkp = &amp;<a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(v);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; marked++;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a><br/></li>
<li>&nbsp; (<span class="Constant">&quot;Mark Ephemeron: </span><span class="Special">%s</span><span class="Constant">. Ephemeron cycle=%&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d &quot;<br/></li>
<li></span>&nbsp;&nbsp; <span class="Constant">&quot;examined=%&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d &quot;<br/></li>
<li></span>&nbsp;&nbsp; <span class="Constant">&quot;marked=%&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d&quot;</span>,<br/></li>
<li>&nbsp;&nbsp; domain_state-&gt;ephe_info-&gt;cursor.cycle == for_cycle ?<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Continued from cursor&quot;</span> : <span class="Constant">&quot;Discarded cursor&quot;</span>,<br/></li>
<li>&nbsp;&nbsp; for_cycle, marked, made_live);<br/></li>
<li><br/></li>
<li>&nbsp; domain_state-&gt;ephe_info-&gt;cursor.cycle = for_cycle;<br/></li>
<li>&nbsp; domain_state-&gt;ephe_info-&gt;cursor.todop = prev_linkp;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> budget;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1169">&#x200c;</a><span class="Type">static</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">ephe_sweep</span> (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> budget)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_sweep_ephe);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span> (domain_state-&gt;ephe_info-&gt;todo != <span class="Constant">0</span> &amp;&amp; budget &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; v = domain_state-&gt;ephe_info-&gt;todo;<br/></li>
<li>&nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;todo = <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(v);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/mlvalues.h.html#L199" title="ocaml/runtime/caml/mlvalues.h:199">Tag_val</a>(v) == <a href="caml/mlvalues.h.html#L324" title="ocaml/runtime/caml/mlvalues.h:324">Abstract_tag</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/shared_heap.h.html#L79" title="ocaml/runtime/caml/shared_heap.h:79">is_unmarked</a>(v)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* The whole array is dead, drop this ephemeron */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; budget -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="weak.c.html#L123" title="ocaml/runtime/weak.c:123">caml_ephe_clean</a>(v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(v) = domain_state-&gt;ephe_info-&gt;live;<br/></li>
<li>&nbsp; &nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;live = v;<br/></li>
<li>&nbsp; &nbsp; &nbsp; budget -= <a href="caml/mlvalues.h.html#L190" title="ocaml/runtime/caml/mlvalues.h:190">Whsize_val</a>(v);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> budget;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1192">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">cycle_all_domains_callback</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain, <span class="Type">void</span>* unused,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** participating)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> num_domains_in_stw;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_GC_CYCLE_DOMAINS);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(domain == <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_todo) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done));<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(&amp;<a href="#L81" title="ocaml/runtime/major_gc.c:81">num_domains_to_mark</a>) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(&amp;<a href="#L80" title="ocaml/runtime/major_gc.c:80">num_domains_to_sweep</a>) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a>(&amp;<a href="#L82" title="ocaml/runtime/major_gc.c:82">num_domains_to_ephe_sweep</a>) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="minor_gc.c.html#L748" title="ocaml/runtime/minor_gc.c:748">caml_empty_minor_heap_no_major_slice_from_stw</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (domain, (<span class="Type">void</span>*)<span class="Constant">0</span>, participating_count, participating);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_GC_STW);<br/></li>
<li><br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cycle major heap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">// </span><span class="Todo">FIXME</span><span class="Comment">: delete <a href="shared_heap.c.html#L882" title="ocaml/runtime/shared_heap.c:882">caml_cycle_heap_stw</a> <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> have per-domain copies of the data?<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/domain.h.html#L115" title="ocaml/runtime/caml/domain.h:115">barrier_status</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> = <a href="domain.c.html#L1216" title="ocaml/runtime/domain.c:1216">caml_global_barrier_begin</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="domain.c.html#L1222" title="ocaml/runtime/domain.c:1222">caml_global_barrier_is_final</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="shared_heap.c.html#L882" title="ocaml/runtime/shared_heap.c:882">caml_cycle_heap_stw</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;GC cycle </span><span class="Special">%lu</span><span class="Constant"> completed (heap cycled)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">unsigned</span> <span class="Type">int</span>)<a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a>(<span class="Constant">0x40</span>, <span class="Constant">&quot;Starting major GC cycle</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;<a href="misc.c.html#L79" title="ocaml/runtime/misc.c:79">caml_verb_gc</a>) &amp; <span class="Constant">0x400</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="caml/gc_stats.h.html#L68" title="ocaml/runtime/caml/gc_stats.h:68">gc_stats</a> s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> heap_words, not_garbage_words, swept_words;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gc_stats.c.html#L124" title="ocaml/runtime/gc_stats.c:124">caml_compute_gc_stats</a>(&amp;s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heap_words = s.<a href="caml/gc_stats.h.html#L35" title="ocaml/runtime/caml/gc_stats.h:35">heap_stats</a>.pool_words + s.<a href="caml/gc_stats.h.html#L35" title="ocaml/runtime/caml/gc_stats.h:35">heap_stats</a>.large_words;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; not_garbage_words = s.<a href="caml/gc_stats.h.html#L35" title="ocaml/runtime/caml/gc_stats.h:35">heap_stats</a>.pool_live_words<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + s.<a href="caml/gc_stats.h.html#L35" title="ocaml/runtime/caml/gc_stats.h:35">heap_stats</a>.large_words;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; swept_words = domain-&gt;swept_words;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a> (<span class="Constant">&quot;heap_words: %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;not_garbage_words %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;swept_words %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a><span class="Constant">&quot;d&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap_words, not_garbage_words, swept_words);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.heap_words_last_cycle != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* At the end of a major cycle, no object has colour MARKED.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [not_garbage_words] counts all objects which are UNMARKED.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Importantly, this includes both live objects <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> objects which are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; unreachable in the current cycle (i.e, garbage). But we don't get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; to know which objects are garbage until the end of the next cycle.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; live_words@N = not_garbage_words@N - swept_words@N+1<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; space_overhead@N =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 100.0 * (heap_words@N - live_words@N) / live_words@N<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> live_words_last_cycle =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.not_garbage_words_last_cycle - swept_words;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> space_overhead =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">100.0</span> * (<span class="Type">double</span>)(<a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.heap_words_last_cycle<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - live_words_last_cycle) / live_words_last_cycle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.l == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.index == <a href="#L412" title="ocaml/runtime/major_gc.c:412">BUFFER_SIZE</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L414" title="ocaml/runtime/major_gc.c:414">buf_list_t</a> *l =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> <a href="#L414" title="ocaml/runtime/major_gc.c:414">buf_list_t</a>*)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="#L414" title="ocaml/runtime/major_gc.c:414">buf_list_t</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l-&gt;next = <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.l = l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.l-&gt;buffer[<a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.index++] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; space_overhead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Previous cycle's space_overhead: </span><span class="Special">%lf</span><span class="Constant">&quot;</span>, space_overhead);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.heap_words_last_cycle = heap_words;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L424" title="ocaml/runtime/major_gc.c:424">caml_stat_space_overhead</a>.not_garbage_words_last_cycle<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; = not_garbage_words;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; domain-&gt;swept_words = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; num_domains_in_stw = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)<a href="domain.c.html#L1248" title="ocaml/runtime/domain.c:1248">caml_global_barrier_num_domains</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L80" title="ocaml/runtime/major_gc.c:80">num_domains_to_sweep</a>, num_domains_in_stw);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L81" title="ocaml/runtime/major_gc.c:81">num_domains_to_mark</a>, num_domains_in_stw);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> = Phase_sweep_and_mark_main;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L67" title="ocaml/runtime/caml/camlatomic.h:67">atomic_store</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_todo, num_domains_in_stw);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L67" title="ocaml/runtime/caml/camlatomic.h:67">atomic_store</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.ephe_cycle, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L67" title="ocaml/runtime/caml/camlatomic.h:67">atomic_store</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L82" title="ocaml/runtime/major_gc.c:82">num_domains_to_ephe_sweep</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Will be set to the correct number when switching to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [Phase_sweep_ephe] */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L83" title="ocaml/runtime/major_gc.c:83">num_domains_to_final_update_first</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_domains_in_stw);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L84" title="ocaml/runtime/major_gc.c:84">num_domains_to_final_update_last</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_domains_in_stw);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/camlatomic.h.html#L67" title="ocaml/runtime/caml/camlatomic.h:67">atomic_store</a>(&amp;<a href="#L104" title="ocaml/runtime/major_gc.c:104">domain_global_roots_started</a>, WORK_UNSTARTED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Cleanups for various data structures that must be done in a STW by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; only a single domain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="codefrag.c.html#L163" title="ocaml/runtime/codefrag.c:163">caml_code_fragment_cleanup</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">// should interrupts be processed here <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> not?<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">// depends on whether marking above may need interrupts<br/></li>
<li></span>&nbsp; &nbsp; <a href="domain.c.html#L1227" title="ocaml/runtime/domain.c:1227">caml_global_barrier_end</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* If the heap is to be verified, do it before the domains continue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; running OCaml code. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="startup_aux.c.html#L41" title="ocaml/runtime/startup_aux.c:41">caml_params</a>-&gt;verify_heap) {<br/></li>
<li>&nbsp; &nbsp; <a href="shared_heap.c.html#L776" title="ocaml/runtime/shared_heap.c:776">caml_verify_heap</a>(domain);<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Heap verified&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="domain.c.html#L1242" title="ocaml/runtime/domain.c:1242">caml_global_barrier</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="shared_heap.c.html#L892" title="ocaml/runtime/shared_heap.c:892">caml_cycle_heap</a>(domain-&gt;shared_heap);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Collect domain-local stats to emit to runtime events */<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="caml/gc_stats.h.html#L35" title="ocaml/runtime/caml/gc_stats.h:35">heap_stats</a> local_stats;<br/></li>
<li>&nbsp; <a href="shared_heap.c.html#L639" title="ocaml/runtime/shared_heap.c:639">caml_collect_heap_stats_sample</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;shared_heap, &amp;local_stats);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_MAJOR_HEAP_POOL_WORDS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)local_stats.pool_words);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_MAJOR_HEAP_POOL_LIVE_WORDS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)local_stats.pool_live_words);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_MAJOR_HEAP_LARGE_WORDS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)local_stats.large_words);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_MAJOR_HEAP_POOL_FRAG_WORDS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)(local_stats.pool_frag_words));<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_MAJOR_HEAP_POOL_LIVE_BLOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)local_stats.pool_live_blocks);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L44" title="ocaml/runtime/caml/runtime_events.h:44">CAML_EV_COUNTER</a>(EV_C_MAJOR_HEAP_LARGE_BLOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)local_stats.large_blocks);<br/></li>
<li><br/></li>
<li>&nbsp; domain-&gt;sweeping_done = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Mark roots for new cycle */<br/></li>
<li></span>&nbsp; domain-&gt;marking_done = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_MARK_ROOTS);<br/></li>
<li>&nbsp; <a href="roots.c.html#L35" title="ocaml/runtime/roots.c:35">caml_do_roots</a> (&amp;<a href="#L1052" title="ocaml/runtime/major_gc.c:1052">caml_darken</a>, <a href="#L1026" title="ocaml/runtime/major_gc.c:1026">darken_scanning_flags</a>, domain, domain, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> work_unstarted = WORK_UNSTARTED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span>(<a href="caml/camlatomic.h.html#L68" title="ocaml/runtime/caml/camlatomic.h:68">atomic_compare_exchange_strong</a>(&amp;<a href="#L104" title="ocaml/runtime/major_gc.c:104">domain_global_roots_started</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;work_unstarted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WORK_STARTED)){<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globroots.c.html#L233" title="ocaml/runtime/globroots.c:233">caml_scan_global_roots</a>(&amp;<a href="#L1052" title="ocaml/runtime/major_gc.c:1052">caml_darken</a>, domain);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_MARK_ROOTS);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (domain-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;count == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; !<a href="caml/addrmap.h.html#L49" title="ocaml/runtime/caml/addrmap.h:49">caml_addrmap_iter_ok</a>(&amp;domain-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;compressed_stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domain-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;compressed_stack_iter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; ) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L81" title="ocaml/runtime/major_gc.c:81">num_domains_to_mark</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; domain-&gt;marking_done = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Ephemerons */<br/></li>
<li></span>&nbsp; <span class="Comment">// Adopt orphaned work from domains that were spawned <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> terminated in<br/></li>
<li></span>&nbsp; <span class="Comment">// the previous cycle.<br/></li>
<li></span><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; <a href="#L310" title="ocaml/runtime/major_gc.c:310">orph_ephe_list_verify_status</a> (<a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.UNMARKED);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <a href="#L361" title="ocaml/runtime/major_gc.c:361">caml_adopt_orphaned_work</a> ();<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(domain-&gt;ephe_info-&gt;todo == (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; domain-&gt;ephe_info-&gt;todo = domain-&gt;ephe_info-&gt;live;<br/></li>
<li>&nbsp; domain-&gt;ephe_info-&gt;live = (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain-&gt;ephe_info-&gt;must_sweep_ephe = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain-&gt;ephe_info-&gt;cycle = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain-&gt;ephe_info-&gt;cursor.todop = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; domain-&gt;ephe_info-&gt;cursor.cycle = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (domain-&gt;ephe_info-&gt;todo == (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="ocaml/runtime/major_gc.c:218">ephe_todo_list_emptied</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Finalisers */<br/></li>
<li></span>&nbsp; domain-&gt;final_info-&gt;updated_first = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; domain-&gt;final_info-&gt;updated_last = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* To ensure a mutator doesn't resume while global roots are being marked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Mutators can alter the set of global roots, to preserve its correctness,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; they should not run while global roots are being marked.*/<br/></li>
<li></span>&nbsp; <a href="domain.c.html#L1242" title="ocaml/runtime/domain.c:1242">caml_global_barrier</a>();<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Someone should flush the allocation stats we gathered during the cycle */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span>( participating[<span class="Constant">0</span>] == <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a> ) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L36" title="ocaml/runtime/caml/runtime_events.h:36">CAML_EV_ALLOC_FLUSH</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_GC_STW);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_GC_CYCLE_DOMAINS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1394">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">is_complete_phase_sweep_and_mark_main</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_sweep_and_mark_main &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;<a href="#L80" title="ocaml/runtime/major_gc.c:80">num_domains_to_sweep</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;<a href="#L81" title="ocaml/runtime/major_gc.c:81">num_domains_to_mark</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Marking is done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_todo) ==<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ephemeron marking is done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L291" title="ocaml/runtime/major_gc.c:291">no_orphaned_work</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All orphaned ephemerons have been adopted */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L1408">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">is_complete_phase_mark_final</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_mark_final &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;<a href="#L83" title="ocaml/runtime/major_gc.c:83">num_domains_to_final_update_first</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* updated finalise first values */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;<a href="#L81" title="ocaml/runtime/major_gc.c:81">num_domains_to_mark</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Marking is done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_todo) ==<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.num_domains_done) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ephemeron marking is done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L291" title="ocaml/runtime/major_gc.c:291">no_orphaned_work</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All orphaned ephemerons have been adopted */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L1423">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">is_complete_phase_sweep_ephe</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_sweep_ephe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;<a href="#L82" title="ocaml/runtime/major_gc.c:82">num_domains_to_ephe_sweep</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All domains have swept their ephemerons */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a> (&amp;<a href="#L84" title="ocaml/runtime/major_gc.c:84">num_domains_to_final_update_last</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All domains have updated finalise last values */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L291" title="ocaml/runtime/major_gc.c:291">no_orphaned_work</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All orphaned structures have been adopted */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L1435">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">try_complete_gc_phase</span> (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain, <span class="Type">void</span>* unused,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participant_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** participating)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain.h.html#L115" title="ocaml/runtime/caml/domain.h:115">barrier_status</a> <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>;<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_GC_PHASE_CHANGE);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a> = <a href="domain.c.html#L1216" title="ocaml/runtime/domain.c:1216">caml_global_barrier_begin</a> ();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="domain.c.html#L1222" title="ocaml/runtime/domain.c:1222">caml_global_barrier_is_final</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1394" title="ocaml/runtime/major_gc.c:1394">is_complete_phase_sweep_and_mark_main</a>()) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> = Phase_mark_final;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1408" title="ocaml/runtime/major_gc.c:1408">is_complete_phase_mark_final</a>()) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> = Phase_sweep_ephe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L58" title="ocaml/runtime/caml/platform.h:58">atomic_store_release</a>(&amp;<a href="#L82" title="ocaml/runtime/major_gc.c:82">num_domains_to_ephe_sweep</a>, participant_count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; participant_count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; participating[i]-&gt;ephe_info-&gt;must_sweep_ephe = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="domain.c.html#L1227" title="ocaml/runtime/domain.c:1227">caml_global_barrier_end</a>(<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>);<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_GC_PHASE_CHANGE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1457">&#x200c;</a><a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">caml_opportunistic_major_work_available</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> !domain_state-&gt;sweeping_done || !domain_state-&gt;marking_done;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1463">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> <span class="linkable">collection_slice_mode_char</span>(<a href="#L636" title="ocaml/runtime/major_gc.c:636">collection_slice_mode</a> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">switch</span>(mode) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> Slice_uninterruptible:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">'u'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> Slice_interruptible:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">'i'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> Slice_opportunistic:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">'o'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1477">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">major_collection_slice</span>(<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> howmuch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participant_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** barrier_participants,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L636" title="ocaml/runtime/major_gc.c:636">collection_slice_mode</a> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> sweep_work = <span class="Constant">0</span>, mark_work = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> blocks_marked_before = domain_state-&gt;stat_blocks_marked;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> saved_ephe_cycle;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> saved_major_cycle = <a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a>;<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> budget;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Type">int</span> log_events = mode != Slice_opportunistic ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;<a href="misc.c.html#L79" title="ocaml/runtime/misc.c:79">caml_verb_gc</a>) &amp; <span class="Constant">0x40</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L494" title="ocaml/runtime/major_gc.c:494">update_major_slice_work</a>(howmuch);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* When a full slice of major GC work is done,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> the slice is interrupted (in mode Slice_interruptible),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode) will return a budget &lt;= 0 */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* shortcut out if there is no opportunistic work to be done<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * NB: needed particularly to avoid caml_ev spam when polling */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (mode == Slice_opportunistic &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; !<a href="#L1457" title="ocaml/runtime/major_gc.c:1457">caml_opportunistic_major_work_available</a>()) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L654" title="ocaml/runtime/major_gc.c:654">commit_major_slice_work</a> (<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (log_events) <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_SLICE);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L207" title="ocaml/runtime/caml/misc.h:207">call_timing_hook</a>(&amp;<a href="misc.c.html#L40" title="ocaml/runtime/misc.c:40">caml_major_slice_begin_hook</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!domain_state-&gt;sweeping_done) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (log_events) <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_SWEEP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!domain_state-&gt;sweeping_done &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (budget = <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode)) &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> left = <a href="shared_heap.c.html#L546" title="ocaml/runtime/shared_heap.c:546">caml_sweep</a>(domain_state-&gt;shared_heap, budget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> work_done = budget - left;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; sweep_work += work_done;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L654" title="ocaml/runtime/major_gc.c:654">commit_major_slice_work</a> (work_done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (work_done == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;sweeping_done = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L80" title="ocaml/runtime/major_gc.c:80">num_domains_to_sweep</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (log_events) <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_SWEEP);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">mark_again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (!domain_state-&gt;marking_done &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode) &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (log_events) <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_MARK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!domain_state-&gt;marking_done &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (budget = <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode)) &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> left = <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a>(budget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> work_done = budget - left;<br/></li>
<li>&nbsp; &nbsp; &nbsp; mark_work += work_done;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L654" title="ocaml/runtime/major_gc.c:654">commit_major_slice_work</a>(work_done);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (log_events) <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_MARK);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (mode != Slice_opportunistic) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finalisers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_mark_final &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode) &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="finalise.c.html#L116" title="ocaml/runtime/finalise.c:116">caml_final_update_first</a>(domain_state)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* This domain has updated finalise first values */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L83" title="ocaml/runtime/major_gc.c:83">num_domains_to_final_update_first</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!domain_state-&gt;marking_done &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> mark_again;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_sweep_ephe &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode) &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="finalise.c.html#L129" title="ocaml/runtime/finalise.c:129">caml_final_update_last</a>(domain_state)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* This domain has updated finalise last values */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L84" title="ocaml/runtime/major_gc.c:84">num_domains_to_final_update_last</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing has been marked while updating last */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L310" title="ocaml/runtime/major_gc.c:310">orph_ephe_list_verify_status</a> (<a href="shared_heap.c.html#L39" title="ocaml/runtime/shared_heap.c:39">caml_global_heap_state</a>.MARKED);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L361" title="ocaml/runtime/major_gc.c:361">caml_adopt_orphaned_work</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ephemerons */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> != Phase_sweep_ephe) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Ephemeron Marking */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; saved_ephe_cycle = <a href="caml/platform.h.html#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(&amp;<a href="#L120" title="ocaml/runtime/major_gc.c:120">ephe_cycle_info</a>.ephe_cycle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (domain_state-&gt;ephe_info-&gt;todo != (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saved_ephe_cycle &gt; domain_state-&gt;ephe_info-&gt;cycle &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode) &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_EPHE_MARK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> ephe_completed_marking = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (domain_state-&gt;ephe_info-&gt;todo != (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>) <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; saved_ephe_cycle &gt; domain_state-&gt;ephe_info-&gt;cycle &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (budget = <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode)) &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> left = <a href="#L1080" title="ocaml/runtime/major_gc.c:1080">ephe_mark</a>(budget, saved_ephe_cycle, <a href="#L327" title="ocaml/runtime/major_gc.c:327">EPHE_MARK_DEFAULT</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> work_done = budget - left;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L654" title="ocaml/runtime/major_gc.c:654">commit_major_slice_work</a> (work_done);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">// </span><span class="Todo">FIXME</span><span class="Comment">: Can we delete this?<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (left &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ephe_completed_marking = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (domain_state-&gt;ephe_info-&gt;todo == (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L218" title="ocaml/runtime/major_gc.c:218">ephe_todo_list_emptied</a> ();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ephe_completed_marking) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!domain_state-&gt;marking_done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> mark_again;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="ocaml/runtime/major_gc.c:238">record_ephe_marking_done</a>(saved_ephe_cycle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> == Phase_sweep_ephe) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Ephemeron Sweeping */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (domain_state-&gt;ephe_info-&gt;must_sweep_ephe) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move the ephemerons on the live list to the todo list. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; needed since the live list may contain ephemerons with unmarked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; keys, which need to be cleaned. This code is executed exactly once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; per major cycle per domain. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;must_sweep_ephe = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> e = <a href="#L298" title="ocaml/runtime/major_gc.c:298">ephe_list_tail</a> (domain_state-&gt;ephe_info-&gt;todo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (e == (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;todo = domain_state-&gt;ephe_info-&gt;live;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(e) == (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/weak.h.html#L74" title="ocaml/runtime/caml/weak.h:74">Ephe_link</a>(e) = domain_state-&gt;ephe_info-&gt;live;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; domain_state-&gt;ephe_info-&gt;live = (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>)<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the todo list is empty, then the ephemeron has no sweeping work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (domain_state-&gt;ephe_info-&gt;todo == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L82" title="ocaml/runtime/major_gc.c:82">num_domains_to_ephe_sweep</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (domain_state-&gt;ephe_info-&gt;todo != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (domain_state-&gt;ephe_info-&gt;must_sweep_ephe == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sweep the ephemeron todo list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_EPHE_SWEEP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (domain_state-&gt;ephe_info-&gt;todo != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (budget = <a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode)) &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> left = <a href="#L1169" title="ocaml/runtime/major_gc.c:1169">ephe_sweep</a> (domain_state, budget);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> work_done = budget - left;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L654" title="ocaml/runtime/major_gc.c:654">commit_major_slice_work</a>(work_done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_EPHE_SWEEP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (domain_state-&gt;ephe_info-&gt;todo == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L82" title="ocaml/runtime/major_gc.c:82">num_domains_to_ephe_sweep</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Complete GC phase */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1394" title="ocaml/runtime/major_gc.c:1394">is_complete_phase_sweep_and_mark_main</a>() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1408" title="ocaml/runtime/major_gc.c:1408">is_complete_phase_mark_final</a> ()) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a> != Phase_sweep_ephe);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (barrier_participants) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1435" title="ocaml/runtime/major_gc.c:1435">try_complete_gc_phase</a> (domain_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>*)<span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; participant_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; barrier_participants);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="domain.c.html#L1496" title="ocaml/runtime/domain.c:1496">caml_try_run_on_all_domains</a> (&amp;<a href="#L1435" title="ocaml/runtime/major_gc.c:1435">try_complete_gc_phase</a>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L638" title="ocaml/runtime/major_gc.c:638">get_major_slice_work</a>(mode) &gt; <span class="Constant">0</span>) <span class="Statement">goto</span> mark_again;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L207" title="ocaml/runtime/caml/misc.h:207">call_timing_hook</a>(&amp;<a href="misc.c.html#L41" title="ocaml/runtime/misc.c:41">caml_major_slice_end_hook</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (log_events) <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_SLICE);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a><br/></li>
<li>&nbsp; &nbsp; (<span class="Constant">&quot;Major slice [</span><span class="Special">%c%c%c</span><span class="Constant">]: </span><span class="Special">%ld</span><span class="Constant"> sweep, </span><span class="Special">%ld</span><span class="Constant"> <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> (</span><span class="Special">%lu</span><span class="Constant"> blocks)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1463" title="ocaml/runtime/major_gc.c:1463">collection_slice_mode_char</a>(mode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="domain.c.html#L300" title="ocaml/runtime/domain.c:300">caml_incoming_interrupts_queued</a>() ? <span class="Constant">'.'</span> : <span class="Constant">'*'</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/major_gc.h.html#L28" title="ocaml/runtime/caml/major_gc.h:28">caml_gc_phase_char</a>(<a href="#L106" title="ocaml/runtime/major_gc.c:106">caml_gc_phase</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span>)sweep_work, (<span class="Type">long</span>)mark_work,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span>)(domain_state-&gt;stat_blocks_marked<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - blocks_marked_before));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (mode != Slice_opportunistic &amp;&amp; <a href="#L1423" title="ocaml/runtime/major_gc.c:1423">is_complete_phase_sweep_ephe</a>()) {<br/></li>
<li>&nbsp; &nbsp; saved_major_cycle = <a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* To handle the case where multiple domains try to finish the major<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; cycle simultaneously, we loop until the current cycle has ended,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; ignoring whether <a href="domain.c.html#L1496" title="ocaml/runtime/domain.c:1496">caml_try_run_on_all_domains</a> succeeds. */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (saved_major_cycle == <a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (barrier_participants) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1192" title="ocaml/runtime/major_gc.c:1192">cycle_all_domains_callback</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (domain_state, (<span class="Type">void</span>*)<span class="Constant">0</span>, participant_count, barrier_participants);<br/></li>
<li>&nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="domain.c.html#L1496" title="ocaml/runtime/domain.c:1496">caml_try_run_on_all_domains</a>(&amp;<a href="#L1192" title="ocaml/runtime/major_gc.c:1192">cycle_all_domains_callback</a>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1697">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_opportunistic_major_collection_slice</span>(<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> howmuch)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L1477" title="ocaml/runtime/major_gc.c:1477">major_collection_slice</a>(howmuch, <span class="Constant">0</span>, <span class="Constant">0</span>, Slice_opportunistic);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1702">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_major_collection_slice</span>(<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> howmuch)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> major_slice_epoch = <a href="caml/camlatomic.h.html#L65" title="ocaml/runtime/caml/camlatomic.h:65">atomic_load</a> (&amp;<a href="minor_gc.c.html#L47" title="ocaml/runtime/minor_gc.c:47">caml_major_slice_epoch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* if this is an auto-triggered GC slice, make it interruptible */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (howmuch == <a href="caml/major_gc.h.html#L44" title="ocaml/runtime/caml/major_gc.h:44">AUTO_TRIGGERED_MAJOR_SLICE</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L1477" title="ocaml/runtime/major_gc.c:1477">major_collection_slice</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/major_gc.h.html#L44" title="ocaml/runtime/caml/major_gc.h:44">AUTO_TRIGGERED_MAJOR_SLICE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Slice_interruptible<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; );<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="domain.c.html#L300" title="ocaml/runtime/domain.c:300">caml_incoming_interrupts_queued</a>()) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Major slice interrupted, rescheduling major slice&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="signals.c.html#L237" title="ocaml/runtime/signals.c:237">caml_request_major_slice</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment">: could make forced API slices interruptible, but would need to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; accounting <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> pass up interrupt */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1477" title="ocaml/runtime/major_gc.c:1477">major_collection_slice</a>(howmuch, <span class="Constant">0</span>, <span class="Constant">0</span>, Slice_uninterruptible);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* Record that this domain has completed a major slice for this minor cycle.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;major_slice_epoch = major_slice_epoch;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1728">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">finish_major_cycle_callback</span> (<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain, <span class="Type">void</span>* arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participating_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>** participating)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> saved_major_cycles = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)arg;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (domain == <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="minor_gc.c.html#L748" title="ocaml/runtime/minor_gc.c:748">caml_empty_minor_heap_no_major_slice_from_stw</a><br/></li>
<li>&nbsp; &nbsp; (domain, (<span class="Type">void</span>*)<span class="Constant">0</span>, participating_count, participating);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_FINISH_CYCLE);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (saved_major_cycles == <a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L1477" title="ocaml/runtime/major_gc.c:1477">major_collection_slice</a>(<span class="Constant">10000000</span>, participating_count, participating,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Slice_uninterruptible);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_FINISH_CYCLE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1746">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_finish_major_cycle</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> saved_major_cycles = <a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">while</span>( saved_major_cycles == <a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a> ) {<br/></li>
<li>&nbsp; &nbsp; <a href="domain.c.html#L1496" title="ocaml/runtime/domain.c:1496">caml_try_run_on_all_domains</a><br/></li>
<li>&nbsp; &nbsp; (&amp;<a href="#L1728" title="ocaml/runtime/major_gc.c:1728">finish_major_cycle_callback</a>, (<span class="Type">void</span>*)<a href="#L78" title="ocaml/runtime/major_gc.c:78">caml_major_cycles_completed</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1756">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_empty_mark_stack</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">while</span> (!<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;marking_done){<br/></li>
<li>&nbsp; &nbsp; <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a>(<span class="Constant">1000</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="domain.c.html#L325" title="ocaml/runtime/domain.c:325">caml_handle_incoming_interrupts</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stat_blocks_marked)<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Finished marking major heap. Marked </span><span class="Special">%u</span><span class="Constant"> blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span>)<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stat_blocks_marked);<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stat_blocks_marked = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1769">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_finish_marking</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;marking_done) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_FINISH_MARKING);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1756" title="ocaml/runtime/major_gc.c:1756">caml_empty_mark_stack</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L786" title="ocaml/runtime/major_gc.c:786">caml_shrink_mark_stack</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stat_major_words += <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;allocated_words;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;allocated_words = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_FINISH_MARKING);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1781">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_finish_sweeping</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;sweeping_done) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L42" title="ocaml/runtime/caml/runtime_events.h:42">CAML_EV_BEGIN</a>(EV_MAJOR_FINISH_SWEEPING);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (!<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;sweeping_done) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="shared_heap.c.html#L546" title="ocaml/runtime/shared_heap.c:546">caml_sweep</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;shared_heap, <span class="Constant">10</span>) &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* just finished sweeping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;sweeping_done == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;sweeping_done = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/platform.h.html#L93" title="ocaml/runtime/caml/platform.h:93">atomic_fetch_add_verify_ge0</a>(&amp;<a href="#L80" title="ocaml/runtime/major_gc.c:80">num_domains_to_sweep</a>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="domain.c.html#L325" title="ocaml/runtime/domain.c:325">caml_handle_incoming_interrupts</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/runtime_events.h.html#L43" title="ocaml/runtime/caml/runtime_events.h:43">CAML_EV_END</a>(EV_MAJOR_FINISH_SWEEPING);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1798">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">int</span> <span class="linkable">add_addr</span>(<span class="Type">struct</span> <a href="caml/addrmap.h.html#L23" title="ocaml/runtime/caml/addrmap.h:23">addrmap</a>* amap, <a href="caml/mlvalues.h.html#L65" title="ocaml/runtime/caml/mlvalues.h:65">value_ptr</a> ptr) {<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> chunk = <a href="#L982" title="ocaml/runtime/major_gc.c:982">ptr_to_chunk</a>(ptr);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> offset = <a href="#L985" title="ocaml/runtime/major_gc.c:985">ptr_to_chunk_offset</a>(ptr);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> flag = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)<span class="Constant">1</span> &lt;&lt; offset;<br/></li>
<li>&nbsp; <span class="Type">int</span> new_entry = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* amap_pos = <a href="addrmap.c.html#L93" title="ocaml/runtime/addrmap.c:93">caml_addrmap_insert_pos</a>(amap, chunk);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (*amap_pos == <a href="caml/addrmap.h.html#L33" title="ocaml/runtime/caml/addrmap.h:33">ADDRMAP_NOT_PRESENT</a>) {<br/></li>
<li>&nbsp; &nbsp; new_entry = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; *amap_pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(ptr == <a href="#L988" title="ocaml/runtime/major_gc.c:988">chunk_and_offset_to_ptr</a>(chunk, offset));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!(*amap_pos &amp; flag)) {<br/></li>
<li>&nbsp; &nbsp; *amap_pos |= flag;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> new_entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1820">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">mark_stack_prune</span>(<span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>* stk)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* Since <a href="caml/addrmap.h.html#L23" title="ocaml/runtime/caml/addrmap.h:23">addrmap</a> is (currently) using open address hashing, we cannot insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; new compressed stack entries into an existing, partially-processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; compressed stack. Thus, we create a new compressed stack <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> insert the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; unprocessed entries of the existing compressed stack into the new one. */<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> old_compressed_entries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/addrmap.h.html#L23" title="ocaml/runtime/caml/addrmap.h:23">addrmap</a> new_compressed_stack = <a href="caml/addrmap.h.html#L28" title="ocaml/runtime/caml/addrmap.h:28">ADDRMAP_INIT</a>;<br/></li>
<li>&nbsp; <a href="caml/addrmap.h.html#L48" title="ocaml/runtime/caml/addrmap.h:48">addrmap_iterator</a> it;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (it = stk-&gt;compressed_stack_iter;<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/addrmap.h.html#L49" title="ocaml/runtime/caml/addrmap.h:49">caml_addrmap_iter_ok</a>(&amp;stk-&gt;compressed_stack, it);<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; it = <a href="caml/addrmap.h.html#L59" title="ocaml/runtime/caml/addrmap.h:59">caml_addrmap_next</a>(&amp;stk-&gt;compressed_stack, it)) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> k = <a href="caml/addrmap.h.html#L71" title="ocaml/runtime/caml/addrmap.h:71">caml_addrmap_iter_key</a>(&amp;stk-&gt;compressed_stack, it);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v = <a href="caml/addrmap.h.html#L78" title="ocaml/runtime/caml/addrmap.h:78">caml_addrmap_iter_value</a>(&amp;stk-&gt;compressed_stack, it);<br/></li>
<li>&nbsp; &nbsp; <a href="addrmap.c.html#L127" title="ocaml/runtime/addrmap.c:127">caml_addrmap_insert</a>(&amp;new_compressed_stack, k, v);<br/></li>
<li>&nbsp; &nbsp; ++old_compressed_entries;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (old_compressed_entries &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Preserved %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d compressed entries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_compressed_entries);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="addrmap.c.html#L85" title="ocaml/runtime/addrmap.c:85">caml_addrmap_clear</a>(&amp;stk-&gt;compressed_stack);<br/></li>
<li>&nbsp; stk-&gt;compressed_stack = new_compressed_stack;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* scan <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> compress entries */<br/></li>
<li></span>&nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> i, new_stk_count = <span class="Constant">0</span>, compressed_entries = <span class="Constant">0</span>, total_words = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i=<span class="Constant">0</span>; i &lt; stk-&gt;count; i++) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a> me = stk-&gt;stack[i];<br/></li>
<li>&nbsp; &nbsp; total_words += me.end - me.start;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (me.end - me.start &gt; <a href="caml/signals.h.html#L54" title="ocaml/runtime/caml/signals.h:54">BITS_PER_WORD</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* keep entry in the stack as more efficient <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> move to front */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; stk-&gt;stack[new_stk_count++] = me;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">while</span>(me.start &lt; me.end) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; compressed_entries += <a href="#L1798" title="ocaml/runtime/major_gc.c:1798">add_addr</a>(&amp;stk-&gt;compressed_stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; me.start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; me.start++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <a href="misc.c.html#L81" title="ocaml/runtime/misc.c:81">caml_gc_log</a>(<span class="Constant">&quot;Compressed %&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack words into &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;%&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d <a href="#L993" title="ocaml/runtime/major_gc.c:993">mark</a> stack entries <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;%&quot;</span><a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;d compressed entries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_words, new_stk_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compressed_entries+old_compressed_entries);<br/></li>
<li><br/></li>
<li>&nbsp; stk-&gt;count = new_stk_count;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(stk-&gt;count &lt; stk-&gt;size);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* setup the compressed stack iterator */<br/></li>
<li></span>&nbsp; stk-&gt;compressed_stack_iter = <a href="caml/addrmap.h.html#L92" title="ocaml/runtime/caml/addrmap.h:92">caml_addrmap_iterator</a>(&amp;stk-&gt;compressed_stack);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1874">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_init_major_gc</span>(<a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* d) {<br/></li>
<li>&nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a> = <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>));<br/></li>
<li>&nbsp; <span class="Statement">if</span>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;stack =<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<a href="#L44" title="ocaml/runtime/major_gc.c:44">MARK_STACK_INIT_SIZE</a> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L64" title="ocaml/runtime/major_gc.c:64">mark_entry</a>));<br/></li>
<li>&nbsp; <span class="Statement">if</span>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;stack == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>);<br/></li>
<li>&nbsp; &nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;size = <a href="#L44" title="ocaml/runtime/major_gc.c:44">MARK_STACK_INIT_SIZE</a>;<br/></li>
<li>&nbsp; <a href="addrmap.c.html#L80" title="ocaml/runtime/addrmap.c:80">caml_addrmap_init</a>(&amp;d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;compressed_stack);<br/></li>
<li>&nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;compressed_stack_iter =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/addrmap.h.html#L92" title="ocaml/runtime/caml/addrmap.h:92">caml_addrmap_iterator</a>(&amp;d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;compressed_stack);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Fresh domains do not need to performing marking <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> sweeping. */<br/></li>
<li></span>&nbsp; d-&gt;sweeping_done = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; d-&gt;marking_done = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Comment">/* Finalisers. Fresh domains participate in updating finalisers. */<br/></li>
<li></span>&nbsp; d-&gt;final_info = <a href="finalise.c.html#L413" title="ocaml/runtime/finalise.c:413">caml_alloc_final_info</a> ();<br/></li>
<li>&nbsp; <span class="Statement">if</span>(d-&gt;final_info == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;stack);<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; d-&gt;ephe_info = <a href="weak.c.html#L37" title="ocaml/runtime/weak.c:37">caml_alloc_ephe_info</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span>(d-&gt;ephe_info == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(d-&gt;final_info);<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;stack);<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>);<br/></li>
<li>&nbsp; &nbsp; d-&gt;final_info = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L83" title="ocaml/runtime/major_gc.c:83">num_domains_to_final_update_first</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <a href="caml/camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(&amp;<a href="#L84" title="ocaml/runtime/major_gc.c:84">num_domains_to_final_update_last</a>, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1917">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_teardown_major_gc</span>(<span class="Type">void</span>) {<br/></li>
<li>&nbsp; <a href="caml/domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* d = <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* account for latest allocations */<br/></li>
<li></span>&nbsp; <a href="#L494" title="ocaml/runtime/major_gc.c:494">update_major_slice_work</a> (<span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(!<a href="caml/addrmap.h.html#L49" title="ocaml/runtime/caml/addrmap.h:49">caml_addrmap_iter_ok</a>(&amp;d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;compressed_stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;compressed_stack_iter));<br/></li>
<li>&nbsp; <a href="addrmap.c.html#L85" title="ocaml/runtime/addrmap.c:85">caml_addrmap_clear</a>(&amp;d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;compressed_stack);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;count == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>-&gt;stack);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a>);<br/></li>
<li>&nbsp; d-&gt;<a href="#L66" title="ocaml/runtime/major_gc.c:66">mark_stack</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1931">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_finalise_heap</span> (<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
