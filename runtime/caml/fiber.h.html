<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/caml/fiber.h - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/caml/fiber.h - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L65">sizeof</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L109">c_stack_link</a></li>
<li><a href="#L31">stack_handler</a></li>
<li><a href="#L43">stack_info</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L20">CAML_FIBER_H</a></li>
<li><a href="#L100">Reserved_space_c_stack_link</a></li>
<li><a href="#L102">Reserved_space_c_stack_link</a></li>
<li><a href="#L66">Stack_base</a></li>
<li><a href="#L73">Stack_handle_effect</a></li>
<li><a href="#L72">Stack_handle_exception</a></li>
<li><a href="#L71">Stack_handle_value</a></li>
<li><a href="#L69">Stack_high</a></li>
<li><a href="#L74">Stack_parent</a></li>
<li><a href="#L67">Stack_threshold_ptr</a></li>
<li><a href="#L243">Trap_link</a></li>
<li><a href="#L242">Trap_pc</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; KC Sivaramakrishnan, Indian Institute of Technology, Madras&nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Tom Kelly, OCaml Labs Consultancy&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Stephen Dolan, University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2021 Indian Institute of Technology, Madras&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2021 OCaml Labs Consultancy&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2019 University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L20" title="ocaml/runtime/caml/fiber.h:20">CAML_FIBER_H</a><br/></li>
<li><a id="L20">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CAML_FIBER_H</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;roots.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L31" title="ocaml/runtime/caml/fiber.h:31">stack_handler</a> describes the state for using fibers as part of effects */<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">stack_handler</span> {<br/></li>
<li>&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> handle_value;<br/></li>
<li>&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> handle_exn;<br/></li>
<li>&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> handle_effect;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* parent; <span class="Comment">/* parent OCaml stack if any */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> describes the OCaml stack. It is used for:<br/></li>
<li></span><span class="Comment"> *&nbsp; - storing information about the OCaml stack allowing it to be switched<br/></li>
<li></span><span class="Comment"> *&nbsp; - accessing the <a href="#L31" title="ocaml/runtime/caml/fiber.h:31">stack_handler</a> for the stack to handle effects<br/></li>
<li></span><span class="Comment"> *&nbsp; - handling a freelist of OCaml stacks in a stack_cache<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L43">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">stack_info</span> {<br/></li>
<li><span class="PreProc">#ifdef NATIVE_CODE<br/></li>
<li></span>&nbsp; <span class="Type">void</span>* sp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stack pointer of the OCaml stack when suspended */<br/></li>
<li></span>&nbsp; <span class="Type">void</span>* exception_ptr; <span class="Comment">/* exception pointer of OCaml stack when suspended */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* sp;<br/></li>
<li>&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* exception_ptr;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="#L31" title="ocaml/runtime/caml/fiber.h:31">stack_handler</a>* handler; <span class="Comment">/* effect handling state for the fiber */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* [cache_bucket] is an index into the [<a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;stack_cache] array if<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * this size is pooled. If unpooled, it is [-1].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * Stacks may be unpooled if either the stack size is not 2**N multiple of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * [<a href="../gc_ctrl.c.html#L42" title="ocaml/runtime/gc_ctrl.c:42">caml_fiber_wsz</a>] <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> the stack is bigger than pooled sizes. */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> cache_bucket;<br/></li>
<li>&nbsp; <span class="Type">size_t</span> size; <span class="Comment">/* only used when USE_MMAP_MAP_STACK is defined */<br/></li>
<li></span>&nbsp; <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> magic;<br/></li>
<li>&nbsp; <span class="Type"><a href="config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> id;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a href="misc.h.html#L222" title="ocaml/runtime/caml/misc.h:222">CAML_STATIC_ASSERT</a>(<span class="Statement"><a href="#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>) ==<br/></li>
<li><a id="L65">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="config.h.html#L209" title="ocaml/runtime/caml/config.h:209">Stack_ctx_words</a> * <span class="Statement"><span class="linkable">sizeof</span></span>(<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>));<br/></li>
<li><a id="L66">&#x200c;</a><span class="PreProc">#define <span class="linkable">Stack_base</span>(stk) ((<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)(stk + </span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Stack_threshold_ptr</span>(stk) \<br/></li>
<li></span><span class="PreProc">&nbsp; (<a href="#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a>(stk) + <a href="config.h.html#L204" title="ocaml/runtime/caml/config.h:204">Stack_threshold</a> / </span><span class="Statement"><a href="#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span><span class="PreProc">(<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>))<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Stack_high</span>(stk) (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>*)stk-&gt;handler<br/></li>
<li></span><br/></li>
<li><a id="L71">&#x200c;</a><span class="PreProc">#define <span class="linkable">Stack_handle_value</span>(stk) (stk)-&gt;handler-&gt;handle_value<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Stack_handle_exception</span>(stk) (stk)-&gt;handler-&gt;handle_exn<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Stack_handle_effect</span>(stk) (stk)-&gt;handler-&gt;handle_effect<br/></li>
<li><a id="L74">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Stack_parent</span>(stk) (stk)-&gt;handler-&gt;parent<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Stack layout for native code. Stack grows downwards.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * +------------------------+<br/></li>
<li></span><span class="Comment"> * |&nbsp; struct <a href="#L31" title="ocaml/runtime/caml/fiber.h:31">stack_handler</a>&nbsp; |<br/></li>
<li></span><span class="Comment"> * +------------------------+ &lt;--- <a href="#L69" title="ocaml/runtime/caml/fiber.h:69">Stack_high</a><br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp; caml_runstack /&nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> * |&nbsp;&nbsp; caml_start_program&nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> * +------------------------+<br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * .&nbsp; &nbsp; &nbsp; OCaml frames&nbsp; &nbsp; &nbsp; . &lt;--- sp<br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * +------------------------+ &lt;--- <a href="config.h.html#L204" title="ocaml/runtime/caml/config.h:204">Stack_threshold</a><br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * .&nbsp; &nbsp; &nbsp; &nbsp; Red Zone&nbsp; &nbsp; &nbsp; &nbsp; .<br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * +------------------------+ &lt;--- <a href="#L66" title="ocaml/runtime/caml/fiber.h:66">Stack_base</a><br/></li>
<li></span><span class="Comment"> * |&nbsp;&nbsp; struct <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>&nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * +------------------------+ &lt;--- <a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;current_stack<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Some ABI reserve space at the bottom of every C stack frame. */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(TARGET_amd64) &amp;&amp; (defined(_WIN32) || defined(__CYGWIN__))<br/></li>
<li></span><span class="Comment">/* Win64 ABI shadow store for argument registers */<br/></li>
<li><a id="L100">&#x200c;</a></span>&nbsp; <span class="PreProc">#define <span class="linkable">Reserved_space_c_stack_link</span> </span><span class="Constant">4</span><span class="PreProc"> * </span><span class="Constant">8<br/></li>
<li></span><span class="PreProc">#elif defined(TARGET_s390x)<br/></li>
<li><a id="L102">&#x200c;</a></span>&nbsp; <span class="PreProc">#define <span class="linkable">Reserved_space_c_stack_link</span> </span><span class="Constant">160<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* This structure is used for storing the OCaml return pointer when<br/></li>
<li></span><span class="Comment"> * transitioning from an OCaml stack to a C stack at a C call. When an OCaml<br/></li>
<li></span><span class="Comment"> * stack is reallocated, this linked list is walked to update the OCaml stack<br/></li>
<li></span><span class="Comment"> * pointers. It is also used for DWARF backtraces. */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">c_stack_link</span> {<br/></li>
<li><span class="PreProc">#if <a href="#L100" title="ocaml/runtime/caml/fiber.h:100">Reserved_space_c_stack_link</a> &gt; </span><span class="Constant">0<br/></li>
<li></span>&nbsp; <span class="Type">char</span> reserved[<a href="#L100" title="ocaml/runtime/caml/fiber.h:100">Reserved_space_c_stack_link</a>];<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Comment">/* The reference to the OCaml stack */<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack;<br/></li>
<li>&nbsp; <span class="Comment">/* OCaml return address */<br/></li>
<li></span>&nbsp; <span class="Type">void</span>* sp;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L109" title="ocaml/runtime/caml/fiber.h:109">c_stack_link</a>* prev;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* `gc_regs` <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> `gc_regs_buckets`.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When entering certain runtime functions, the OCaml runtime saves<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; all registers into a `gc_regs` &quot;bucket&quot;, a <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> array allocated on<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the C heap. This is notably used by the garbage collector to know<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; which registers contain local roots.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; `<a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;gc_regs` points to the bucket currently in use, <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> if no runtime function saving all registers is currently being<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; called.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; `<a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;gc_regs_buckets` is a domain-local cache of buckets<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that are not currently in use. It has a linked list structure<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (the first element of each bucket is a pointer to the next<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; available bucket <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> 0). It is guaranteed to be non-empty, to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; contain at least one free bucket, whenever we are running OCaml<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; code on the domain. This invariant is maintained by calling<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="../fiber.c.html#L292" title="ocaml/runtime/fiber.c:292">caml_maybe_expand_stack</a>] before calling OCaml code from C code,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; which allocates a new bucket if the list is empty.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When OCaml code needs to save all registers, it pops the next<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; bucket from `gc_regs_bucket`. It is pushed back on return.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When C code passes control to an OCaml callback, the current<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; `<a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;gc_regs` <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> is saved to the top of the OCaml stack<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (see the `caml_start_program` logic, which is also used by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; `<a href="../callback.c.html#L291" title="ocaml/runtime/callback.c:291">caml_callback</a>` functions). In general we can thus have several<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; buckets storing registers, one for each nested call to runtime<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; functions saving all registers, with the currently-active one in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; `<a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>` <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the rest at the beginning of each OCaml stack<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; fragment created from C.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Overview of the stack switching primitives for effects<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For an understanding of effect handlers in OCaml please see:<br/></li>
<li></span><span class="Comment"> *&nbsp; Retrofitting Effect Handlers onto OCaml, KC Sivaramakrishnan, et al.<br/></li>
<li></span><span class="Comment"> *&nbsp; PLDI 2021<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; Native code<br/></li>
<li></span><span class="Comment"> *&nbsp; -----------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In native compilation the stack switching primitives Prunstack,<br/></li>
<li></span><span class="Comment"> * Pperform, Preperform <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> Presume make use of corresponding functions<br/></li>
<li></span><span class="Comment"> * implemented in the assembly files for an architecture (such as<br/></li>
<li></span><span class="Comment"> * runtime/amd64.S).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../shared_heap.c.html#L657" title="ocaml/runtime/shared_heap.c:657">A</a> continuation object represents a suspended OCaml stack. It contains<br/></li>
<li></span><span class="Comment"> * the stack pointer tagged as an integer to avoid being followed by the GC.<br/></li>
<li></span><span class="Comment"> * In the code the tagged pointer can be referred to as a 'fiber':<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; fiber := <a href="mlvalues.h.html#L263" title="ocaml/runtime/caml/mlvalues.h:263">Val_ptr</a>(stack)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * caml_runstack new_stack function argument<br/></li>
<li></span><span class="Comment"> *&nbsp; caml_runstack launches a function (with an argument) in a new OCaml<br/></li>
<li></span><span class="Comment"> *&nbsp; stack. It switches execution from the parent OCaml stack to the fresh<br/></li>
<li></span><span class="Comment"> *&nbsp; stack <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> installs an exception handler. On return the new OCaml stack<br/></li>
<li></span><span class="Comment"> *&nbsp; is freed, the stack is restored to the parent OCaml stack <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the<br/></li>
<li></span><span class="Comment"> *&nbsp; handle_value/handle_exn function is executed on the parent OCaml stack.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * caml_perform effect continuation<br/></li>
<li></span><span class="Comment"> *&nbsp; caml_perform captures the current OCaml stack in the continuation object<br/></li>
<li></span><span class="Comment"> *&nbsp; provided <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> raises the effect by switching to the parent OCaml stack <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment"> *&nbsp; then executing the handle_effect function. Should there be no parent OCaml<br/></li>
<li></span><span class="Comment"> *&nbsp; stack then the Effect.Unhandled exception is raised.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * caml_reperform effect continuation last_fiber<br/></li>
<li></span><span class="Comment"> *&nbsp; caml_reperform is used to walk up the parent OCaml stacks to execute the<br/></li>
<li></span><span class="Comment"> *&nbsp; next effect handler installed in the chain. This function is implemented<br/></li>
<li></span><span class="Comment"> *&nbsp; by setting up the required registers then jumping into caml_perform which<br/></li>
<li></span><span class="Comment"> *&nbsp; does the switch to the parent <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> execution of the handle_effect function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * caml_resume new_fiber function argument<br/></li>
<li></span><span class="Comment"> *&nbsp; caml_resume resumes execution on new_fiber by making the current stack<br/></li>
<li></span><span class="Comment"> *&nbsp; the parent of the new_fiber <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> then switching to the stack for new_fiber.<br/></li>
<li></span><span class="Comment"> *&nbsp; The function with argument is then executed on the new stack. Care is taken<br/></li>
<li></span><span class="Comment"> *&nbsp; to check if the new_fiber argument has already been resumed <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> so is null.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; Bytecode<br/></li>
<li></span><span class="Comment"> *&nbsp; --------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In <a href="../meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a> compilation the primitives are mapped to effect <a href="instruct.h.html#L23" title="ocaml/runtime/caml/instruct.h:23">instructions</a> <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment"> * some changes are made to the <a href="../meta.c.html#L53" title="ocaml/runtime/meta.c:53">bytecode</a> interpreter on every function return<br/></li>
<li></span><span class="Comment"> * <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> exception raise. In particular:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; Presume | Prunstack -&gt; RESUME (&amp; RESUMETERM if a tail call)<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; RESUME checks that the stack is valid (a <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> stack indicates a<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; continuation that has already been resumed). The stacks are then switched<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; with the old stack becoming the parent of the new stack. Care is taken<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; to setup the exception handler for the new stack. Execution continues<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; on the new OCaml stack with the passed function <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> argument.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; Pperform -&gt; PERFORM<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; PERFORM captures the current stack in a continuation object it allocates.<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; The parent stack is then switched to <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the handle_effect function for<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; the parent stack is executed. If no parent stack exists then the<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; Effect.Unhandled exception is raised.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; Preperform -&gt; REPERFORMTERM<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; REPERFORMTERM is used to walk up the parent OCaml stacks to execute the<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; next effect handler installed in the chain. The instruction takes care to<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; switch back to the continuation stack to raise the Effect.Unhandled<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; exception in in the case no parent is left. Otherwise the instruction<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; switches to the parent stack <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> executes the handle_effect function for<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; that parent stack.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; Special return handling:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; There is special handling on every function return (see do_return of<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; interp.c). This handling allows the completion of a child stack to be<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; detected. On completion of a child stack, the child stack is freed <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; control returns to the parent stack to execute the handle_value function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; Special exception handling:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; When an exception is raised (see raise_notrace of interp.c), the trap<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; offset is checked. If there are no more exceptions in this stack <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> a<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; parent stack exists, then the child stack is freed <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; handle_exception function is executed on the parent stack.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The table of global identifiers */<br/></li>
<li></span><span class="Type">extern</span> <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="../fiber.c.html#L316" title="ocaml/runtime/fiber.c:316">caml_global_data</a>;<br/></li>
<li><br/></li>
<li><a id="L242">&#x200c;</a><span class="PreProc">#define <span class="linkable">Trap_pc</span>(tp) (((<a href="mlvalues.h.html#L67" title="ocaml/runtime/caml/mlvalues.h:67">code_t</a> *)(tp))[</span><span class="Constant">0</span><span class="PreProc">])<br/></li>
<li><a id="L243">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Trap_link</span>(tp) ((tp)[</span><span class="Constant">1</span><span class="PreProc">])<br/></li>
<li></span><br/></li>
<li><span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>** <a href="../fiber.c.html#L81" title="ocaml/runtime/fiber.c:81">caml_alloc_stack_cache</a> (<span class="Type">void</span>);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* <a href="../fiber.c.html#L550" title="ocaml/runtime/fiber.c:550">caml_alloc_main_stack</a> (<a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> init_wsize);<br/></li>
<li><br/></li>
<li><span class="Type">void</span> <a href="../fiber.c.html#L277" title="ocaml/runtime/fiber.c:277">caml_scan_stack</a>(<br/></li>
<li>&nbsp; <a href="roots.h.html#L28" title="ocaml/runtime/caml/roots.h:28">scanning_action</a> f, <a href="roots.h.html#L26" title="ocaml/runtime/caml/roots.h:26">scanning_action_flags</a> fflags, <span class="Type">void</span>* fdata,<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack, <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>* v_gc_regs);<br/></li>
<li><br/></li>
<li><span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* <a href="../fiber.c.html#L190" title="ocaml/runtime/fiber.c:190">caml_alloc_stack_noexc</a>(<a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> hexn, <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> heff, <span class="Type"><a href="config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> id);<br/></li>
<li><span class="Comment">/* try to grow the stack until at least required_size words are available.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; returns nonzero on success */<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">int</span> <a href="../fiber.c.html#L486" title="ocaml/runtime/fiber.c:486">caml_try_realloc_stack</a> (<a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> required_wsize);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <a href="../fiber.c.html#L51" title="ocaml/runtime/fiber.c:51">caml_get_init_stack_wsize</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">void</span> <a href="../fiber.c.html#L64" title="ocaml/runtime/fiber.c:64">caml_change_max_stack_size</a> (<a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> new_max_wsize);<br/></li>
<li><span class="Type">void</span> <a href="../fiber.c.html#L292" title="ocaml/runtime/fiber.c:292">caml_maybe_expand_stack</a>(<span class="Type">void</span>);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../fiber.c.html#L558" title="ocaml/runtime/fiber.c:558">caml_free_stack</a>(<span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stk);<br/></li>
<li><br/></li>
<li><span class="Comment">/* gc_regs_buckets is allocated on-demand by [maybe_expand_stack]. */<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../fiber.c.html#L585" title="ocaml/runtime/fiber.c:585">caml_free_gc_regs_buckets</a>(<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *gc_regs_buckets);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NATIVE_CODE<br/></li>
<li></span><span class="Type">void</span> <a href="../fiber.c.html#L215" title="ocaml/runtime/fiber.c:215">caml_get_stack_sp_pc</a> (<span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span>** sp <span class="Comment">/* out */</span>, <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>* pc <span class="Comment">/* out */</span>);<br/></li>
<li><span class="Type">void<br/></li>
<li></span><a href="../fiber.c.html#L402" title="ocaml/runtime/fiber.c:402">caml_rewrite_exception_stack</a>(<span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *old_stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>** exn_ptr, <span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a> *new_stack);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="../fiber.c.html#L624" title="ocaml/runtime/fiber.c:624">caml_continuation_use</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Replace the stack of a continuation that was previously removed<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; with <a href="../fiber.c.html#L624" title="ocaml/runtime/fiber.c:624">caml_continuation_use</a>. The GC must not be allowed to run<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; between continuation_use <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> continuation_replace.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Used for cloning continuations <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> continuation backtraces. */<br/></li>
<li></span><span class="Type">void</span> <a href="../fiber.c.html#L651" title="ocaml/runtime/fiber.c:651">caml_continuation_replace</a>(<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> cont, <span class="Type">struct</span> <a href="#L43" title="ocaml/runtime/caml/fiber.h:43">stack_info</a>* stack);<br/></li>
<li><br/></li>
<li><a href="misc.h.html#L90" title="ocaml/runtime/caml/misc.h:90">CAMLnoreturn_start</a><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../fiber.c.html#L685" title="ocaml/runtime/fiber.c:685">caml_raise_continuation_already_resumed</a> (<span class="Type">void</span>)<br/></li>
<li><a href="misc.h.html#L91" title="ocaml/runtime/caml/misc.h:91">CAMLnoreturn_end</a>;<br/></li>
<li><br/></li>
<li><a href="misc.h.html#L90" title="ocaml/runtime/caml/misc.h:90">CAMLnoreturn_start</a><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../fiber.c.html#L705" title="ocaml/runtime/fiber.c:705">caml_raise_unhandled_effect</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> effect)<br/></li>
<li><a href="misc.h.html#L91" title="ocaml/runtime/caml/misc.h:91">CAMLnoreturn_end</a>;<br/></li>
<li><br/></li>
<li><a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="../fiber.c.html#L693" title="ocaml/runtime/fiber.c:693">caml_make_unhandled_effect_exn</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> effect);<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="#L20" title="ocaml/runtime/caml/fiber.h:20">CAML_FIBER_H</a> */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
