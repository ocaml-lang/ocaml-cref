<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/caml/platform.h - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/caml/platform.h - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L147">lockdepth</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L109">caml_plat_cond</a></li>
<li><a href="#L100">caml_plat_mutex</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L93">atomic_fetch_add_verify_ge0</a></li>
<li><a href="#L84">atomic_load_wait_nonzero</a></li>
<li><a href="#L155">caml_plat_lock</a></li>
<li><a href="#L161">caml_plat_try_lock</a></li>
<li><a href="#L173">caml_plat_unlock</a></li>
<li><a href="#L141">check_err</a></li>
<li><a href="#L36">cpu_relax</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L110">CAML_PLAT_COND_INITIALIZER</a></li>
<li><a href="#L101">CAML_PLAT_MUTEX_INITIALIZER</a></li>
<li><a href="#L18">CAML_PLAT_THREADS_H</a></li>
<li><a href="#L148">DEBUG_LOCK</a></li>
<li><a href="#L151">DEBUG_LOCK</a></li>
<li><a href="#L149">DEBUG_UNLOCK</a></li>
<li><a href="#L152">DEBUG_UNLOCK</a></li>
<li><a href="#L73">GENSYM</a></li>
<li><a href="#L72">GENSYM_2</a></li>
<li><a href="#L71">GENSYM_3</a></li>
<li><a href="#L31">MAP_ANONYMOUS</a></li>
<li><a href="#L65">Max_spins</a></li>
<li><a href="#L75">SPIN_WAIT</a></li>
<li><a href="#L54">atomic_load_acquire</a></li>
<li><a href="#L56">atomic_load_relaxed</a></li>
<li><a href="#L60">atomic_store_relaxed</a></li>
<li><a href="#L58">atomic_store_release</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; KC Sivaramakrishnan, Indian Institute of Technology, Madras&nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Stephen Dolan, University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2016 Indian Institute of Technology, Madras&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2016 University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L18" title="ocaml/runtime/caml/platform.h:18">CAML_PLAT_THREADS_H</a><br/></li>
<li><a id="L18">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CAML_PLAT_THREADS_H</span><br/></li>
<li></span><span class="Comment">/* Platform-specific concurrency <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> memory primitives */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;pthread.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;config.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;sys.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(MAP_ANON) &amp;&amp; !defined(<a href="#L31" title="ocaml/runtime/caml/platform.h:31">MAP_ANONYMOUS</a>)<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAP_ANONYMOUS</span> MAP_ANON<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Hint for busy-waiting loops */<br/></li>
<li></span><br/></li>
<li><a id="L36">&#x200c;</a><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">cpu_relax</span>(<span class="Type">void</span>) {<br/></li>
<li><span class="PreProc">#ifdef __GNUC__<br/></li>
<li></span><span class="PreProc">#if defined(__x86_64__) || defined(__i386__)<br/></li>
<li></span>&nbsp; __asm__ <span class="Type">volatile</span>(<span class="Constant">&quot;pause&quot;</span> ::: <span class="Constant">&quot;memory&quot;</span>);<br/></li>
<li><span class="PreProc">#elif defined(__aarch64__)<br/></li>
<li></span>&nbsp; __asm__ <span class="Type">volatile</span> (<span class="Constant">&quot;yield&quot;</span> ::: <span class="Constant">&quot;memory&quot;</span>);<br/></li>
<li><span class="PreProc">#elif defined(__riscv)<br/></li>
<li></span>&nbsp; <span class="Comment">/* Encoding of the pause instruction */<br/></li>
<li></span>&nbsp; __asm__ <span class="Type">volatile</span> (<span class="Constant">&quot;.4byte 0x100000F&quot;</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Comment">/* Just a compiler barrier */<br/></li>
<li></span>&nbsp; __asm__ <span class="Type">volatile</span> (<span class="Constant">&quot;&quot;</span> ::: <span class="Constant">&quot;memory&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Loads <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> stores with acquire, release <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> relaxed semantics */<br/></li>
<li></span><br/></li>
<li><a id="L54">&#x200c;</a><span class="PreProc">#define <span class="linkable">atomic_load_acquire</span>(p)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="camlatomic.h.html#L64" title="ocaml/runtime/caml/camlatomic.h:64">atomic_load_explicit</a>((p), memory_order_acquire)<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">atomic_load_relaxed</span>(p)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="camlatomic.h.html#L64" title="ocaml/runtime/caml/camlatomic.h:64">atomic_load_explicit</a>((p), memory_order_relaxed)<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">atomic_store_release</span>(p, v)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="camlatomic.h.html#L66" title="ocaml/runtime/caml/camlatomic.h:66">atomic_store_explicit</a>((p), (v), memory_order_release)<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">atomic_store_relaxed</span>(p, v)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="camlatomic.h.html#L66" title="ocaml/runtime/caml/camlatomic.h:66">atomic_store_explicit</a>((p), (v), memory_order_relaxed)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Spin-wait loops */<br/></li>
<li></span><br/></li>
<li><a id="L65">&#x200c;</a><span class="PreProc">#define <span class="linkable">Max_spins</span> </span><span class="Constant">1000<br/></li>
<li></span><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">unsigned</span> <a href="../platform.c.html#L227" title="ocaml/runtime/platform.c:227">caml_plat_spin_wait</a>(<span class="Type">unsigned</span> spins,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span>* file, <span class="Type">int</span> line,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span>* function);<br/></li>
<li><br/></li>
<li><a id="L71">&#x200c;</a><span class="PreProc">#define <span class="linkable">GENSYM_3</span>(name, l) name##l<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GENSYM_2</span>(name, l) <a href="#L71" title="ocaml/runtime/caml/platform.h:71">GENSYM_3</a>(name, l)<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GENSYM</span>(name) <a href="#L72" title="ocaml/runtime/caml/platform.h:72">GENSYM_2</a>(name, </span><span class="Constant">__LINE__</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L75">&#x200c;</a><span class="PreProc">#define <span class="linkable">SPIN_WAIT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">unsigned</span><span class="PreProc"> <a href="#L73" title="ocaml/runtime/caml/platform.h:73">GENSYM</a>(caml__spins) = </span><span class="Constant">0</span><span class="PreProc">;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">for</span><span class="PreProc"> (; </span><span class="Constant">1</span><span class="PreProc">; <a href="#L36" title="ocaml/runtime/caml/platform.h:36">cpu_relax</a>(),&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L73" title="ocaml/runtime/caml/platform.h:73">GENSYM</a>(caml__spins) =&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="misc.h.html#L257" title="ocaml/runtime/caml/misc.h:257">CAMLlikely</a>(<a href="#L73" title="ocaml/runtime/caml/platform.h:73">GENSYM</a>(caml__spins) &lt; <a href="#L65" title="ocaml/runtime/caml/platform.h:65">Max_spins</a>) ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L73" title="ocaml/runtime/caml/platform.h:73">GENSYM</a>(caml__spins) + </span><span class="Constant">1</span><span class="PreProc"> :&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../platform.c.html#L227" title="ocaml/runtime/platform.c:227">caml_plat_spin_wait</a>(<a href="#L73" title="ocaml/runtime/caml/platform.h:73">GENSYM</a>(caml__spins),&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Constant">__FILE__</span><span class="PreProc">, </span><span class="Constant">__LINE__</span><span class="PreProc">, </span><span class="Constant">__func__</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><a id="L84">&#x200c;</a><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">atomic_load_wait_nonzero</span>(<a href="camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a>* p) {<br/></li>
<li>&nbsp; <a href="#L75" title="ocaml/runtime/caml/platform.h:75">SPIN_WAIT</a> {<br/></li>
<li>&nbsp; &nbsp; <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> v = <a href="#L54" title="ocaml/runtime/caml/platform.h:54">atomic_load_acquire</a>(p);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (v) <span class="Statement">return</span> v;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Atomic read-modify-write <a href="instruct.h.html#L23" title="ocaml/runtime/caml/instruct.h:23">instructions</a>, with full fences */<br/></li>
<li></span><br/></li>
<li><a id="L93">&#x200c;</a><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">atomic_fetch_add_verify_ge0</span>(<a href="camlatomic.h.html#L32" title="ocaml/runtime/caml/camlatomic.h:32">atomic_uintnat</a>* p, <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> v) {<br/></li>
<li>&nbsp; <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> result = <a href="camlatomic.h.html#L75" title="ocaml/runtime/caml/camlatomic.h:75">atomic_fetch_add</a>(p,v);<br/></li>
<li>&nbsp; <a href="misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> ((<a href="config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>)result &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">typedef</span> pthread_mutex_t <span class="linkable">caml_plat_mutex</span>;<br/></li>
<li><a id="L101">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_PLAT_MUTEX_INITIALIZER</span> PTHREAD_MUTEX_INITIALIZER<br/></li>
<li></span><span class="Type">void</span> <a href="../platform.c.html#L47" title="ocaml/runtime/platform.c:47">caml_plat_mutex_init</a>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>*);<br/></li>
<li><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <a href="#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>*);<br/></li>
<li><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">int</span> <a href="#L161" title="ocaml/runtime/caml/platform.h:161">caml_plat_try_lock</a>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>*);<br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L63" title="ocaml/runtime/platform.c:63">caml_plat_assert_locked</a>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>*);<br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L78" title="ocaml/runtime/platform.c:78">caml_plat_assert_all_locks_unlocked</a>(<span class="Type">void</span>);<br/></li>
<li><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <a href="#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>*);<br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L85" title="ocaml/runtime/platform.c:85">caml_plat_mutex_free</a>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>*);<br/></li>
<li><a id="L109">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> { pthread_cond_t cond; <a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>* mutex; } <span class="linkable">caml_plat_cond</span>;<br/></li>
<li><a id="L110">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_PLAT_COND_INITIALIZER</span>(m) { PTHREAD_COND_INITIALIZER, m }<br/></li>
<li></span><span class="Type">void</span> <a href="../platform.c.html#L103" title="ocaml/runtime/platform.c:103">caml_plat_cond_init</a>(<a href="#L109" title="ocaml/runtime/caml/platform.h:109">caml_plat_cond</a>*, <a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>*);<br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L109" title="ocaml/runtime/platform.c:109">caml_plat_wait</a>(<a href="#L109" title="ocaml/runtime/caml/platform.h:109">caml_plat_cond</a>*);<br/></li>
<li><span class="Comment">/* like <a href="../platform.c.html#L109" title="ocaml/runtime/platform.c:109">caml_plat_wait</a>, but if nanoseconds surpasses the second parameter<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; without a signal, then this function returns 1. */<br/></li>
<li></span><span class="Type">void</span> <a href="../platform.c.html#L115" title="ocaml/runtime/platform.c:115">caml_plat_broadcast</a>(<a href="#L109" title="ocaml/runtime/caml/platform.h:109">caml_plat_cond</a>*);<br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L121" title="ocaml/runtime/platform.c:121">caml_plat_signal</a>(<a href="#L109" title="ocaml/runtime/caml/platform.h:109">caml_plat_cond</a>*);<br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L127" title="ocaml/runtime/platform.c:127">caml_plat_cond_free</a>(<a href="#L109" title="ocaml/runtime/caml/platform.h:109">caml_plat_cond</a>*);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Memory management primitives (mmap) */<br/></li>
<li></span><br/></li>
<li><a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <a href="../platform.c.html#L144" title="ocaml/runtime/platform.c:144">caml_mem_round_up_pages</a>(<a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size);<br/></li>
<li><span class="Comment">/* The size given to <a href="../platform.c.html#L158" title="ocaml/runtime/platform.c:158">caml_mem_map</a> <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> <a href="../platform.c.html#L191" title="ocaml/runtime/platform.c:191">caml_mem_commit</a> must be a multiple of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="../platform.c.html#L141" title="ocaml/runtime/platform.c:141">caml_plat_pagesize</a>. The size given to <a href="../platform.c.html#L208" title="ocaml/runtime/platform.c:208">caml_mem_unmap</a> <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> <a href="../platform.c.html#L199" title="ocaml/runtime/platform.c:199">caml_mem_decommit</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; must match the size given to <a href="../platform.c.html#L158" title="ocaml/runtime/platform.c:158">caml_mem_map</a>/<a href="../platform.c.html#L191" title="ocaml/runtime/platform.c:191">caml_mem_commit</a> for mem.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The Windows <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> Cygwin implementations do not support arbitrary alignment<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> will fail for alignment values greater than <a href="../platform.c.html#L142" title="ocaml/runtime/platform.c:142">caml_plat_mmap_alignment</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Luckily, this <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> is rather large on those platforms: 64KiB. This is enough<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for all alignments used in the runtime system so far, the larger being the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; major heap pools aligned on 32KiB boundaries. */<br/></li>
<li></span><span class="Type">void</span>* <a href="../platform.c.html#L158" title="ocaml/runtime/platform.c:158">caml_mem_map</a>(<a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size, <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> alignment, <span class="Type">int</span> reserve_only);<br/></li>
<li><span class="Type">void</span>* <a href="../platform.c.html#L191" title="ocaml/runtime/platform.c:191">caml_mem_commit</a>(<span class="Type">void</span>* mem, <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size);<br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L199" title="ocaml/runtime/platform.c:199">caml_mem_decommit</a>(<span class="Type">void</span>* mem, <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size);<br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L208" title="ocaml/runtime/platform.c:208">caml_mem_unmap</a>(<span class="Type">void</span>* mem, <a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size);<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="misc.h.html#L90" title="ocaml/runtime/caml/misc.h:90">CAMLnoreturn_start</a><br/></li>
<li><span class="Type">void</span> <a href="../platform.c.html#L38" title="ocaml/runtime/platform.c:38">caml_plat_fatal_error</a>(<span class="Type">const</span> <span class="Type">char</span> * action, <span class="Type">int</span> err)<br/></li>
<li><a href="misc.h.html#L91" title="ocaml/runtime/caml/misc.h:91">CAMLnoreturn_end</a>;<br/></li>
<li><br/></li>
<li><a id="L141">&#x200c;</a><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">check_err</span>(<span class="Type">const</span> <span class="Type">char</span>* action, <span class="Type">int</span> err)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (err) <a href="../platform.c.html#L38" title="ocaml/runtime/platform.c:38">caml_plat_fatal_error</a>(action, err);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="Type">static</span> __thread <span class="Type">int</span> <span class="linkable">lockdepth</span>;<br/></li>
<li><a id="L148">&#x200c;</a><span class="PreProc">#define <span class="linkable">DEBUG_LOCK</span>(m) (<a href="#L147" title="ocaml/runtime/caml/platform.h:147">lockdepth</a>++)<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEBUG_UNLOCK</span>(m) (<a href="#L147" title="ocaml/runtime/caml/platform.h:147">lockdepth</a>--)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L151">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEBUG_LOCK</span>(m)<br/></li>
<li><a id="L152">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEBUG_UNLOCK</span>(m)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L155">&#x200c;</a><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">caml_plat_lock</span>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>* m)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L141" title="ocaml/runtime/caml/platform.h:141">check_err</a>(<span class="Constant">&quot;lock&quot;</span>, pthread_mutex_lock(m));<br/></li>
<li>&nbsp; <a href="#L148" title="ocaml/runtime/caml/platform.h:148">DEBUG_LOCK</a>(m);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L161">&#x200c;</a><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">int</span> <span class="linkable">caml_plat_try_lock</span>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>* m)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> r = pthread_mutex_trylock(m);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (r == <span class="Constant">EBUSY</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="#L141" title="ocaml/runtime/caml/platform.h:141">check_err</a>(<span class="Constant">&quot;try_lock&quot;</span>, r);<br/></li>
<li>&nbsp; &nbsp; <a href="#L148" title="ocaml/runtime/caml/platform.h:148">DEBUG_LOCK</a>(m);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L173">&#x200c;</a><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">caml_plat_unlock</span>(<a href="#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a>* m)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L149" title="ocaml/runtime/caml/platform.h:149">DEBUG_UNLOCK</a>(m);<br/></li>
<li>&nbsp; <a href="#L141" title="ocaml/runtime/caml/platform.h:141">check_err</a>(<span class="Constant">&quot;unlock&quot;</span>, pthread_mutex_unlock(m));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">extern</span> <a href="config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <a href="../platform.c.html#L141" title="ocaml/runtime/platform.c:141">caml_plat_pagesize</a>;<br/></li>
<li><span class="Type">extern</span> <a href="config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <a href="../platform.c.html#L142" title="ocaml/runtime/platform.c:142">caml_plat_mmap_alignment</a>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* CAML_PLATFORM_H */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
