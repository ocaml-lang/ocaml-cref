<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/caml/memory.h - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/caml/memory.h - ocaml</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L222">caml__roots_block</a></li>
<li><a href="#L190">caml_alloc_small_flags</a></li>
<li><a href="#L63">caml_stat_block</a></li>
<li><a href="#L141">caml_stat_string</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L180">DEBUG_clear</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L217">Alloc_small</a></li>
<li><a href="#L199">Alloc_small_enter_GC</a></li>
<li><a href="#L195">Alloc_small_enter_GC_flags</a></li>
<li><a href="#L202">Alloc_small_with_reserved</a></li>
<li><a href="#L451">Begin_root</a></li>
<li><a href="#L453">Begin_roots1</a></li>
<li><a href="#L462">Begin_roots2</a></li>
<li><a href="#L472">Begin_roots3</a></li>
<li><a href="#L483">Begin_roots4</a></li>
<li><a href="#L495">Begin_roots5</a></li>
<li><a href="#L508">Begin_roots_block</a></li>
<li><a href="#L229">CAML_LOCAL_ROOTS</a></li>
<li><a href="#L19">CAML_MEMORY_H</a></li>
<li><a href="#L404">CAMLdrop</a></li>
<li><a href="#L376">CAMLlocal1</a></li>
<li><a href="#L380">CAMLlocal2</a></li>
<li><a href="#L384">CAMLlocal3</a></li>
<li><a href="#L388">CAMLlocal4</a></li>
<li><a href="#L392">CAMLlocal5</a></li>
<li><a href="#L396">CAMLlocalN</a></li>
<li><a href="#L421">CAMLnoreturn</a></li>
<li><a href="#L270">CAMLparam0</a></li>
<li><a href="#L276">CAMLparam1</a></li>
<li><a href="#L280">CAMLparam2</a></li>
<li><a href="#L284">CAMLparam3</a></li>
<li><a href="#L288">CAMLparam4</a></li>
<li><a href="#L292">CAMLparam5</a></li>
<li><a href="#L296">CAMLparamN</a></li>
<li><a href="#L419">CAMLreturn</a></li>
<li><a href="#L408">CAMLreturn0</a></li>
<li><a href="#L413">CAMLreturnT</a></li>
<li><a href="#L300">CAMLxparam1</a></li>
<li><a href="#L311">CAMLxparam2</a></li>
<li><a href="#L323">CAMLxparam3</a></li>
<li><a href="#L336">CAMLxparam4</a></li>
<li><a href="#L350">CAMLxparam5</a></li>
<li><a href="#L365">CAMLxparamN</a></li>
<li><a href="#L187">DEBUG_clear</a></li>
<li><a href="#L234">DO_CHECK_CAML_STATE</a></li>
<li><a href="#L236">DO_CHECK_CAML_STATE</a></li>
<li><a href="#L517">End_roots</a></li>
<li><a href="#L174">Heap_page_size</a></li>
<li><a href="#L175">Round_mmap_size</a></li>
<li><a href="#L425">Store_field</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Damien Doligez, projet Para, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Allocation macros <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> functions */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L19" title="ocaml/runtime/caml/memory.h:19">CAML_MEMORY_H</a><br/></li>
<li><a id="L19">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CAML_MEMORY_H</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;config.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;major_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;minor_gc.h&quot;<br/></li>
<li></span><span class="PreProc">#endif</span> <span class="Comment">/* <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;domain.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;signals.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef __cplusplus<br/></li>
<li></span><span class="Type">extern</span> <span class="Constant">&quot;C&quot;</span> {<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="../memory.c.html#L359" title="ocaml/runtime/memory.c:359">caml_alloc_shr</a> (<a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <a href="mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a>);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="../memory.c.html#L372" title="ocaml/runtime/memory.c:372">caml_alloc_shr_noexc</a>(<a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize, <a href="mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a>);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="../memory.c.html#L364" title="ocaml/runtime/memory.c:364">caml_alloc_shr_reserved</a> (<a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a>, <a href="mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a>, <a href="mlvalues.h.html#L59" title="ocaml/runtime/caml/mlvalues.h:59">reserved_t</a>);<br/></li>
<li><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../memory.c.html#L190" title="ocaml/runtime/memory.c:190">caml_adjust_gc_speed</a> (<a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a>, <a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a>);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../memory.c.html#L167" title="ocaml/runtime/memory.c:167">caml_alloc_dependent_memory</a> (<a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> bsz);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../memory.c.html#L173" title="ocaml/runtime/memory.c:173">caml_free_dependent_memory</a> (<a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> bsz);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../memory.c.html#L149" title="ocaml/runtime/memory.c:149">caml_modify</a> (<span class="Type">volatile</span> <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *, <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../memory.c.html#L207" title="ocaml/runtime/memory.c:207">caml_initialize</a> (<span class="Type">volatile</span> <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *, <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">int</span> <a href="../memory.c.html#L220" title="ocaml/runtime/memory.c:220">caml_atomic_cas_field</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>, <a href="config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>, <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>, <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <a href="../minor_gc.c.html#L866" title="ocaml/runtime/minor_gc.c:866">caml_check_urgent_gc</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>);<br/></li>
<li><span class="PreProc">#ifdef <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a><br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">char</span> *caml_alloc_for_heap (<a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a> request);&nbsp;&nbsp; <span class="Comment">/* Size in bytes. */<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> caml_free_for_heap (<span class="Type">char</span> *mem);<br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">int</span> caml_add_to_heap (<span class="Type">char</span> *mem);<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* [caml_stat_*] functions below provide an interface to the static memory<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; manager built into the runtime, which can be used for managing static<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (that is, non-moving) blocks of heap memory.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Function arguments that have type [<a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a>] must always be pointers<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to blocks returned by the [caml_stat_*] functions below. Attempting to use<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; these functions on memory blocks allocated by a different memory manager<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (e.g. the one from the C runtime) will cause undefined behaviour.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">void</span>* <span class="linkable">caml_stat_block</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The <a href="../memory.c.html#L425" title="ocaml/runtime/memory.c:425">pool</a> must be initialized with a call to [<a href="../memory.c.html#L464" title="ocaml/runtime/memory.c:464">caml_stat_create_pool</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; before it is possible to use any of the [caml_stat_*] functions below.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If the <a href="../memory.c.html#L425" title="ocaml/runtime/memory.c:425">pool</a> is not initialized, [caml_stat_*] functions will still work in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; backward compatibility mode, becoming thin wrappers around [malloc] family<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of functions. In this case, calling [<a href="../memory.c.html#L478" title="ocaml/runtime/memory.c:478">caml_stat_destroy_pool</a>] will not free<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the claimed heap memory, resulting in leaks.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../memory.c.html#L464" title="ocaml/runtime/memory.c:464">caml_stat_create_pool</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L478" title="ocaml/runtime/memory.c:478">caml_stat_destroy_pool</a>] frees all the heap memory claimed by the <a href="../memory.c.html#L425" title="ocaml/runtime/memory.c:425">pool</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Once the <a href="../memory.c.html#L425" title="ocaml/runtime/memory.c:425">pool</a> is destroyed, [caml_stat_*] functions will continue to work<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in backward compatibility mode, becoming thin wrappers around [malloc]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; family of functions.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../memory.c.html#L478" title="ocaml/runtime/memory.c:478">caml_stat_destroy_pool</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(size)] allocates a memory block of the requested [size]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (in bytes) <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> returns a pointer to it. It throws an OCaml exception in case<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the request fails, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> so requires the runtime lock to be held.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="../memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(size)] allocates a memory block of the requested<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [size] (in bytes) <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> returns a pointer to it, <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> in case the request<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; fails.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="../memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L539" title="ocaml/runtime/memory.c:539">caml_stat_alloc_aligned</a>(size, modulo, block*)] allocates a memory block of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the requested [size] (in bytes), the starting address of which is aligned to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the provided [modulo] <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>. The function returns the aligned address, as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; well as the unaligned [block] (as an output parameter). It throws an OCaml<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; exception in case the request fails, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> so requires the runtime lock.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span>* <a href="../memory.c.html#L539" title="ocaml/runtime/memory.c:539">caml_stat_alloc_aligned</a>(<a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a>, <span class="Type">int</span> modulo, <a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a>*);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L512" title="ocaml/runtime/memory.c:512">caml_stat_alloc_aligned_noexc</a>] is a variant of [<a href="../memory.c.html#L539" title="ocaml/runtime/memory.c:539">caml_stat_alloc_aligned</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that returns <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> in case the request fails, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> doesn't require the runtime<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; lock to be held.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span>* <a href="../memory.c.html#L512" title="ocaml/runtime/memory.c:512">caml_stat_alloc_aligned_noexc</a>(<a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a>, <span class="Type">int</span> modulo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a>*);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L609" title="ocaml/runtime/memory.c:609">caml_stat_calloc_noexc</a>(num, size)] allocates a block of memory for an array<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of [num] elements, each of them [size] bytes long, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> initializes all its<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; bits to zero, effectively allocating a zero-initialized memory block of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [num * size] bytes. It returns <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> in case the request fails.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="../memory.c.html#L609" title="ocaml/runtime/memory.c:609">caml_stat_calloc_noexc</a>(<a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a>, <a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(block)] deallocates the provided [block]. */<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(<a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L600" title="ocaml/runtime/memory.c:600">caml_stat_resize</a>(block, size)] changes the size of the provided [block] to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [size] bytes. The function may move the memory block to a new location (whose<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; address is returned by the function). The content of the [block] is preserved<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; up to the smaller of the new <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> old sizes, even if the block is moved to a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; new location. If the new size is larger, the <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> of the newly allocated<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; portion is indeterminate. The function throws an OCaml exception in case the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; request fails, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> so requires the runtime lock to be held.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="../memory.c.html#L600" title="ocaml/runtime/memory.c:600">caml_stat_resize</a>(<a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a>, <a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L573" title="ocaml/runtime/memory.c:573">caml_stat_resize_noexc</a>] is a variant of [<a href="../memory.c.html#L600" title="ocaml/runtime/memory.c:600">caml_stat_resize</a>] that returns <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in case the request fails, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> doesn't require the runtime lock.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a> <a href="../memory.c.html#L573" title="ocaml/runtime/memory.c:573">caml_stat_resize_noexc</a>(<a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a>, <a href="misc.h.html#L68" title="ocaml/runtime/caml/misc.h:68">asize_t</a>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../shared_heap.c.html#L657" title="ocaml/runtime/shared_heap.c:657">A</a> [<a href="#L63" title="ocaml/runtime/caml/memory.h:63">caml_stat_block</a>] containing a <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a>-terminated string */<br/></li>
<li><a id="L141">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">char</span>* <span class="linkable">caml_stat_string</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>(s)] returns a pointer to a heap-allocated string which is a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; copy of the <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a>-terminated string [s]. It throws an OCaml exception in case<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the request fails, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> so requires the runtime lock to be held.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <a href="../memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>(<span class="Type">const</span> <span class="Type">char</span> *s);<br/></li>
<li><span class="PreProc">#ifdef _WIN32<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">wchar_t</span>* <a href="../memory.c.html#L642" title="ocaml/runtime/memory.c:642">caml_stat_wcsdup</a>(<span class="Type">const</span> <span class="Type">wchar_t</span> *s);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L622" title="ocaml/runtime/memory.c:622">caml_stat_strdup_noexc</a>] is a variant of [<a href="../memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>] that returns <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in case the request fails, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> doesn't require the runtime lock.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <a href="../memory.c.html#L622" title="ocaml/runtime/memory.c:622">caml_stat_strdup_noexc</a>(<span class="Type">const</span> <span class="Type">char</span> *s);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../memory.c.html#L654" title="ocaml/runtime/memory.c:654">caml_stat_strconcat</a>(nargs, strings)] concatenates <a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a>-terminated [strings]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (an array of [char*] of size [nargs]) into a new string, dropping all NULLs,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; except for the very last one. It throws an OCaml exception in case the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; request fails, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> so requires the runtime lock to be held.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <a href="#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <a href="../memory.c.html#L654" title="ocaml/runtime/memory.c:654">caml_stat_strconcat</a>(<span class="Type">int</span> n, ...);<br/></li>
<li><span class="PreProc">#ifdef _WIN32<br/></li>
<li></span><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">wchar_t</span>* <a href="../memory.c.html#L686" title="ocaml/runtime/memory.c:686">caml_stat_wcsconcat</a>(<span class="Type">int</span> n, ...);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* void caml_shrink_heap (char *);&nbsp; &nbsp; &nbsp; &nbsp; Only used in compact.c */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef HAS_HUGE_PAGES<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;<br/></li>
<li><a id="L174">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Heap_page_size</span> HUGE_PAGE_SIZE<br/></li>
<li><a id="L175">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Round_mmap_size</span>(x)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((x) + (<a href="#L174" title="ocaml/runtime/caml/memory.h:174">Heap_page_size</a> - </span><span class="Constant">1</span><span class="PreProc">)) &amp; ~ (<a href="#L174" title="ocaml/runtime/caml/memory.h:174">Heap_page_size</a> - </span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef DEBUG<br/></li>
<li><a id="L180">&#x200c;</a></span><a href="config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">void</span> <span class="linkable">DEBUG_clear</span>(<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> result, <a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> wosize) {<br/></li>
<li>&nbsp; <span class="Statement">for</span> (<a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> i=<span class="Constant">0</span>; i&lt;wosize; ++i) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, i) == <a href="misc.h.html#L529" title="ocaml/runtime/caml/misc.h:529">Debug_free_minor</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a>(result, i) = <a href="misc.h.html#L534" title="ocaml/runtime/caml/misc.h:534">Debug_uninit_minor</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#else<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEBUG_clear</span>(result, wosize)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L190">&#x200c;</a><span class="Type">enum</span> <span class="linkable">caml_alloc_small_flags</span> {<br/></li>
<li>&nbsp; CAML_DONT_TRACK = <span class="Constant">0</span>, CAML_DO_TRACK = <span class="Constant">1</span>, <span class="Comment">// call memprof<br/></li>
<li></span>&nbsp; CAML_FROM_C = <span class="Constant">0</span>,&nbsp; &nbsp;&nbsp; CAML_FROM_CAML = <span class="Constant">2</span> <span class="Comment">// call async callbacks<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L195">&#x200c;</a><span class="PreProc">#define <span class="linkable">Alloc_small_enter_GC_flags</span>(flags, dom_st, wosize) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="../minor_gc.c.html#L801" title="ocaml/runtime/minor_gc.c:801">caml_alloc_small_dispatch</a>((dom_st), (wosize), (flags), </span><span class="Constant">1</span><span class="PreProc">, </span><span class="Constant"><a href="misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span><span class="PreProc">);<br/></li>
<li></span><br/></li>
<li><span class="Comment">// Do not call asynchronous callbacks from allocation functions<br/></li>
<li><a id="L199">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Alloc_small_enter_GC</span>(dom_st, wosize)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L195" title="ocaml/runtime/caml/memory.h:195">Alloc_small_enter_GC_flags</a>(CAML_DO_TRACK | CAML_FROM_C, dom_st, wosize)<br/></li>
<li></span><br/></li>
<li><a id="L202">&#x200c;</a><span class="PreProc">#define <span class="linkable">Alloc_small_with_reserved</span>(result, wosize, tag, GC, reserved) </span><span class="Statement">do</span><span class="PreProc">{&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> ((wosize) &gt;= </span><span class="Constant">1</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> ((<a href="mlvalues.h.html#L61" title="ocaml/runtime/caml/mlvalues.h:61">tag_t</a>) (tag) &lt; </span><span class="Constant">256</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> ((wosize) &lt;= <a href="config.h.html#L221" title="ocaml/runtime/caml/config.h:221">Max_young_wosize</a>); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* dom_st = <a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; dom_st-&gt;young_ptr -=&nbsp; <a href="mlvalues.h.html#L178" title="ocaml/runtime/caml/mlvalues.h:178">Whsize_wosize</a>(wosize);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">if</span><span class="PreProc"> (<a href="domain.h.html#L54" title="ocaml/runtime/caml/domain.h:54">Caml_check_gc_interrupt</a>(dom_st)) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; GC(dom_st, wosize);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L162" title="ocaml/runtime/caml/mlvalues.h:162">Hd_hp</a> (dom_st-&gt;young_ptr) =&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="gc.h.html#L24" title="ocaml/runtime/caml/gc.h:24">Make_header_with_reserved</a>((wosize), (tag), </span><span class="Constant">0</span><span class="PreProc">, (reserved));&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; (result) = <a href="mlvalues.h.html#L167" title="ocaml/runtime/caml/mlvalues.h:167">Val_hp</a> (dom_st-&gt;young_ptr);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L180" title="ocaml/runtime/caml/memory.h:180">DEBUG_clear</a> ((result), (wosize));&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">}</span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L217">&#x200c;</a><span class="PreProc">#define <span class="linkable">Alloc_small</span>(result, wosize, tag, GC) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L202" title="ocaml/runtime/caml/memory.h:202">Alloc_small_with_reserved</a>(result, wosize, tag, GC, (<a href="config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>)</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a> */<br/></li>
<li></span><br/></li>
<li><a id="L222">&#x200c;</a><span class="Type">struct</span> <span class="linkable">caml__roots_block</span> {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> *next;<br/></li>
<li>&nbsp; <a href="config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> ntables;<br/></li>
<li>&nbsp; <a href="config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> nitems;<br/></li>
<li>&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *tables [<span class="Constant">5</span>];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L229">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_LOCAL_ROOTS</span> (<a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;local_roots)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Emit a call to `<a href="domain_state.h.html#L72" title="ocaml/runtime/caml/domain_state.h:72">Caml_check_caml_state</a>`, but only for user<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; programs. */<br/></li>
<li></span><span class="PreProc">#ifdef <a href="../instrtrace.c.html#L16" title="ocaml/runtime/instrtrace.c:16">CAML_INTERNALS</a><br/></li>
<li><a id="L234">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DO_CHECK_CAML_STATE</span> </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DO_CHECK_CAML_STATE</span> </span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The following macros are used to declare C local variables <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function parameters of type [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The function body must start with one of the [CAMLparam] macros.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If the function has no parameter of type [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>], use [<a href="#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If the function has 1 to 5 [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>] parameters, use the corresponding<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [CAMLparam] with the parameters as arguments.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If the function has more than 5 [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>] parameters, use [<a href="#L292" title="ocaml/runtime/caml/memory.h:292">CAMLparam5</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for the first 5 parameters, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> one <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> more calls to the [CAMLxparam]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; macros for the others.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If the function takes an array of [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>]s as argument, use<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L296" title="ocaml/runtime/caml/memory.h:296">CAMLparamN</a>] to declare it (<a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> [<a href="#L365" title="ocaml/runtime/caml/memory.h:365">CAMLxparamN</a>] if you already have a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; call to [CAMLparam] for some other arguments).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If you need local variables of type [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>], declare them with one<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> more calls to the [CAMLlocal] macros at the beginning of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function, after the call to CAMLparam.&nbsp; Use [<a href="#L396" title="ocaml/runtime/caml/memory.h:396">CAMLlocalN</a>] (at the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; beginning of the function) to declare an array of [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>]s.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Your function may raise an exception <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> return a [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>] with the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>] macro.&nbsp; Its argument is simply the [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>] returned by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; your function.&nbsp; Do NOT directly return a [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>] with the [return]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; keyword.&nbsp; If your function returns void, use [<a href="#L408" title="ocaml/runtime/caml/memory.h:408">CAMLreturn0</a>]. If you<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; un-register the local roots (i.e. undo the effects of the [CAMLparam*]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [CAMLlocal] macros) without returning immediately, use [<a href="#L404" title="ocaml/runtime/caml/memory.h:404">CAMLdrop</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; All the identifiers beginning with &quot;caml__&quot; are reserved by OCaml.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Do not use them for anything (local <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> global variables, struct <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; union tags, macros, etc.)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L270">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLparam0</span>()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>** caml_local_roots_ptr =&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L234" title="ocaml/runtime/caml/memory.h:234">DO_CHECK_CAML_STATE</a> ? <a href="domain_state.h.html#L72" title="ocaml/runtime/caml/domain_state.h:72">Caml_check_caml_state</a>() : (</span><span class="Type">void</span><span class="PreProc">)</span><span class="Constant">0</span><span class="PreProc">,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; &amp;<a href="#L229" title="ocaml/runtime/caml/memory.h:229">CAML_LOCAL_ROOTS</a>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> *caml__frame = *caml_local_roots_ptr<br/></li>
<li></span><br/></li>
<li><a id="L276">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLparam1</span>(x) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a> (); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L300" title="ocaml/runtime/caml/memory.h:300">CAMLxparam1</a> (x)<br/></li>
<li></span><br/></li>
<li><a id="L280">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLparam2</span>(x, y) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a> (); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L311" title="ocaml/runtime/caml/memory.h:311">CAMLxparam2</a> (x, y)<br/></li>
<li></span><br/></li>
<li><a id="L284">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLparam3</span>(x, y, z) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a> (); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L323" title="ocaml/runtime/caml/memory.h:323">CAMLxparam3</a> (x, y, z)<br/></li>
<li></span><br/></li>
<li><a id="L288">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLparam4</span>(x, y, z, t) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a> (); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L336" title="ocaml/runtime/caml/memory.h:336">CAMLxparam4</a> (x, y, z, t)<br/></li>
<li></span><br/></li>
<li><a id="L292">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLparam5</span>(x, y, z, t, u) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a> (); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L350" title="ocaml/runtime/caml/memory.h:350">CAMLxparam5</a> (x, y, z, t, u)<br/></li>
<li></span><br/></li>
<li><a id="L296">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLparamN</span>(x, size) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a> (); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L365" title="ocaml/runtime/caml/memory.h:365">CAMLxparamN</a> (x, (size))<br/></li>
<li></span><br/></li>
<li><a id="L300">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLxparam1</span>(x) \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> caml__roots_##x; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L171" title="ocaml/runtime/caml/misc.h:171">CAMLunused_start</a> </span><span class="Type">int</span><span class="PreProc"> caml__dummy_##x = ( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.next = *caml_local_roots_ptr), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (*caml_local_roots_ptr = &amp;caml__roots_##x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.nitems = </span><span class="Constant">1</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.ntables = </span><span class="Constant">1</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">0</span><span class="PreProc">] = &amp;x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp;&nbsp; <a href="misc.h.html#L172" title="ocaml/runtime/caml/misc.h:172">CAMLunused_end</a><br/></li>
<li></span><br/></li>
<li><a id="L311">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLxparam2</span>(x, y) \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> caml__roots_##x; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L171" title="ocaml/runtime/caml/misc.h:171">CAMLunused_start</a> </span><span class="Type">int</span><span class="PreProc"> caml__dummy_##x = ( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.next = *caml_local_roots_ptr), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (*caml_local_roots_ptr = &amp;caml__roots_##x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.nitems = </span><span class="Constant">1</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.ntables = </span><span class="Constant">2</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">0</span><span class="PreProc">] = &amp;x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">1</span><span class="PreProc">] = &amp;y), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp;&nbsp; <a href="misc.h.html#L172" title="ocaml/runtime/caml/misc.h:172">CAMLunused_end</a><br/></li>
<li></span><br/></li>
<li><a id="L323">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLxparam3</span>(x, y, z) \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> caml__roots_##x; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L171" title="ocaml/runtime/caml/misc.h:171">CAMLunused_start</a> </span><span class="Type">int</span><span class="PreProc"> caml__dummy_##x = ( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.next = *caml_local_roots_ptr), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (*caml_local_roots_ptr = &amp;caml__roots_##x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.nitems = </span><span class="Constant">1</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.ntables = </span><span class="Constant">3</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">0</span><span class="PreProc">] = &amp;x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">1</span><span class="PreProc">] = &amp;y), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">2</span><span class="PreProc">] = &amp;z), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L172" title="ocaml/runtime/caml/misc.h:172">CAMLunused_end</a><br/></li>
<li></span><br/></li>
<li><a id="L336">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLxparam4</span>(x, y, z, t) \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> caml__roots_##x; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L171" title="ocaml/runtime/caml/misc.h:171">CAMLunused_start</a> </span><span class="Type">int</span><span class="PreProc"> caml__dummy_##x = ( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.next = *caml_local_roots_ptr), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (*caml_local_roots_ptr = &amp;caml__roots_##x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.nitems = </span><span class="Constant">1</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.ntables = </span><span class="Constant">4</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">0</span><span class="PreProc">] = &amp;x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">1</span><span class="PreProc">] = &amp;y), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">2</span><span class="PreProc">] = &amp;z), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">3</span><span class="PreProc">] = &amp;t), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L172" title="ocaml/runtime/caml/misc.h:172">CAMLunused_end</a><br/></li>
<li></span><br/></li>
<li><a id="L350">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLxparam5</span>(x, y, z, t, u) \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> caml__roots_##x; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L171" title="ocaml/runtime/caml/misc.h:171">CAMLunused_start</a> </span><span class="Type">int</span><span class="PreProc"> caml__dummy_##x = ( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.next = *caml_local_roots_ptr), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (*caml_local_roots_ptr = &amp;caml__roots_##x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.nitems = </span><span class="Constant">1</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.ntables = </span><span class="Constant">5</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">0</span><span class="PreProc">] = &amp;x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">1</span><span class="PreProc">] = &amp;y), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">2</span><span class="PreProc">] = &amp;z), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">3</span><span class="PreProc">] = &amp;t), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables [</span><span class="Constant">4</span><span class="PreProc">] = &amp;u), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L172" title="ocaml/runtime/caml/misc.h:172">CAMLunused_end</a><br/></li>
<li></span><br/></li>
<li><a id="L365">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLxparamN</span>(x, size) \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> caml__roots_##x; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L171" title="ocaml/runtime/caml/misc.h:171">CAMLunused_start</a> </span><span class="Type">int</span><span class="PreProc"> caml__dummy_##x = ( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.next = *caml_local_roots_ptr), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (*caml_local_roots_ptr = &amp;caml__roots_##x), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.nitems = (size)), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.ntables = </span><span class="Constant">1</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (caml__roots_##x.tables[</span><span class="Constant">0</span><span class="PreProc">] = &amp;(x[</span><span class="Constant">0</span><span class="PreProc">])), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="misc.h.html#L172" title="ocaml/runtime/caml/misc.h:172">CAMLunused_end</a><br/></li>
<li></span><br/></li>
<li><a id="L376">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLlocal1</span>(x) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> x = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L300" title="ocaml/runtime/caml/memory.h:300">CAMLxparam1</a> (x)<br/></li>
<li></span><br/></li>
<li><a id="L380">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLlocal2</span>(x, y) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> x = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, y = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L311" title="ocaml/runtime/caml/memory.h:311">CAMLxparam2</a> (x, y)<br/></li>
<li></span><br/></li>
<li><a id="L384">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLlocal3</span>(x, y, z) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> x = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, y = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, z = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L323" title="ocaml/runtime/caml/memory.h:323">CAMLxparam3</a> (x, y, z)<br/></li>
<li></span><br/></li>
<li><a id="L388">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLlocal4</span>(x, y, z, t) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> x = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, y = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, z = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, t = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L336" title="ocaml/runtime/caml/memory.h:336">CAMLxparam4</a> (x, y, z, t)<br/></li>
<li></span><br/></li>
<li><a id="L392">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLlocal5</span>(x, y, z, t, u) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> x = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, y = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, z = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, t = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>, u = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L350" title="ocaml/runtime/caml/memory.h:350">CAMLxparam5</a> (x, y, z, t, u)<br/></li>
<li></span><br/></li>
<li><a id="L396">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLlocalN</span>(x, size) \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> x [(size)]; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">int</span><span class="PreProc"> caml__i_##x; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L365" title="ocaml/runtime/caml/memory.h:365">CAMLxparamN</a> (x, (size)); \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">for</span><span class="PreProc"> (caml__i_##x = </span><span class="Constant">0</span><span class="PreProc">; caml__i_##x &lt; size; caml__i_##x ++) { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; x[caml__i_##x] = <a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; }<br/></li>
<li></span><br/></li>
<li><a id="L404">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLdrop</span> </span><span class="Statement">do</span><span class="PreProc">{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; *caml_local_roots_ptr = caml__frame; \<br/></li>
<li></span><span class="PreProc">}</span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L408">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLreturn0</span> </span><span class="Statement">do</span><span class="PreProc">{ \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L404" title="ocaml/runtime/caml/memory.h:404">CAMLdrop</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">return</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">}</span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L413">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLreturnT</span>(type, result) </span><span class="Statement">do</span><span class="PreProc">{ \<br/></li>
<li></span><span class="PreProc">&nbsp; type caml__temp_result = (result); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L404" title="ocaml/runtime/caml/memory.h:404">CAMLdrop</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">return</span><span class="PreProc"> (caml__temp_result); \<br/></li>
<li></span><span class="PreProc">}</span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L419">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLreturn</span>(result) <a href="#L413" title="ocaml/runtime/caml/memory.h:413">CAMLreturnT</a>(<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>, result)<br/></li>
<li></span><br/></li>
<li><a id="L421">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAMLnoreturn</span> ((</span><span class="Type">void</span><span class="PreProc">) caml__frame)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* convenience macro */<br/></li>
<li><a id="L425">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">Store_field</span>(block, offset, val) </span><span class="Statement">do</span><span class="PreProc">{ \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> caml__temp_offset = (offset); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> caml__temp_val = (val); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="../memory.c.html#L149" title="ocaml/runtime/memory.c:149">caml_modify</a> (&amp;<a href="mlvalues.h.html#L228" title="ocaml/runtime/caml/mlvalues.h:228">Field</a> ((block), caml__temp_offset), caml__temp_val); \<br/></li>
<li></span><span class="PreProc">}</span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; NOTE: [Begin_roots] <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [<a href="#L517" title="ocaml/runtime/caml/memory.h:517">End_roots</a>] are superseded by [CAMLparam]*,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [CAMLxparam]*, [CAMLlocal]*, [<a href="#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; [Begin_roots] <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [<a href="#L517" title="ocaml/runtime/caml/memory.h:517">End_roots</a>] are used for C variables that are GC roots.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; It must contain all values in C local variables <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> function parameters<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; at the time the minor GC is called.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Usage:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; After initialising your local variables to legal OCaml values, but before<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; calling allocation functions, insert [Begin_roots_n(v1, ... vn)], where<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; v1 ... vn are your variables of type [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a>] that you want to be updated<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; across allocations.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; At the end, insert [<a href="#L517" title="ocaml/runtime/caml/memory.h:517">End_roots</a>()].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Note that [Begin_roots] opens a new block, <a href="../ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [<a href="#L517" title="ocaml/runtime/caml/memory.h:517">End_roots</a>] closes it.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Thus they must occur in matching pairs at the same brace nesting level.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; You can use [<a href="mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>] as a dummy initial <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> for your variables.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L451">&#x200c;</a><span class="PreProc">#define <span class="linkable">Begin_root</span> <a href="#L453" title="ocaml/runtime/caml/memory.h:453">Begin_roots1</a><br/></li>
<li></span><br/></li>
<li><a id="L453">&#x200c;</a><span class="PreProc">#define <span class="linkable">Begin_roots1</span>(r0) { \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.next = domain_state-&gt;local_roots; \<br/></li>
<li></span><span class="PreProc">&nbsp; domain_state-&gt;local_roots = &amp;<a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.nitems = </span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.ntables = </span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">0</span><span class="PreProc">] = &amp;(r0);<br/></li>
<li></span><br/></li>
<li><a id="L462">&#x200c;</a><span class="PreProc">#define <span class="linkable">Begin_roots2</span>(r0, r1) { \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.next = domain_state-&gt;local_roots; \<br/></li>
<li></span><span class="PreProc">&nbsp; domain_state-&gt;local_roots = &amp;<a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.nitems = </span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.ntables = </span><span class="Constant">2</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">0</span><span class="PreProc">] = &amp;(r0); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">1</span><span class="PreProc">] = &amp;(r1);<br/></li>
<li></span><br/></li>
<li><a id="L472">&#x200c;</a><span class="PreProc">#define <span class="linkable">Begin_roots3</span>(r0, r1, r2) { \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.next = domain_state-&gt;local_roots; \<br/></li>
<li></span><span class="PreProc">&nbsp; domain_state-&gt;local_roots = &amp;<a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.nitems = </span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.ntables = </span><span class="Constant">3</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">0</span><span class="PreProc">] = &amp;(r0); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">1</span><span class="PreProc">] = &amp;(r1); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">2</span><span class="PreProc">] = &amp;(r2);<br/></li>
<li></span><br/></li>
<li><a id="L483">&#x200c;</a><span class="PreProc">#define <span class="linkable">Begin_roots4</span>(r0, r1, r2, r3) { \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.next = domain_state-&gt;local_roots; \<br/></li>
<li></span><span class="PreProc">&nbsp; domain_state-&gt;local_roots = &amp;<a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.nitems = </span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.ntables = </span><span class="Constant">4</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">0</span><span class="PreProc">] = &amp;(r0); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">1</span><span class="PreProc">] = &amp;(r1); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">2</span><span class="PreProc">] = &amp;(r2); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">3</span><span class="PreProc">] = &amp;(r3);<br/></li>
<li></span><br/></li>
<li><a id="L495">&#x200c;</a><span class="PreProc">#define <span class="linkable">Begin_roots5</span>(r0, r1, r2, r3, r4) { \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.next = domain_state-&gt;local_roots; \<br/></li>
<li></span><span class="PreProc">&nbsp; domain_state-&gt;local_roots = &amp;<a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.nitems = </span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.ntables = </span><span class="Constant">5</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">0</span><span class="PreProc">] = &amp;(r0); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">1</span><span class="PreProc">] = &amp;(r1); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">2</span><span class="PreProc">] = &amp;(r2); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">3</span><span class="PreProc">] = &amp;(r3); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">4</span><span class="PreProc">] = &amp;(r4);<br/></li>
<li></span><br/></li>
<li><a id="L508">&#x200c;</a><span class="PreProc">#define <span class="linkable">Begin_roots_block</span>(table, size) { \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">struct</span><span class="PreProc"> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a> <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="domain_state.h.html#L34" title="ocaml/runtime/caml/domain_state.h:34">caml_domain_state</a>* domain_state = <a href="domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.next = domain_state-&gt;local_roots; \<br/></li>
<li></span><span class="PreProc">&nbsp; domain_state-&gt;local_roots = &amp;<a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.nitems = (size); \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.ntables = </span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.tables[</span><span class="Constant">0</span><span class="PreProc">] = (table);<br/></li>
<li></span><br/></li>
<li><a id="L517">&#x200c;</a><span class="PreProc">#define <span class="linkable">End_roots</span>() <a href="#L229" title="ocaml/runtime/caml/memory.h:229">CAML_LOCAL_ROOTS</a> = <a href="#L222" title="ocaml/runtime/caml/memory.h:222">caml__roots_block</a>.next; }<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../globroots.c.html#L67" title="ocaml/runtime/globroots.c:67">caml_register_global_root</a>] registers a global C variable as a memory root<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for the duration of the program, <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> until [<a href="../globroots.c.html#L75" title="ocaml/runtime/globroots.c:75">caml_remove_global_root</a>] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; called. */<br/></li>
<li></span><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../globroots.c.html#L67" title="ocaml/runtime/globroots.c:67">caml_register_global_root</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../globroots.c.html#L75" title="ocaml/runtime/globroots.c:75">caml_remove_global_root</a>] removes a memory root registered on a global C<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; variable with [<a href="../globroots.c.html#L67" title="ocaml/runtime/globroots.c:67">caml_register_global_root</a>]. */<br/></li>
<li></span><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../globroots.c.html#L75" title="ocaml/runtime/globroots.c:75">caml_remove_global_root</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>] registers a global C<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; variable as a memory root for the duration of the program, <a href="../ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> until<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="../globroots.c.html#L113" title="ocaml/runtime/globroots.c:113">caml_remove_generational_global_root</a>] is called.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The program guarantees that the <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> contained in this variable<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; will not be assigned directly.&nbsp; If the program needs to change<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> of this variable, it must do so by calling<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="../globroots.c.html#L129" title="ocaml/runtime/globroots.c:129">caml_modify_generational_global_root</a>].&nbsp; The [<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *] pointer<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; passed to [<a href="../globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>] must contain<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; a valid OCaml <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> before the call.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; In return for these constraints, scanning of memory roots during<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; minor collection is made more efficient. */<br/></li>
<li></span><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../globroots.c.html#L113" title="ocaml/runtime/globroots.c:113">caml_remove_generational_global_root</a>] removes a memory root<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; registered on a global C variable with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="../globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>]. */<br/></li>
<li></span><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../globroots.c.html#L113" title="ocaml/runtime/globroots.c:113">caml_remove_generational_global_root</a> (<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *);<br/></li>
<li><br/></li>
<li><span class="Comment">/* [<a href="../globroots.c.html#L129" title="ocaml/runtime/globroots.c:129">caml_modify_generational_global_root</a>(r, newval)]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; modifies the <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> contained in [r], storing [newval] inside.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; In other words, the assignment [*r = newval] is performed,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; but in a way that is compatible with the optimized scanning of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; generational global roots.&nbsp; [r] must be a global memory root<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; previously registered with [<a href="../globroots.c.html#L95" title="ocaml/runtime/globroots.c:95">caml_register_generational_global_root</a>]. */<br/></li>
<li></span><br/></li>
<li><a href="misc.h.html#L125" title="ocaml/runtime/caml/misc.h:125">CAMLextern</a> <span class="Type">void</span> <a href="../globroots.c.html#L129" title="ocaml/runtime/globroots.c:129">caml_modify_generational_global_root</a>(<a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *r, <a href="mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> newval);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef __cplusplus<br/></li>
<li></span>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="#L19" title="ocaml/runtime/caml/memory.h:19">CAML_MEMORY_H</a> */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
