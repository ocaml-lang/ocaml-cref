<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/win32.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/win32.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L329">argc</a></li>
<li><a href="#L330">argv</a></li>
<li><a href="#L331">argvsize</a></li>
<li><a href="#L609">caml_stack_overflow_handle</a></li>
<li><a href="#L71">caml_win32_build</a></li>
<li><a href="#L69">caml_win32_major</a></li>
<li><a href="#L70">caml_win32_minor</a></li>
<li><a href="#L72">caml_win32_revision</a></li>
<li><a href="#L1128">clock_period</a></li>
<li><a href="#L294">ctrl_handler_action</a></li>
<li><a href="#L293">ctrl_handler_installed</a></li>
<li><a href="#L1022">startup_codepage</a></li>
<li><a href="#L521">win32_alt_stack</a></li>
<li><a href="#L888">windows_unicode_enabled</a></li>
<li><a href="#L902">windows_unicode_fallback</a></li>
<li><a href="#L897">windows_unicode_strict</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L292">sighandler</a></li>
<li><a href="#L1043">tGetFileInformationByHandleEx</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L717">CAML_SNPRINTF(_vsnprintf, _vscprintf)</a></li>
<li><a href="#L961">caml_copy_string_of_utf16</a></li>
<li><a href="#L136">caml_decompose_path</a></li>
<li><a href="#L242">caml_dlclose</a></li>
<li><a href="#L269">caml_dlclose</a></li>
<li><a href="#L257">caml_dlerror</a></li>
<li><a href="#L283">caml_dlerror</a></li>
<li><a href="#L229">caml_dlopen</a></li>
<li><a href="#L264">caml_dlopen</a></li>
<li><a href="#L247">caml_dlsym</a></li>
<li><a href="#L273">caml_dlsym</a></li>
<li><a href="#L670">caml_executable_name</a></li>
<li><a href="#L398">caml_expand_command_line</a></li>
<li><a href="#L252">caml_globalsym</a></li>
<li><a href="#L278">caml_globalsym</a></li>
<li><a href="#L1130">caml_init_os_params</a></li>
<li><a href="#L660">caml_install_invalid_parameter_handler</a></li>
<li><a href="#L1105">caml_num_rows_fd</a></li>
<li><a href="#L1167">caml_plat_mem_commit</a></li>
<li><a href="#L1172">caml_plat_mem_decommit</a></li>
<li><a href="#L1154">caml_plat_mem_map</a></li>
<li><a href="#L1177">caml_plat_mem_unmap</a></li>
<li><a href="#L999">caml_probe_win32_version</a></li>
<li><a href="#L415">caml_read_directory</a></li>
<li><a href="#L96">caml_read_fd</a></li>
<li><a href="#L523">caml_reset_stack</a></li>
<li><a href="#L1033">caml_restore_win32_terminal</a></li>
<li><a href="#L216">caml_search_dll_in_path</a></li>
<li><a href="#L185">caml_search_exe_in_path</a></li>
<li><a href="#L155">caml_search_in_path</a></li>
<li><a href="#L1024">caml_setup_win32_terminal</a></li>
<li><a href="#L460">caml_signal_thread</a></li>
<li><a href="#L548">caml_stack_overflow_VEH</a></li>
<li><a href="#L579">caml_stack_overflow_VEH</a></li>
<li><a href="#L987">caml_stat_strdup_of_utf16</a></li>
<li><a href="#L975">caml_stat_strdup_to_utf16</a></li>
<li><a href="#L1146">caml_time_counter</a></li>
<li><a href="#L1111">caml_win32_clock</a></li>
<li><a href="#L739">caml_win32_getenv</a></li>
<li><a href="#L1046">caml_win32_is_cygwin_pty</a></li>
<li><a href="#L1081">caml_win32_isatty</a></li>
<li><a href="#L904">caml_win32_multi_byte_to_wide_char</a></li>
<li><a href="#L611">caml_win32_overflow_detection</a></li>
<li><a href="#L629">caml_win32_random_seed</a></li>
<li><a href="#L782">caml_win32_rename</a></li>
<li><a href="#L313">caml_win32_signal</a></li>
<li><a href="#L78">caml_win32_sys_error</a></li>
<li><a href="#L845">caml_win32_unlink</a></li>
<li><a href="#L620">caml_win32_unregister_overflow_detection</a></li>
<li><a href="#L936">caml_win32_wide_char_to_multi_byte</a></li>
<li><a href="#L118">caml_write_fd</a></li>
<li><a href="#L296">ctrl_handler</a></li>
<li><a href="#L353">expand_argument</a></li>
<li><a href="#L366">expand_pattern</a></li>
<li><a href="#L650">invalid_parameter_handler</a></li>
<li><a href="#L337">out_of_memory</a></li>
<li><a href="#L342">store_argument</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L16">CAML_INTERNALS</a></li>
<li><a href="#L690">CAML_SNPRINTF</a></li>
<li><a href="#L723">CAML_SNPRINTF</a></li>
<li><a href="#L66">S_ISREG</a></li>
<li><a href="#L933">WC_ERR_INVALID_CHARS</a></li>
<li><a href="#L25">WIN32_LEAN_AND_MEAN</a></li>
<li><a href="#L58">WITH_DYNAMIC_LINKING</a></li>
<li><a href="#L22">_WIN32_WINNT</a></li>
<li><a href="#L23">_WIN32_WINNT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Win32-specific stuff */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* FILE_INFO_BY_HANDLE_CLASS <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> FILE_NAME_INFO are only available from Windows<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Vista onwards */<br/></li>
<li><a id="L22">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">_WIN32_WINNT</span><br/></li>
<li><a id="L23">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">_WIN32_WINNT</span> </span><span class="Constant">0x0600<br/></li>
<li></span><br/></li>
<li><a id="L25">&#x200c;</a><span class="PreProc">#define <span class="linkable">WIN32_LEAN_AND_MEAN</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;wtypes.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;winbase.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;winsock2.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;winioctl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;direct.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdarg.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;io.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/codefrag.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/io.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/osdeps.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/signals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/sys.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/winsupport.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/startup_aux.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/platform.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(SUPPORT_DYNAMIC_LINKING) &amp;&amp; !defined(BUILDING_LIBCAMLRUNS)<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WITH_DYNAMIC_LINKING</span><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef <a href="unix.c.html#L36" title="ocaml/runtime/unix.c:36">WITH_DYNAMIC_LINKING</a><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;flexdll.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="unix.c.html#L73" title="ocaml/runtime/unix.c:73">S_ISREG</a><br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">S_ISREG</span>(mode) (((mode) &amp; S_IFMT) == S_IFREG)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L69">&#x200c;</a><span class="Type">unsigned</span> <span class="Type">short</span> <span class="linkable">caml_win32_major</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L70">&#x200c;</a><span class="Type">unsigned</span> <span class="Type">short</span> <span class="linkable">caml_win32_minor</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L71">&#x200c;</a><span class="Type">unsigned</span> <span class="Type">short</span> <span class="linkable">caml_win32_build</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L72">&#x200c;</a><span class="Type">unsigned</span> <span class="Type">short</span> <span class="linkable">caml_win32_revision</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a href="caml/misc.h.html#L90" title="ocaml/runtime/caml/misc.h:90">CAMLnoreturn_start</a><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L78" title="ocaml/runtime/win32.c:78">caml_win32_sys_error</a> (<span class="Type">int</span> errnum)<br/></li>
<li><a href="caml/misc.h.html#L91" title="ocaml/runtime/caml/misc.h:91">CAMLnoreturn_end</a>;<br/></li>
<li><br/></li>
<li><a id="L78">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_win32_sys_error</span>(<span class="Type">int</span> errnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> buffer[<span class="Constant">512</span>];<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> msg;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(buffer)/<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)) {<br/></li>
<li>&nbsp; &nbsp; msg = <a href="#L961" title="ocaml/runtime/win32.c:961">caml_copy_string_of_utf16</a>(buffer);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; msg = <a href="str.c.html#L390" title="ocaml/runtime/str.c:390">caml_alloc_sprintf</a>(<span class="Constant">&quot;unknown <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> #</span><span class="Special">%d</span><span class="Constant">&quot;</span>, errnum);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="fail_nat.c.html#L163" title="ocaml/runtime/fail_nat.c:163">caml_raise_sys_error</a>(msg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L96">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_read_fd</span>(<span class="Type">int</span> fd, <span class="Type">int</span> flags, <span class="Type">void</span> * buf, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode;<br/></li>
<li>&nbsp; <span class="Statement">if</span> ((flags &amp; CHANNEL_FLAG_FROM_SOCKET) == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L145" title="ocaml/runtime/signals.c:145">caml_enter_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; retcode = read(fd, buf, n);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Large reads from console can fail with ENOMEM.&nbsp; Reduce requested size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> try again. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span> &amp;&amp; errno == <span class="Constant">ENOMEM</span> &amp;&amp; n &gt; <span class="Constant">16384</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; retcode = read(fd, buf, <span class="Constant">16384</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span>) <a href="sys.c.html#L115" title="ocaml/runtime/sys.c:115">caml_sys_io_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L145" title="ocaml/runtime/signals.c:145">caml_enter_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; retcode = recv((SOCKET) _get_osfhandle(fd), buf, n, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span>) <a href="#L78" title="ocaml/runtime/win32.c:78">caml_win32_sys_error</a>(WSAGetLastError());<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> retcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L118">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_write_fd</span>(<span class="Type">int</span> fd, <span class="Type">int</span> flags, <span class="Type">void</span> * buf, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode;<br/></li>
<li>&nbsp; <span class="Statement">if</span> ((flags &amp; CHANNEL_FLAG_FROM_SOCKET) == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L145" title="ocaml/runtime/signals.c:145">caml_enter_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; retcode = write(fd, buf, n);<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span>) <a href="sys.c.html#L115" title="ocaml/runtime/sys.c:115">caml_sys_io_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L145" title="ocaml/runtime/signals.c:145">caml_enter_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; retcode = send((SOCKET) _get_osfhandle(fd), buf, n, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode == -<span class="Constant">1</span>) <a href="#L78" title="ocaml/runtime/win32.c:78">caml_win32_sys_error</a>(WSAGetLastError());<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (retcode &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> retcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L136">&#x200c;</a><span class="Type">wchar_t</span> * <span class="linkable">caml_decompose_path</span>(<span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * tbl, <span class="Type">wchar_t</span> * path)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * p, * q;<br/></li>
<li>&nbsp; <span class="Type">int</span> n;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (path == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; p = <a href="memory.c.html#L642" title="ocaml/runtime/memory.c:642">caml_stat_wcsdup</a>(path);<br/></li>
<li>&nbsp; q = p;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (n = <span class="Constant">0</span>; q[n] != <span class="Constant">0</span> &amp;&amp; q[n] != <span class="Constant">L';'</span>; n++) <span class="Comment">/*nothing*/</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L146" title="ocaml/runtime/misc.c:146">caml_ext_table_add</a>(tbl, q);<br/></li>
<li>&nbsp; &nbsp; q = q + n;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*q == <span class="Constant">0</span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; *q = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; q += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L155">&#x200c;</a><span class="Type">wchar_t</span> * <span class="linkable">caml_search_in_path</span>(<span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * path, <span class="Type">const</span> <span class="Type">wchar_t</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * dir, * fullname;<br/></li>
<li>&nbsp; <span class="Type">char</span> * u8;<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">wchar_t</span> * p;<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Type">struct</span> _stati64 st;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (p = name; *p != <span class="Constant">0</span>; p++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'/'</span> || *p == <span class="Special">'\\'</span>) <span class="Statement">goto</span> not_found;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; path-&gt;size; i++) {<br/></li>
<li>&nbsp; &nbsp; dir = path-&gt;contents[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dir[<span class="Constant">0</span>] == <span class="Constant">0</span>) <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* not sure what empty path components mean under Windows */<br/></li>
<li></span>&nbsp; &nbsp; fullname = <a href="memory.c.html#L686" title="ocaml/runtime/memory.c:686">caml_stat_wcsconcat</a>(<span class="Constant">3</span>, dir, <span class="Constant">L&quot;</span><span class="Special">\\</span><span class="Constant">&quot;</span>, name);<br/></li>
<li>&nbsp; &nbsp; u8 = <a href="#L987" title="ocaml/runtime/win32.c:987">caml_stat_strdup_of_utf16</a>(fullname);<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a>(<span class="Constant">0x100</span>, <span class="Constant">&quot;Searching </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>, u8);<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(u8);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (_wstati64(fullname, &amp;st) == <span class="Constant">0</span> &amp;&amp; <a href="unix.c.html#L73" title="ocaml/runtime/unix.c:73">S_ISREG</a>(st.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fullname;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(fullname);<br/></li>
<li>&nbsp; }<br/></li>
<li> <span class="Statement">not_found</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; u8 = <a href="#L987" title="ocaml/runtime/win32.c:987">caml_stat_strdup_of_utf16</a>(name);<br/></li>
<li>&nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a>(<span class="Constant">0x100</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> not found in search path</span><span class="Special">\n</span><span class="Constant">&quot;</span>, u8);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(u8);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="memory.c.html#L642" title="ocaml/runtime/memory.c:642">caml_stat_wcsdup</a>(name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L185">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">wchar_t</span> * <span class="linkable">caml_search_exe_in_path</span>(<span class="Type">const</span> <span class="Type">wchar_t</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * fullname, * filepart;<br/></li>
<li>&nbsp; <span class="Type">char</span> * u8;<br/></li>
<li>&nbsp; <span class="Type">size_t</span> fullnamelen;<br/></li>
<li>&nbsp; DWORD retcode;<br/></li>
<li><br/></li>
<li>&nbsp; fullnamelen = wcslen(name) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (fullnamelen &lt; <span class="Constant">256</span>) fullnamelen = <span class="Constant">256</span>;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; fullname = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(fullnamelen*<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>));<br/></li>
<li>&nbsp; &nbsp; retcode = SearchPath(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use system search path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">L&quot;.exe&quot;</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="ints.c.html#L461" title="ocaml/runtime/ints.c:461">add</a> .exe extension if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fullnamelen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fullname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;filepart);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; u8 = <a href="#L987" title="ocaml/runtime/win32.c:987">caml_stat_strdup_of_utf16</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L95" title="ocaml/runtime/misc.c:95">caml_gc_message</a>(<span class="Constant">0x100</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> not found in search path</span><span class="Special">\n</span><span class="Constant">&quot;</span>, u8);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(u8);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(fullname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="caml/misc.h.html#L393" title="ocaml/runtime/caml/misc.h:393">caml_stat_strdup_os</a>(name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode &lt; fullnamelen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fullname;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(fullname);<br/></li>
<li>&nbsp; &nbsp; fullnamelen = retcode + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L216">&#x200c;</a><span class="Type">wchar_t</span> * <span class="linkable">caml_search_dll_in_path</span>(<span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * path, <span class="Type">const</span> <span class="Type">wchar_t</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * dllname;<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * res;<br/></li>
<li><br/></li>
<li>&nbsp; dllname = <a href="memory.c.html#L686" title="ocaml/runtime/memory.c:686">caml_stat_wcsconcat</a>(<span class="Constant">2</span>, name, <span class="Constant">L&quot;.dll&quot;</span>);<br/></li>
<li>&nbsp; res = <a href="unix.c.html#L141" title="ocaml/runtime/unix.c:141">caml_search_in_path</a>(path, dllname);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(dllname);<br/></li>
<li>&nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="unix.c.html#L36" title="ocaml/runtime/unix.c:36">WITH_DYNAMIC_LINKING</a><br/></li>
<li></span><br/></li>
<li><a id="L229">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlopen</span>(<span class="Type">wchar_t</span> * libname, <span class="Type">int</span> global)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">void</span> *handle;<br/></li>
<li>&nbsp; <span class="Type">int</span> flags = (global ? FLEXDLL_RTLD_GLOBAL : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; handle = flexdll_wdlopen(libname, flags);<br/></li>
<li>&nbsp; <span class="Statement">if</span> ((handle != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp;&nbsp; &amp;&amp; ((<a href="caml/platform.h.html#L56" title="ocaml/runtime/caml/platform.h:56">atomic_load_relaxed</a>(&amp;<a href="misc.c.html#L79" title="ocaml/runtime/misc.c:79">caml_verb_gc</a>) &amp; <span class="Constant">0x100</span>) != <span class="Constant">0</span>)) {<br/></li>
<li>&nbsp; &nbsp; flexdll_dump_exports(handle);<br/></li>
<li>&nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> handle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L242">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_dlclose</span>(<span class="Type">void</span> * handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; flexdll_dlclose(handle);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L247">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlsym</span>(<span class="Type">void</span> * handle, <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> flexdll_dlsym(handle, name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L252">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_globalsym</span>(<span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> flexdll_dlsym(flexdll_wdlopen(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<span class="Constant">0</span>), name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L257">&#x200c;</a><span class="Type">char</span> * <span class="linkable">caml_dlerror</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> flexdll_dlerror();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li><a id="L264">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlopen</span>(<span class="Type">wchar_t</span> * libname, <span class="Type">int</span> global)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L269">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_dlclose</span>(<span class="Type">void</span> * handle)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L273">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_dlsym</span>(<span class="Type">void</span> * handle, <span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L278">&#x200c;</a><span class="Type">void</span> * <span class="linkable">caml_globalsym</span>(<span class="Type">const</span> <span class="Type">char</span> * name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L283">&#x200c;</a><span class="Type">char</span> * <span class="linkable">caml_dlerror</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">&quot;dynamic loading not supported on this platform&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* <a href="unix.c.html#L36" title="ocaml/runtime/unix.c:36">WITH_DYNAMIC_LINKING</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Proper emulation of signal(), including ctrl-C <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> ctrl-break */<br/></li>
<li></span><br/></li>
<li><a id="L292">&#x200c;</a><span class="Type">typedef</span> <span class="Type">void</span> (*<span class="linkable">sighandler</span>)(<span class="Type">int</span> sig);<br/></li>
<li><a id="L293">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">ctrl_handler_installed</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L294">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <a href="#L292" title="ocaml/runtime/win32.c:292">sighandler</a> <span class="linkable">ctrl_handler_action</span> = <span class="Constant">SIG_DFL</span>;<br/></li>
<li><br/></li>
<li><a id="L296">&#x200c;</a><span class="Type">static</span> BOOL WINAPI <span class="linkable">ctrl_handler</span>(DWORD event)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* Only ctrl-C <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> ctrl-Break are handled */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (event != CTRL_C_EVENT &amp;&amp; event != CTRL_BREAK_EVENT) <span class="Statement">return</span> FALSE;<br/></li>
<li>&nbsp; <span class="Comment">/* Default behavior is to exit, which we get by not handling the event */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L294" title="ocaml/runtime/win32.c:294">ctrl_handler_action</a> == <span class="Constant">SIG_DFL</span>) <span class="Statement">return</span> FALSE;<br/></li>
<li>&nbsp; <span class="Comment">/* Ignore behavior is to do nothing, which we get by claiming that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; have handled the event */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L294" title="ocaml/runtime/win32.c:294">ctrl_handler_action</a> == <span class="Constant">SIG_IGN</span>) <span class="Statement">return</span> TRUE;<br/></li>
<li>&nbsp; <span class="Comment">/* Win32 doesn't like it when we do a longjmp() at this point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; (it looks like we're running in a different thread than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the main program!).&nbsp; So, just record the signal. */<br/></li>
<li></span>&nbsp; <a href="signals.c.html#L115" title="ocaml/runtime/signals.c:115">caml_record_signal</a>(<span class="Constant"><a href="signals.c.html#L383" title="ocaml/runtime/signals.c:383">SIGINT</a></span>);<br/></li>
<li>&nbsp; <span class="Comment">/* We have handled the event */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> TRUE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L313">&#x200c;</a><a href="#L292" title="ocaml/runtime/win32.c:292">sighandler</a> <span class="linkable">caml_win32_signal</span>(<span class="Type">int</span> sig, <a href="#L292" title="ocaml/runtime/win32.c:292">sighandler</a> action)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L292" title="ocaml/runtime/win32.c:292">sighandler</a> oldaction;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (sig != <span class="Constant"><a href="signals.c.html#L383" title="ocaml/runtime/signals.c:383">SIGINT</a></span>) <span class="Statement">return</span> signal(sig, action);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (! <a href="#L293" title="ocaml/runtime/win32.c:293">ctrl_handler_installed</a>) {<br/></li>
<li>&nbsp; &nbsp; SetConsoleCtrlHandler(<a href="#L296" title="ocaml/runtime/win32.c:296">ctrl_handler</a>, TRUE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L293" title="ocaml/runtime/win32.c:293">ctrl_handler_installed</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; oldaction = <a href="#L294" title="ocaml/runtime/win32.c:294">ctrl_handler_action</a>;<br/></li>
<li>&nbsp; <a href="#L294" title="ocaml/runtime/win32.c:294">ctrl_handler_action</a> = action;<br/></li>
<li>&nbsp; <span class="Statement">return</span> oldaction;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Expansion of @responsefile <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> *? file patterns in the command line */<br/></li>
<li></span><br/></li>
<li><a id="L329">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">argc</span>;<br/></li>
<li><a id="L330">&#x200c;</a><span class="Type">static</span> <span class="Type">wchar_t</span> ** <span class="linkable">argv</span>;<br/></li>
<li><a id="L331">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">argvsize</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L342" title="ocaml/runtime/win32.c:342">store_argument</a>(<span class="Type">wchar_t</span> * arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L353" title="ocaml/runtime/win32.c:353">expand_argument</a>(<span class="Type">wchar_t</span> * arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L366" title="ocaml/runtime/win32.c:366">expand_pattern</a>(<span class="Type">wchar_t</span> * arg);<br/></li>
<li><br/></li>
<li><a id="L337">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">out_of_memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;out of memory while expanding command line&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L342">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">store_argument</span>(<span class="Type">wchar_t</span> * arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L329" title="ocaml/runtime/win32.c:329">argc</a> + <span class="Constant">1</span> &gt;= <a href="#L331" title="ocaml/runtime/win32.c:331">argvsize</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L331" title="ocaml/runtime/win32.c:331">argvsize</a> *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L330" title="ocaml/runtime/win32.c:330">argv</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<span class="Type">wchar_t</span> **) <a href="memory.c.html#L573" title="ocaml/runtime/memory.c:573">caml_stat_resize_noexc</a>(<a href="#L330" title="ocaml/runtime/win32.c:330">argv</a>, <a href="#L331" title="ocaml/runtime/win32.c:331">argvsize</a> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span> *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L330" title="ocaml/runtime/win32.c:330">argv</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <a href="#L337" title="ocaml/runtime/win32.c:337">out_of_memory</a>();<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L330" title="ocaml/runtime/win32.c:330">argv</a>[<a href="#L329" title="ocaml/runtime/win32.c:329">argc</a>++] = arg;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L353">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">expand_argument</span>(<span class="Type">wchar_t</span> * arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * p;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">for</span> (p = arg; *p != <span class="Constant">0</span>; p++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">L'*'</span> || *p == <span class="Constant">L'?'</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L366" title="ocaml/runtime/win32.c:366">expand_pattern</a>(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L342" title="ocaml/runtime/win32.c:342">store_argument</a>(arg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L366">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">expand_pattern</span>(<span class="Type">wchar_t</span> * pat)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * prefix, * p, * name;<br/></li>
<li>&nbsp; <span class="Type">intptr_t</span> handle;<br/></li>
<li>&nbsp; <span class="Type">struct</span> _wfinddata_t ffblk;<br/></li>
<li>&nbsp; <span class="Type">size_t</span> i;<br/></li>
<li><br/></li>
<li>&nbsp; handle = _wfindfirst(pat, &amp;ffblk);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (handle == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L342" title="ocaml/runtime/win32.c:342">store_argument</a>(pat); <span class="Comment">/* a la Bourne shell */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; prefix = <a href="memory.c.html#L642" title="ocaml/runtime/memory.c:642">caml_stat_wcsdup</a>(pat);<br/></li>
<li>&nbsp; <span class="Comment">/* We need to stop at the first directory <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> drive boundary, because the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * _findata_t structure contains the filename, not the leading directory. */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (i = wcslen(prefix); i &gt; <span class="Constant">0</span>; i--) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">wchar_t</span> c = prefix[i - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (c == <span class="Special">L'\\'</span> || c == <span class="Constant">L'/'</span> || c == <span class="Constant">L':'</span>) { prefix[i] = <span class="Constant">0</span>; <span class="Statement">break</span>; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* No separator was found, it's a filename pattern without a leading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; directory. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; prefix[<span class="Constant">0</span>] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; name = <a href="memory.c.html#L686" title="ocaml/runtime/memory.c:686">caml_stat_wcsconcat</a>(<span class="Constant">2</span>, prefix, ffblk.name);<br/></li>
<li>&nbsp; &nbsp; <a href="#L342" title="ocaml/runtime/win32.c:342">store_argument</a>(name);<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (_wfindnext(handle, &amp;ffblk) != -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; _findclose(handle);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(prefix);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L398">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_expand_command_line</span>(<span class="Type">int</span> * argcp, <span class="Type">wchar_t</span> *** argvp)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="#L329" title="ocaml/runtime/win32.c:329">argc</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="#L331" title="ocaml/runtime/win32.c:331">argvsize</a> = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; <a href="#L330" title="ocaml/runtime/win32.c:330">argv</a> = (<span class="Type">wchar_t</span> **) <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(<a href="#L331" title="ocaml/runtime/win32.c:331">argvsize</a> * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span> *));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L330" title="ocaml/runtime/win32.c:330">argv</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <a href="#L337" title="ocaml/runtime/win32.c:337">out_of_memory</a>();<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; *argcp; i++) <a href="#L353" title="ocaml/runtime/win32.c:353">expand_argument</a>((*argvp)[i]);<br/></li>
<li>&nbsp; <a href="#L330" title="ocaml/runtime/win32.c:330">argv</a>[<a href="#L329" title="ocaml/runtime/win32.c:329">argc</a>] = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; *argcp = <a href="#L329" title="ocaml/runtime/win32.c:329">argc</a>;<br/></li>
<li>&nbsp; *argvp = <a href="#L330" title="ocaml/runtime/win32.c:330">argv</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Add to [contents] the (short) names of the files contained in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the directory named [dirname].&nbsp; No entries are added for [.] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [..].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Return 0 on success, -1 on <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>; set errno in the case of <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>. */<br/></li>
<li></span><br/></li>
<li><a id="L415">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_read_directory</span>(<span class="Type">wchar_t</span> * dirname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> <a href="caml/misc.h.html#L452" title="ocaml/runtime/caml/misc.h:452">ext_table</a> * contents)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">size_t</span> dirnamelen;<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * template;<br/></li>
<li>&nbsp; <span class="Type">intptr_t</span> h;<br/></li>
<li>&nbsp; <span class="Type">struct</span> _wfinddata_t fileinfo;<br/></li>
<li>&nbsp; <span class="Type">int</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; dirnamelen = wcslen(dirname);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (dirnamelen &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; (dirname[dirnamelen - <span class="Constant">1</span>] == <span class="Constant">L'/'<br/></li>
<li></span>&nbsp; &nbsp; &nbsp;&nbsp; || dirname[dirnamelen - <span class="Constant">1</span>] == <span class="Special">L'\\'<br/></li>
<li></span>&nbsp; &nbsp; &nbsp;&nbsp; || dirname[dirnamelen - <span class="Constant">1</span>] == <span class="Constant">L':'</span>))<br/></li>
<li>&nbsp; &nbsp; template = <a href="memory.c.html#L686" title="ocaml/runtime/memory.c:686">caml_stat_wcsconcat</a>(<span class="Constant">2</span>, dirname, <span class="Constant">L&quot;*.*&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; template = <a href="memory.c.html#L686" title="ocaml/runtime/memory.c:686">caml_stat_wcsconcat</a>(<span class="Constant">2</span>, dirname, <span class="Constant">L&quot;</span><span class="Special">\\</span><span class="Constant">*.*&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; dirnamelen++; <span class="Comment">/* template[dirnamelen] always points after the backslash */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; h = _wfindfirst(template, &amp;fileinfo);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (h == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Instead of checking the existence of [dirname] directly, we call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; [GetFileAttributes()] on [template] without the trailing [*.*].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; The added backslash at the end gives us the expected result (-1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; on pathological paths like [...]. */<br/></li>
<li></span>&nbsp; &nbsp; template[dirnamelen] = <span class="Special">L'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; res = errno == <span class="Constant">ENOENT</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetFileAttributes(template) != INVALID_FILE_ATTRIBUTES ? <span class="Constant">0</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(template);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (wcscmp(fileinfo.name, <span class="Constant">L&quot;.&quot;</span>) != <span class="Constant">0</span> &amp;&amp; wcscmp(fileinfo.name, <span class="Constant">L&quot;..&quot;</span>) != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="misc.c.html#L146" title="ocaml/runtime/misc.c:146">caml_ext_table_add</a>(contents, <a href="#L987" title="ocaml/runtime/win32.c:987">caml_stat_strdup_of_utf16</a>(fileinfo.name));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (_wfindnext(h, &amp;fileinfo) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; _findclose(h);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(template);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef NATIVE_CODE<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Set up a new thread for control-C emulation <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> termination */<br/></li>
<li></span><br/></li>
<li><a id="L460">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_signal_thread</span>(<span class="Type">void</span> * lpParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> *endptr;<br/></li>
<li>&nbsp; HANDLE h;<br/></li>
<li>&nbsp; <span class="Comment">/* Get an hexa-code raw handle through the environment */<br/></li>
<li></span>&nbsp; h = (HANDLE) (<span class="Type">uintptr_t</span>)<br/></li>
<li>&nbsp; &nbsp; wcstol(<a href="unix.c.html#L414" title="ocaml/runtime/unix.c:414">caml_secure_getenv</a>(<a href="caml/misc.h.html#L363" title="ocaml/runtime/caml/misc.h:363">T</a>(<span class="Constant">&quot;CAMLSIGPIPE&quot;</span>)), &amp;endptr, <span class="Constant">16</span>);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; DWORD numread;<br/></li>
<li>&nbsp; &nbsp; BOOL ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span> iobuf[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This shall always return a single character */<br/></li>
<li></span>&nbsp; &nbsp; ret = ReadFile(h, iobuf, <span class="Constant">1</span>, &amp;numread, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ret || numread != <span class="Constant">1</span>) <a href="sys.c.html#L134" title="ocaml/runtime/sys.c:134">caml_do_exit</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (iobuf[<span class="Constant">0</span>]) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'C'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="signals.c.html#L115" title="ocaml/runtime/signals.c:115">caml_record_signal</a>(<span class="Constant"><a href="signals.c.html#L383" title="ocaml/runtime/signals.c:383">SIGINT</a></span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'<a href="caml/misc.h.html#L363" title="ocaml/runtime/caml/misc.h:363">T</a>'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; raise(<span class="Constant"><a href="signals.c.html#L398" title="ocaml/runtime/signals.c:398">SIGTERM</a></span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* NATIVE_CODE */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(NATIVE_CODE)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Handling of system stack overflow.<br/></li>
<li></span><span class="Comment"> * Based on code provided by Olivier Andrieu.<br/></li>
<li></span><br/></li>
<li><span class="Comment"> * An EXCEPTION_STACK_OVERFLOW is signaled when the guard page at the<br/></li>
<li></span><span class="Comment"> * end of the stack has been accessed. Windows clears the PAGE_GUARD<br/></li>
<li></span><span class="Comment"> * protection (making it a regular PAGE_READWRITE) <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> then calls our<br/></li>
<li></span><span class="Comment"> * exception handler. This means that although we're handling an &quot;out<br/></li>
<li></span><span class="Comment"> * of stack&quot; condition, there is a bit of stack available to call<br/></li>
<li></span><span class="Comment"> * functions <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> allocate temporaries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * PAGE_GUARD is a one-shot access protection mechanism: we need to<br/></li>
<li></span><span class="Comment"> * restore the PAGE_GUARD protection on this page otherwise the next<br/></li>
<li></span><span class="Comment"> * stack overflow won't be detected <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the program will abruptly exit<br/></li>
<li></span><span class="Comment"> * with STATUS_ACCESS_VIOLATION.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Visual Studio 2003 <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> later (_MSC_VER &gt;= 1300) have a<br/></li>
<li></span><span class="Comment"> * _resetstkoflw() function that resets this protection.<br/></li>
<li></span><span class="Comment"> * Unfortunately, it cannot work when called directly from the<br/></li>
<li></span><span class="Comment"> * exception handler because at this point we are using the page that<br/></li>
<li></span><span class="Comment"> * is to be protected.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="shared_heap.c.html#L657" title="ocaml/runtime/shared_heap.c:657">A</a> solution is to use an alternate stack when restoring the<br/></li>
<li></span><span class="Comment"> * protection. However it's not possible to use _resetstkoflw() then<br/></li>
<li></span><span class="Comment"> * since it determines the stack pointer by calling alloca(): it would<br/></li>
<li></span><span class="Comment"> * try to protect the alternate stack.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Finally, we call <a href="fail_nat.c.html#L158" title="ocaml/runtime/fail_nat.c:158">caml_raise_stack_overflow</a>; it will either call<br/></li>
<li></span><span class="Comment"> * caml_raise_exception which switches back to the normal stack, <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a><br/></li>
<li></span><span class="Comment"> * call <a href="printexc.c.html#L139" title="ocaml/runtime/printexc.c:139">caml_fatal_uncaught_exception</a> which terminates the program<br/></li>
<li></span><span class="Comment"> * quickly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L521">&#x200c;</a><span class="Type">static</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">win32_alt_stack</span>[<span class="Constant">0x100</span>];<br/></li>
<li><br/></li>
<li><a id="L523">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">caml_reset_stack</span> (<span class="Type">void</span> *faulting_address)<br/></li>
<li>{<br/></li>
<li>&nbsp; SYSTEM_INFO si;<br/></li>
<li>&nbsp; DWORD page_size;<br/></li>
<li>&nbsp; MEMORY_BASIC_INFORMATION mbi;<br/></li>
<li>&nbsp; DWORD oldprot;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* get the system's page size. */<br/></li>
<li></span>&nbsp; GetSystemInfo (&amp;si);<br/></li>
<li>&nbsp; page_size = si.dwPageSize;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* get some information on the page the fault occurred */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (! VirtualQuery (faulting_address, &amp;mbi, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span> mbi))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">goto</span> failed;<br/></li>
<li><br/></li>
<li>&nbsp; VirtualProtect (mbi.BaseAddress, page_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mbi.Protect | PAGE_GUARD, &amp;oldprot);<br/></li>
<li><br/></li>
<li> <span class="Statement">failed</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="fail_nat.c.html#L158" title="ocaml/runtime/fail_nat.c:158">caml_raise_stack_overflow</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef _WIN64<br/></li>
<li></span><span class="Type">static</span> LONG CALLBACK<br/></li>
<li><a id="L548">&#x200c;</a>&nbsp; &nbsp; <span class="linkable">caml_stack_overflow_VEH</span> (EXCEPTION_POINTERS* exn_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; DWORD code&nbsp;&nbsp; = exn_info-&gt;ExceptionRecord-&gt;ExceptionCode;<br/></li>
<li>&nbsp; CONTEXT *ctx = exn_info-&gt;ContextRecord;<br/></li>
<li>&nbsp; DWORD *ctx_ip = &amp;(ctx-&gt;Eip);<br/></li>
<li>&nbsp; DWORD *ctx_sp = &amp;(ctx-&gt;Esp);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (code == EXCEPTION_STACK_OVERFLOW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="codefrag.c.html#L104" title="ocaml/runtime/codefrag.c:104">caml_find_code_fragment_by_pc</a>((<span class="Type">char</span> *) (*ctx_ip)) != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> faulting_address;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> * alt_esp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* grab the address that caused the fault */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; faulting_address = exn_info-&gt;ExceptionRecord-&gt;ExceptionInformation[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* call <a href="#L523" title="ocaml/runtime/win32.c:523">caml_reset_stack</a>(faulting_address) using the alternate stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; alt_esp&nbsp; = <a href="#L521" title="ocaml/runtime/win32.c:521">win32_alt_stack</a> + <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L521" title="ocaml/runtime/win32.c:521">win32_alt_stack</a>) / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; *--alt_esp = faulting_address;<br/></li>
<li>&nbsp; &nbsp; &nbsp; *ctx_sp = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) (alt_esp - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; *ctx_ip = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) &amp;<a href="#L523" title="ocaml/runtime/win32.c:523">caml_reset_stack</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> EXCEPTION_CONTINUE_EXECUTION;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> EXCEPTION_CONTINUE_SEARCH;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> LONG CALLBACK<br/></li>
<li><a id="L579">&#x200c;</a>&nbsp; &nbsp; <span class="linkable">caml_stack_overflow_VEH</span> (EXCEPTION_POINTERS* exn_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; DWORD code&nbsp;&nbsp; = exn_info-&gt;ExceptionRecord-&gt;ExceptionCode;<br/></li>
<li>&nbsp; CONTEXT *ctx = exn_info-&gt;ContextRecord;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (code == EXCEPTION_STACK_OVERFLOW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="codefrag.c.html#L104" title="ocaml/runtime/codefrag.c:104">caml_find_code_fragment_by_pc</a>((<span class="Type">char</span> *) (ctx-&gt;Rip)) != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> faulting_address;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> * alt_rsp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* grab the address that caused the fault */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; faulting_address = exn_info-&gt;ExceptionRecord-&gt;ExceptionInformation[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* refresh runtime parameters from registers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/domain_state.h.html#L62" title="ocaml/runtime/caml/domain_state.h:62">Caml_state</a>-&gt;young_ptr = (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> *) ctx-&gt;R15;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* call <a href="#L523" title="ocaml/runtime/win32.c:523">caml_reset_stack</a>(faulting_address) using the alternate stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; alt_rsp&nbsp; = <a href="#L521" title="ocaml/runtime/win32.c:521">win32_alt_stack</a> + <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="#L521" title="ocaml/runtime/win32.c:521">win32_alt_stack</a>) / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; ctx-&gt;Rcx = faulting_address;<br/></li>
<li>&nbsp; &nbsp; &nbsp; ctx-&gt;Rsp = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) (alt_rsp - <span class="Constant">4</span> - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; ctx-&gt;Rip = (<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a>) &amp;<a href="#L523" title="ocaml/runtime/win32.c:523">caml_reset_stack</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> EXCEPTION_CONTINUE_EXECUTION;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> EXCEPTION_CONTINUE_SEARCH;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* _WIN64 */<br/></li>
<li></span><br/></li>
<li><a id="L609">&#x200c;</a><span class="Type">static</span> PVOID <span class="linkable">caml_stack_overflow_handle</span>;<br/></li>
<li><br/></li>
<li><a id="L611">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_win32_overflow_detection</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L609" title="ocaml/runtime/win32.c:609">caml_stack_overflow_handle</a> =<br/></li>
<li>&nbsp; &nbsp; AddVectoredExceptionHandler(<span class="Constant">1</span>, <a href="#L548" title="ocaml/runtime/win32.c:548">caml_stack_overflow_VEH</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L609" title="ocaml/runtime/win32.c:609">caml_stack_overflow_handle</a> == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;cannot install stack overflow detection&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L620">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_win32_unregister_overflow_detection</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; RemoveVectoredExceptionHandler(<a href="#L609" title="ocaml/runtime/win32.c:609">caml_stack_overflow_handle</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span> <span class="Comment">/* NATIVE_CODE */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Seeding of pseudo-random number generators */<br/></li>
<li></span><br/></li>
<li><a id="L629">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_win32_random_seed</span> (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> data[<span class="Constant">16</span>])<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* For better randomness, consider:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; http://msdn.microsoft.com/library/en-us/seccrypto/security/rtlgenrandom.asp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; http://blogs.msdn.com/<a href="bigarray.c.html#L951" title="ocaml/runtime/bigarray.c:951">b</a>/michael_howard/archive/2005/01/14/353379.aspx<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span>&nbsp; FILETIME t;<br/></li>
<li>&nbsp; LARGE_INTEGER pc;<br/></li>
<li>&nbsp; GetSystemTimeAsFileTime(&amp;t);<br/></li>
<li>&nbsp; QueryPerformanceCounter(&amp;pc);&nbsp; <span class="Comment">/* PR#6032 */<br/></li>
<li></span>&nbsp; data[<span class="Constant">0</span>] = t.dwLowDateTime;<br/></li>
<li>&nbsp; data[<span class="Constant">1</span>] = t.dwHighDateTime;<br/></li>
<li>&nbsp; data[<span class="Constant">2</span>] = GetCurrentProcessId();<br/></li>
<li>&nbsp; data[<span class="Constant">3</span>] = pc.LowPart;<br/></li>
<li>&nbsp; data[<span class="Constant">4</span>] = pc.HighPart;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">5</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef _MSC_VER<br/></li>
<li></span><br/></li>
<li><a id="L650">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">invalid_parameter_handler</span>(<span class="Type">const</span> <span class="Type">wchar_t</span>* expression,<br/></li>
<li>&nbsp;&nbsp; <span class="Type">const</span> <span class="Type">wchar_t</span>* function,<br/></li>
<li>&nbsp;&nbsp; <span class="Type">const</span> <span class="Type">wchar_t</span>* file,<br/></li>
<li>&nbsp;&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> line,<br/></li>
<li>&nbsp;&nbsp; <span class="Type">uintptr_t</span> pReserved)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* no crash box */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L660">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_install_invalid_parameter_handler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; _set_invalid_parameter_handler(<a href="#L650" title="ocaml/runtime/win32.c:650">invalid_parameter_handler</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Recover executable name&nbsp; */<br/></li>
<li></span><br/></li>
<li><a id="L670">&#x200c;</a><span class="Type">wchar_t</span> * <span class="linkable">caml_executable_name</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * name;<br/></li>
<li>&nbsp; DWORD namelen, ret;<br/></li>
<li><br/></li>
<li>&nbsp; namelen = <span class="Constant">256</span>;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; name = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(namelen*<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>));<br/></li>
<li>&nbsp; &nbsp; ret = GetModuleFileName(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, name, namelen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret == <span class="Constant">0</span>) { <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(name); <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; namelen) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (namelen &gt;= <span class="Constant">1024</span>*<span class="Constant">1024</span>) <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>; <span class="Comment">/* avoid runaway <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> overflow */<br/></li>
<li></span>&nbsp; &nbsp; namelen *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> name;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="caml/misc.h.html#L550" title="ocaml/runtime/caml/misc.h:550">snprintf</a> emulation */<br/></li>
<li></span><br/></li>
<li><a id="L690">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_SNPRINTF</span>(_vsnprintf, _vscprintf) \<br/></li>
<li></span><span class="PreProc">{ \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">int</span><span class="PreProc"> len; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Type">va_list</span><span class="PreProc"> args; \<br/></li>
<li></span><span class="PreProc">\<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">if</span><span class="PreProc"> (size &gt; </span><span class="Constant">0</span><span class="PreProc">) { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; va_start(args, format); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; len = _vsnprintf(buf, size, format, args); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; va_end(args); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (len &gt;= </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; len &lt; size) { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; </span><span class="Comment">/* [len] characters were stored in [buf], \<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; a null-terminator was appended. */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> len; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* [size] characters were stored in [buf], without null termination. \<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Put a null terminator, truncating the output. */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; buf[size - </span><span class="Constant">1</span><span class="PreProc">] = </span><span class="Constant">0</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Comment">/* Compute the actual length of output, excluding null terminator */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; va_start(args, format); \<br/></li>
<li></span><span class="PreProc">&nbsp; len = _vscprintf(format, args); \<br/></li>
<li></span><span class="PreProc">&nbsp; va_end(args); \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">return</span><span class="PreProc"> len; \<br/></li>
<li></span><span class="PreProc">}<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef _UCRT<br/></li>
<li></span><span class="Type">int</span> caml_snprintf(<span class="Type">char</span> * buf, <span class="Type">size_t</span> size, <span class="Type">const</span> <span class="Type">char</span> * format, ...)<br/></li>
<li><a id="L717">&#x200c;</a><span class="linkable">CAML_SNPRINTF</span>(_vsnprintf, _vscprintf)<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">int</span> caml_snwprintf(<span class="Type">wchar_t</span> * buf, <span class="Type">size_t</span> size, <span class="Type">const</span> <span class="Type">wchar_t</span> * format, ...)<br/></li>
<li><a href="#L690" title="ocaml/runtime/win32.c:690">CAML_SNPRINTF</a>(_vsnwprintf, _vscwprintf)<br/></li>
<li><br/></li>
<li><a id="L723">&#x200c;</a><span class="PreProc">#undef <span class="linkable">CAML_SNPRINTF</span><br/></li>
<li></span><br/></li>
<li><span class="Type">wchar_t</span> *<a href="unix.c.html#L414" title="ocaml/runtime/unix.c:414">caml_secure_getenv</a> (<span class="Type">wchar_t</span> <span class="Type">const</span> *var)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* Win32 doesn't have a notion of setuid bit, so getenv is safe. */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> _wgetenv(var);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L739" title="ocaml/runtime/win32.c:739">caml_win32_getenv</a> is used to implement Sys.getenv <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> Unix.getenv in such a<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; way that they get direct access to the Win32 environment rather than to the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; copy that is cached by the C runtime system. The result of <a href="#L739" title="ocaml/runtime/win32.c:739">caml_win32_getenv</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is dynamically allocated <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> must be explicitly deallocated.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; In contrast, the OCaml runtime system still calls _wgetenv from the C runtime<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; system, via <a href="unix.c.html#L414" title="ocaml/runtime/unix.c:414">caml_secure_getenv</a>. The result is statically allocated <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> needs<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; no deallocation. */<br/></li>
<li><a id="L739">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">wchar_t</span> *<span class="linkable">caml_win32_getenv</span>(<span class="Type">wchar_t</span> <span class="Type">const</span> *lpName)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * lpBuffer;<br/></li>
<li>&nbsp; DWORD nSize = <span class="Constant">256</span>, res;<br/></li>
<li><br/></li>
<li>&nbsp; lpBuffer = <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(nSize * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (lpBuffer == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; res = GetEnvironmentVariable(lpName, lpBuffer, nSize);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (res == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(lpBuffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (res &lt; nSize)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lpBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; nSize = res;<br/></li>
<li>&nbsp; lpBuffer = <a href="memory.c.html#L573" title="ocaml/runtime/memory.c:573">caml_stat_resize_noexc</a>(lpBuffer, nSize * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">wchar_t</span>));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (lpBuffer == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li>&nbsp; res = GetEnvironmentVariable(lpName, lpBuffer, nSize);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (res == <span class="Constant">0</span> || res &gt;= nSize) {<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(lpBuffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> lpBuffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* The rename() implementation in MSVC's CRT is based on MoveFile()<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> therefore fails if the new name exists.&nbsp; This is inconsistent<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; with POSIX <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> a problem in practice.&nbsp; Here we reimplement<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; rename() using MoveFileEx() to make it more POSIX-like.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; There are no official guarantee that the rename operation is atomic,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; but it is widely believed to be atomic on NTFS. */<br/></li>
<li></span><br/></li>
<li><a id="L782">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_win32_rename</span>(<span class="Type">const</span> <span class="Type">wchar_t</span> * oldpath, <span class="Type">const</span> <span class="Type">wchar_t</span> * newpath)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* First handle corner-case not handled by MoveFileEx:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; - dir to existing file - should fail */<br/></li>
<li></span>&nbsp; DWORD new_attribs;<br/></li>
<li>&nbsp; DWORD old_attribs = GetFileAttributes(oldpath);<br/></li>
<li>&nbsp; <span class="Statement">if</span> ((old_attribs != INVALID_FILE_ATTRIBUTES) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; (old_attribs &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; new_attribs = GetFileAttributes(newpath);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((new_attribs != INVALID_FILE_ATTRIBUTES) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (new_attribs &amp; FILE_ATTRIBUTE_DIRECTORY) == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOTDIR</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* MOVEFILE_REPLACE_EXISTING: to be closer to POSIX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; MOVEFILE_COPY_ALLOWED: MoveFile performs a copy if old <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; paths are on different devices, so we do the same here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; compatibility with the old rename()-based implementation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; MOVEFILE_WRITE_THROUGH: not sure it's useful; affects only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; the case where a copy is done. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (MoveFileEx(oldpath, newpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MOVEFILE_COPY_ALLOWED)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Another cornercase not handled by MoveFileEx:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; - dir to empty dir - positive - should succeed */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> ((old_attribs != INVALID_FILE_ATTRIBUTES) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; (old_attribs &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; (new_attribs != INVALID_FILE_ATTRIBUTES) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; (new_attribs &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to delete: RemoveDirectoryW fails on non-empty dirs as intended.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Then try again. */<br/></li>
<li></span>&nbsp; &nbsp; RemoveDirectoryW(newpath);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MoveFileEx(oldpath, newpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MOVEFILE_COPY_ALLOWED)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Modest attempt at mapping Win32 <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> codes to POSIX <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> codes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; The __dosmaperr() function from the CRT does a better job but is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; generally not accessible. */<br/></li>
<li></span>&nbsp; <span class="Statement">switch</span> (GetLastError()) {<br/></li>
<li>&nbsp; <span class="Statement">case</span> ERROR_FILE_NOT_FOUND: <span class="Statement">case</span> ERROR_PATH_NOT_FOUND:<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">ENOENT</span>; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">case</span> ERROR_ACCESS_DENIED: <span class="Statement">case</span> ERROR_WRITE_PROTECT: <span class="Statement">case</span> ERROR_CANNOT_MAKE:<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">EACCES</span>; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">case</span> ERROR_CURRENT_DIRECTORY: <span class="Statement">case</span> ERROR_BUSY:<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">EBUSY</span>; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">case</span> ERROR_NOT_SAME_DEVICE:<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">EXDEV</span>; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">case</span> ERROR_ALREADY_EXISTS:<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">EEXIST</span>; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">EINVAL</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L845">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_win32_unlink</span>(<span class="Type">const</span> <span class="Type">wchar_t</span> * path) {<br/></li>
<li>&nbsp; <span class="Type">int</span> ret;<br/></li>
<li><br/></li>
<li>&nbsp; ret = _wunlink(path);<br/></li>
<li>&nbsp; <span class="Comment">/* On Windows, trying to unlink a symlink to a directory will return<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * EACCES, but the symlink can be deleted with rmdir. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (ret == -<span class="Constant">1</span> &amp;&amp; errno == <span class="Constant">EACCES</span>) {<br/></li>
<li>&nbsp; &nbsp; HANDLE h;<br/></li>
<li>&nbsp; &nbsp; DWORD attrs, dummy;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">char</span> raw[<span class="Constant">16384</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/winsupport.h.html#L60" title="ocaml/runtime/caml/winsupport.h:60">REPARSE_DATA_BUFFER</a> point;<br/></li>
<li>&nbsp; &nbsp; } buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrs = GetFileAttributes(path);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attrs == INVALID_FILE_ATTRIBUTES ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(attrs &amp; (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; h = CreateFile(path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FILE_READ_ATTRIBUTES,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OPEN_EXISTING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (h == INVALID_HANDLE_VALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, <span class="Constant">0</span>, &amp;buffer.point,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(buffer.raw), &amp;dummy, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; &nbsp; CloseHandle(h);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ret || buffer.point.ReparseTag != IO_REPARSE_TAG_SYMLINK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = _wrmdir(path);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; errno = <span class="Constant">EACCES</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Windows Unicode support */<br/></li>
<li><a id="L888">&#x200c;</a></span><span class="Type">static</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">windows_unicode_enabled</span> = WINDOWS_UNICODE;<br/></li>
<li><br/></li>
<li><span class="Comment">/* If [<a href="#L897" title="ocaml/runtime/win32.c:897">windows_unicode_strict</a>] is non-zero, then illegal UTF-8 characters (on<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the OCaml side) <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> illegal UTF-16 characters (on the Windows side) cause an<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> to be signaled.&nbsp; What happens then depends on the variable<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L902" title="ocaml/runtime/win32.c:902">windows_unicode_fallback</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If [<a href="#L897" title="ocaml/runtime/win32.c:897">windows_unicode_strict</a>] is zero, then illegal characters are silently<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; dropped. */<br/></li>
<li><a id="L897">&#x200c;</a></span><span class="Type">static</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">windows_unicode_strict</span> = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* If [<a href="#L902" title="ocaml/runtime/win32.c:902">windows_unicode_fallback</a>] is non-zero, then if an <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> is signaled when<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; translating to UTF-16, the translation is re-done under the assumption that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the argument string is encoded in the local codepage. */<br/></li>
<li><a id="L902">&#x200c;</a></span><span class="Type">static</span> <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> <span class="linkable">windows_unicode_fallback</span> = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><a id="L904">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_win32_multi_byte_to_wide_char</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">int</span> slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">wchar_t</span> *out, <span class="Type">int</span> outlen)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (s != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (slen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L888" title="ocaml/runtime/win32.c:888">windows_unicode_enabled</a> != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; retcode =<br/></li>
<li>&nbsp; &nbsp; &nbsp; MultiByteToWideChar(CP_UTF8,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L897" title="ocaml/runtime/win32.c:897">windows_unicode_strict</a> ? MB_ERR_INVALID_CHARS : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s, slen, out, outlen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retcode == <span class="Constant">0</span> &amp;&amp; <a href="#L902" title="ocaml/runtime/win32.c:902">windows_unicode_fallback</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; retcode = MultiByteToWideChar(CP_ACP, <span class="Constant">0</span>, s, slen, out, outlen);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; retcode = MultiByteToWideChar(CP_ACP, <span class="Constant">0</span>, s, slen, out, outlen);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (retcode == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="ocaml/runtime/win32.c:78">caml_win32_sys_error</a>(GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> retcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* For old versions of Windows we simply ignore the flag */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L933" title="ocaml/runtime/win32.c:933">WC_ERR_INVALID_CHARS</a><br/></li>
<li><a id="L933">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WC_ERR_INVALID_CHARS</span> </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L936">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_win32_wide_char_to_multi_byte</span>(<span class="Type">const</span> <span class="Type">wchar_t</span> *s, <span class="Type">int</span> slen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *out, <span class="Type">int</span> outlen)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(s != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (slen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L888" title="ocaml/runtime/win32.c:888">windows_unicode_enabled</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; retcode =<br/></li>
<li>&nbsp; &nbsp; &nbsp; WideCharToMultiByte(CP_UTF8,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L897" title="ocaml/runtime/win32.c:897">windows_unicode_strict</a> ? <a href="#L933" title="ocaml/runtime/win32.c:933">WC_ERR_INVALID_CHARS</a> : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s, slen, out, outlen, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; retcode =<br/></li>
<li>&nbsp; &nbsp; &nbsp; WideCharToMultiByte(CP_ACP, <span class="Constant">0</span>, s, slen, out, outlen, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (retcode == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="ocaml/runtime/win32.c:78">caml_win32_sys_error</a>(GetLastError());<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> retcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L961">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_copy_string_of_utf16</span>(<span class="Type">const</span> <span class="Type">wchar_t</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode, slen;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> v;<br/></li>
<li><br/></li>
<li>&nbsp; slen = wcslen(s);<br/></li>
<li>&nbsp; <span class="Comment">/* Do not include <a href="caml/finalise.h.html#L24" title="ocaml/runtime/caml/finalise.h:24">final</a> <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a> */<br/></li>
<li></span>&nbsp; retcode = <a href="#L936" title="ocaml/runtime/win32.c:936">caml_win32_wide_char_to_multi_byte</a>(s, slen, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; v = <a href="alloc.c.html#L177" title="ocaml/runtime/alloc.c:177">caml_alloc_string</a>(retcode);<br/></li>
<li>&nbsp; <a href="#L936" title="ocaml/runtime/win32.c:936">caml_win32_wide_char_to_multi_byte</a>(s, slen, (<span class="Type">char</span> *)<a href="caml/mlvalues.h.html#L329" title="ocaml/runtime/caml/mlvalues.h:329">String_val</a>(v), retcode);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> v;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L975">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">wchar_t</span>* <span class="linkable">caml_stat_strdup_to_utf16</span>(<span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">wchar_t</span> * ws;<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode;<br/></li>
<li><br/></li>
<li>&nbsp; retcode = <a href="#L904" title="ocaml/runtime/win32.c:904">caml_win32_multi_byte_to_wide_char</a>(s, -<span class="Constant">1</span>, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; ws = <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a>(retcode * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(*ws));<br/></li>
<li>&nbsp; <a href="#L904" title="ocaml/runtime/win32.c:904">caml_win32_multi_byte_to_wide_char</a>(s, -<span class="Constant">1</span>, ws, retcode);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> ws;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L987">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> <span class="linkable">caml_stat_strdup_of_utf16</span>(<span class="Type">const</span> <span class="Type">wchar_t</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L141" title="ocaml/runtime/caml/memory.h:141">caml_stat_string</a> out;<br/></li>
<li>&nbsp; <span class="Type">int</span> retcode;<br/></li>
<li><br/></li>
<li>&nbsp; retcode = <a href="#L936" title="ocaml/runtime/win32.c:936">caml_win32_wide_char_to_multi_byte</a>(s, -<span class="Constant">1</span>, <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; out = <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(retcode);<br/></li>
<li>&nbsp; <a href="#L936" title="ocaml/runtime/win32.c:936">caml_win32_wide_char_to_multi_byte</a>(s, -<span class="Constant">1</span>, out, retcode);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> out;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L999">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_probe_win32_version</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* Determine the version of Windows we're running, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> cache it */<br/></li>
<li></span>&nbsp; WCHAR fileName[MAX_PATH];<br/></li>
<li>&nbsp; DWORD size =<br/></li>
<li>&nbsp; &nbsp; GetModuleFileName(GetModuleHandle(<span class="Constant">L&quot;kernel32&quot;</span>), fileName, MAX_PATH);<br/></li>
<li>&nbsp; DWORD dwHandle = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; BYTE* versionInfo;<br/></li>
<li>&nbsp; fileName[size] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; size = GetFileVersionInfoSize(fileName, &amp;dwHandle);<br/></li>
<li>&nbsp; versionInfo = (BYTE*)malloc(size * <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(BYTE));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (GetFileVersionInfo(fileName, <span class="Constant">0</span>, size, versionInfo)) {<br/></li>
<li>&nbsp; &nbsp; UINT len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; VS_FIXEDFILEINFO* vsfi = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; VerQueryValue(versionInfo, <span class="Constant">L&quot;</span><span class="Special">\\</span><span class="Constant">&quot;</span>, (<span class="Type">void</span>**)&amp;vsfi, &amp;len);<br/></li>
<li>&nbsp; &nbsp; <a href="#L69" title="ocaml/runtime/win32.c:69">caml_win32_major</a> = HIWORD(vsfi-&gt;dwProductVersionMS);<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="ocaml/runtime/win32.c:70">caml_win32_minor</a> = LOWORD(vsfi-&gt;dwProductVersionMS);<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="ocaml/runtime/win32.c:71">caml_win32_build</a> = HIWORD(vsfi-&gt;dwProductVersionLS);<br/></li>
<li>&nbsp; &nbsp; <a href="#L72" title="ocaml/runtime/win32.c:72">caml_win32_revision</a> = LOWORD(vsfi-&gt;dwProductVersionLS);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; free(versionInfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1022">&#x200c;</a><span class="Type">static</span> UINT <span class="linkable">startup_codepage</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L1024">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_setup_win32_terminal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L69" title="ocaml/runtime/win32.c:69">caml_win32_major</a> &gt;= <span class="Constant">10</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L1022" title="ocaml/runtime/win32.c:1022">startup_codepage</a> = GetConsoleOutputCP();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1022" title="ocaml/runtime/win32.c:1022">startup_codepage</a> != CP_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; SetConsoleOutputCP(CP_UTF8);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1033">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_restore_win32_terminal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L1022" title="ocaml/runtime/win32.c:1022">startup_codepage</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; SetConsoleOutputCP(<a href="#L1022" title="ocaml/runtime/win32.c:1022">startup_codepage</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Detect if a named pipe corresponds to a Cygwin/MSYS pty: see<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; https://github.com/mirror/newlib-cygwin/blob/00e9bf2/winsup/cygwin/dtable.cc#L932<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><span class="Type">typedef<br/></li>
<li><a id="L1043">&#x200c;</a></span>BOOL (WINAPI *<span class="linkable">tGetFileInformationByHandleEx</span>)(HANDLE, FILE_INFO_BY_HANDLE_CLASS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LPVOID, DWORD);<br/></li>
<li><br/></li>
<li><a id="L1046">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">caml_win32_is_cygwin_pty</span>(HANDLE hFile)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">char</span> buffer[<span class="Constant">1024</span>];<br/></li>
<li>&nbsp; FILE_NAME_INFO * nameinfo = (FILE_NAME_INFO *) buffer;<br/></li>
<li>&nbsp; <span class="Type">static</span> <a href="#L1043" title="ocaml/runtime/win32.c:1043">tGetFileInformationByHandleEx</a> pGetFileInformationByHandleEx =<br/></li>
<li>&nbsp; &nbsp; INVALID_HANDLE_VALUE;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (pGetFileInformationByHandleEx == INVALID_HANDLE_VALUE)<br/></li>
<li>&nbsp; &nbsp; pGetFileInformationByHandleEx =<br/></li>
<li>&nbsp; &nbsp; &nbsp; (<a href="#L1043" title="ocaml/runtime/win32.c:1043">tGetFileInformationByHandleEx</a>)GetProcAddress(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GetModuleHandle(<span class="Constant">L&quot;KERNEL32.DLL&quot;</span>), <span class="Constant">&quot;GetFileInformationByHandleEx&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (pGetFileInformationByHandleEx == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Get pipe name. GetFileInformationByHandleEx does not <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a>-terminate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; string, so reduce the buffer size to allow for adding one. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (! pGetFileInformationByHandleEx(hFile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FileNameInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(buffer) - <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(WCHAR)))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; nameinfo-&gt;FileName[nameinfo-&gt;FileNameLength / <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(WCHAR)] = <span class="Special">L'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* check if this could be a msys pty pipe ('msys-XXXX-ptyN-XX')<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> a cygwin pty pipe ('cygwin-XXXX-ptyN-XX') */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> ((wcsstr(nameinfo-&gt;FileName, <span class="Constant">L&quot;msys-&quot;</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; wcsstr(nameinfo-&gt;FileName, <span class="Constant">L&quot;cygwin-&quot;</span>)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wcsstr(nameinfo-&gt;FileName, <span class="Constant">L&quot;-pty&quot;</span>))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1081">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_win32_isatty</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; DWORD lpMode;<br/></li>
<li>&nbsp; HANDLE hFile = (HANDLE)_get_osfhandle(fd);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (hFile == INVALID_HANDLE_VALUE)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">switch</span> (GetFileType(hFile)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> FILE_TYPE_CHAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Both console handles <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> the NUL device are FILE_TYPE_CHAR.&nbsp; The NUL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; device returns FALSE for a GetConsoleMode call. _isatty incorrectly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; only uses GetFileType (see GPR#1321). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> GetConsoleMode(hFile, &amp;lpMode);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> FILE_TYPE_PIPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Cygwin PTYs are implemented using named pipes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1046" title="ocaml/runtime/win32.c:1046">caml_win32_is_cygwin_pty</a>(hFile);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1105">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_num_rows_fd</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* UCRT clock function returns wall-clock time */<br/></li>
<li><a id="L1111">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">clock_t</span> <span class="linkable">caml_win32_clock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; FILETIME _creation, _exit;<br/></li>
<li>&nbsp; <a href="caml/winsupport.h.html#L66" title="ocaml/runtime/caml/winsupport.h:66">CAML_ULONGLONG_FILETIME</a> stime, utime;<br/></li>
<li>&nbsp; ULARGE_INTEGER tmp;<br/></li>
<li>&nbsp; ULONGLONG clocks_per_sec;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (!(GetProcessTimes(GetCurrentProcess(), &amp;_creation, &amp;_exit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;stime.ft, &amp;utime.ft))) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">clock_t</span>)(-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* total in 100-nanosecond intervals (1e7 / CLOCKS_PER_SEC) */<br/></li>
<li></span>&nbsp; clocks_per_sec = <span class="Constant">10000000ULL</span> / (ULONGLONG)<span class="Constant">CLOCKS_PER_SEC</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<span class="Type">clock_t</span>)((stime.ul + utime.ul) / clocks_per_sec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1128">&#x200c;</a><span class="Type">static</span> <span class="Type">double</span> <span class="linkable">clock_period</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L1130">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_init_os_params</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; SYSTEM_INFO si;<br/></li>
<li>&nbsp; LARGE_INTEGER frequency;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Get the system page size <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> allocation granularity. */<br/></li>
<li></span>&nbsp; GetSystemInfo(&amp;si);<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(si.dwAllocationGranularity &gt;= si.dwPageSize);<br/></li>
<li>&nbsp; <a href="platform.c.html#L141" title="ocaml/runtime/platform.c:141">caml_plat_pagesize</a> = si.dwPageSize;<br/></li>
<li>&nbsp; <a href="platform.c.html#L142" title="ocaml/runtime/platform.c:142">caml_plat_mmap_alignment</a> = si.dwAllocationGranularity;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Get the number of nanoseconds for each tick in QueryPerformanceCounter */<br/></li>
<li></span>&nbsp; QueryPerformanceFrequency(&amp;frequency);<br/></li>
<li>&nbsp; <a href="#L1128" title="ocaml/runtime/win32.c:1128">clock_period</a> = (<span class="Constant">1000000000.0</span> / frequency.QuadPart);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1146">&#x200c;</a><span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span> <span class="linkable">caml_time_counter</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; LARGE_INTEGER now;<br/></li>
<li><br/></li>
<li>&nbsp; QueryPerformanceCounter(&amp;now);<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<span class="Type"><a href="caml/config.h.html#L127" title="ocaml/runtime/caml/config.h:127">int64_t</a></span>)(now.QuadPart * <a href="#L1128" title="ocaml/runtime/win32.c:1128">clock_period</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1154">&#x200c;</a><span class="Type">void</span> *<span class="linkable">caml_plat_mem_map</span>(<a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> alignment, <span class="Type">int</span> reserve_only)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Comment">/* VirtualAlloc returns an address aligned to <a href="platform.c.html#L142" title="ocaml/runtime/platform.c:142">caml_plat_mmap_alignment</a>, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; trimming will not be required. VirtualAlloc returns 0 on <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (alignment &gt; <a href="platform.c.html#L142" title="ocaml/runtime/platform.c:142">caml_plat_mmap_alignment</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a>(<span class="Constant">&quot;Cannot align memory to %&quot;</span> <a href="caml/config.h.html#L142" title="ocaml/runtime/caml/config.h:142">ARCH_INTNAT_PRINTF_FORMAT</a> <span class="Constant">&quot;x&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; on this platform&quot;</span>, alignment);<br/></li>
<li>&nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; VirtualAlloc(<span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MEM_RESERVE | (reserve_only ? <span class="Constant">0</span> : MEM_COMMIT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reserve_only ? PAGE_NOACCESS : PAGE_READWRITE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1167">&#x200c;</a><span class="Type">void</span>* <span class="linkable">caml_plat_mem_commit</span>(<span class="Type">void</span>* mem, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> VirtualAlloc(mem, size, MEM_COMMIT, PAGE_READWRITE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1172">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_plat_mem_decommit</span>(<span class="Type">void</span>* mem, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; VirtualFree(mem, size, MEM_DECOMMIT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1177">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_plat_mem_unmap</span>(<span class="Type">void</span>* mem, <a href="caml/config.h.html#L141" title="ocaml/runtime/caml/config.h:141">uintnat</a> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!VirtualFree(mem, <span class="Constant">0</span>, MEM_RELEASE))<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
