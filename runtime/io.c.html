<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/runtime/io.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/runtime/io.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L103">caml_all_opened_channels</a></li>
<li><a href="#L107">caml_all_opened_channels_mutex</a></li>
<li><a href="#L93">caml_channel_mutex_free</a></li>
<li><a href="#L95">caml_channel_mutex_lock</a></li>
<li><a href="#L97">caml_channel_mutex_unlock</a></li>
<li><a href="#L99">caml_channel_mutex_unlock_exn</a></li>
<li><a href="#L554">channel_operations</a></li>
<li><a href="#L59">last_channel_locked</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L618">channel_list</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L565">caml_alloc_channel</a></li>
<li><a href="#L227">caml_channel_binary_mode</a></li>
<li><a href="#L665">caml_channel_descriptor</a></li>
<li><a href="#L202">caml_channel_size</a></li>
<li><a href="#L193">caml_close_channel</a></li>
<li><a href="#L339">caml_do_read</a></li>
<li><a href="#L499">caml_finalize_channel</a></li>
<li><a href="#L261">caml_flush</a></li>
<li><a href="#L239">caml_flush_partial</a></li>
<li><a href="#L387">caml_getblock</a></li>
<li><a href="#L368">caml_getch</a></li>
<li><a href="#L373">caml_getword</a></li>
<li><a href="#L452">caml_input_scan_line</a></li>
<li><a href="#L725">caml_ml_channel_size</a></li>
<li><a href="#L732">caml_ml_channel_size_64</a></li>
<li><a href="#L672">caml_ml_close_channel</a></li>
<li><a href="#L770">caml_ml_flush</a></li>
<li><a href="#L927">caml_ml_input</a></li>
<li><a href="#L900">caml_ml_input_char</a></li>
<li><a href="#L912">caml_ml_input_int</a></li>
<li><a href="#L1010">caml_ml_input_scan_line</a></li>
<li><a href="#L798">caml_ml_is_buffered</a></li>
<li><a href="#L585">caml_ml_open_descriptor_in</a></li>
<li><a href="#L574">caml_ml_open_descriptor_in_with_flags</a></li>
<li><a href="#L600">caml_ml_open_descriptor_out</a></li>
<li><a href="#L589">caml_ml_open_descriptor_out_with_flags</a></li>
<li><a href="#L623">caml_ml_out_channels_list</a></li>
<li><a href="#L849">caml_ml_output</a></li>
<li><a href="#L828">caml_ml_output_bytes</a></li>
<li><a href="#L804">caml_ml_output_char</a></li>
<li><a href="#L816">caml_ml_output_int</a></li>
<li><a href="#L987">caml_ml_pos_in</a></li>
<li><a href="#L999">caml_ml_pos_in_64</a></li>
<li><a href="#L877">caml_ml_pos_out</a></li>
<li><a href="#L889">caml_ml_pos_out_64</a></li>
<li><a href="#L965">caml_ml_seek_in</a></li>
<li><a href="#L976">caml_ml_seek_in_64</a></li>
<li><a href="#L855">caml_ml_seek_out</a></li>
<li><a href="#L866">caml_ml_seek_out_64</a></li>
<li><a href="#L737">caml_ml_set_binary_mode</a></li>
<li><a href="#L782">caml_ml_set_buffered</a></li>
<li><a href="#L604">caml_ml_set_channel_name</a></li>
<li><a href="#L164">caml_open_descriptor_in</a></li>
<li><a href="#L184">caml_open_descriptor_out</a></li>
<li><a href="#L447">caml_pos_in</a></li>
<li><a href="#L332">caml_pos_out</a></li>
<li><a href="#L288">caml_putblock</a></li>
<li><a href="#L273">caml_putch</a></li>
<li><a href="#L278">caml_putword</a></li>
<li><a href="#L416">caml_really_getblock</a></li>
<li><a href="#L309">caml_really_putblock</a></li>
<li><a href="#L348">caml_refill</a></li>
<li><a href="#L429">caml_seek_in</a></li>
<li><a href="#L320">caml_seek_out</a></li>
<li><a href="#L1022">caml_terminfo_rows</a></li>
<li><a href="#L61">channel_mutex_free_default</a></li>
<li><a href="#L66">channel_mutex_lock_default</a></li>
<li><a href="#L80">channel_mutex_unlock_default</a></li>
<li><a href="#L86">channel_mutex_unlock_exn_default</a></li>
<li><a href="#L115">check_pending</a></li>
<li><a href="#L542">compare_channel</a></li>
<li><a href="#L129">descriptor_is_in_binary_mode</a></li>
<li><a href="#L549">hash_channel</a></li>
<li><a href="#L140">link_channel</a></li>
<li><a href="#L713">ml_channel_size</a></li>
<li><a href="#L149">unlink_channel</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L16">CAML_INTERNALS</a></li>
<li><a href="#L710">EOVERFLOW</a></li>
<li><a href="#L363">Getch</a></li>
<li><a href="#L268">Putch</a></li>
<li><a href="#L48">SEEK_CUR</a></li>
<li><a href="#L49">SEEK_END</a></li>
<li><a href="#L47">SEEK_SET</a></li>
<li><a href="#L54">lseek</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><a id="L16">&#x200c;</a><span class="PreProc">#define <span class="linkable">CAML_INTERNALS</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Buffered input/output. */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/config.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef HAS_UNISTD<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef __CYGWIN__<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;/usr/include/io.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/alloc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/camlatomic.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/custom.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/fail.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/io.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/misc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/mlvalues.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/osdeps.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/platform.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/signals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/sys.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L47" title="ocaml/runtime/io.c:47">SEEK_SET</a><br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SEEK_SET</span></span><span class="PreProc"> </span><span class="Constant">0<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SEEK_CUR</span></span><span class="PreProc"> </span><span class="Constant">1<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">SEEK_END</span></span><span class="PreProc"> </span><span class="Constant">2<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if defined(_WIN32)<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;io.h&gt;<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">lseek</span> _lseeki64<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Hooks for locking channels */<br/></li>
<li></span><br/></li>
<li><a id="L59">&#x200c;</a><span class="Type">static</span> __thread <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>* <span class="linkable">last_channel_locked</span> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><a id="L61">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">channel_mutex_free_default</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *chan)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="platform.c.html#L85" title="ocaml/runtime/platform.c:85">caml_plat_mutex_free</a>(&amp;chan-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L66">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">channel_mutex_lock_default</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *chan)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span>( <a href="caml/platform.h.html#L161" title="ocaml/runtime/caml/platform.h:161">caml_plat_try_lock</a>(&amp;chan-&gt;mutex) ) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="ocaml/runtime/io.c:59">last_channel_locked</a> = chan;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* If unsuccessful, block on mutex */<br/></li>
<li></span>&nbsp; <a href="signals.c.html#L145" title="ocaml/runtime/signals.c:145">caml_enter_blocking_section</a>();<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a>(&amp;chan-&gt;mutex);<br/></li>
<li>&nbsp; <a href="#L59" title="ocaml/runtime/io.c:59">last_channel_locked</a> = chan;<br/></li>
<li>&nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L80">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">channel_mutex_unlock_default</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *chan)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a>(&amp;chan-&gt;mutex);<br/></li>
<li>&nbsp; <a href="#L59" title="ocaml/runtime/io.c:59">last_channel_locked</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L86">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">channel_mutex_unlock_exn_default</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * chan = <a href="#L59" title="ocaml/runtime/io.c:59">last_channel_locked</a>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (chan != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> &amp;&amp; <a href="#L97" title="ocaml/runtime/io.c:97">caml_channel_mutex_unlock</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="ocaml/runtime/io.c:97">caml_channel_mutex_unlock</a>(chan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L93">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_channel_mutex_free</span>) (<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *)<br/></li>
<li>&nbsp; = <a href="#L61" title="ocaml/runtime/io.c:61">channel_mutex_free_default</a>;<br/></li>
<li><a id="L95">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_channel_mutex_lock</span>) (<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *)<br/></li>
<li>&nbsp; = <a href="#L66" title="ocaml/runtime/io.c:66">channel_mutex_lock_default</a>;<br/></li>
<li><a id="L97">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_channel_mutex_unlock</span>) (<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *)<br/></li>
<li>&nbsp; = <a href="#L80" title="ocaml/runtime/io.c:80">channel_mutex_unlock_default</a>;<br/></li>
<li><a id="L99">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> (*<span class="linkable">caml_channel_mutex_unlock_exn</span>) (<span class="Type">void</span>)<br/></li>
<li>&nbsp; = <a href="#L86" title="ocaml/runtime/io.c:86">channel_mutex_unlock_exn_default</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* List of channels opened from the OCaml side <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> managed by the GC */<br/></li>
<li><a id="L103">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <span class="linkable">caml_all_opened_channels</span> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The mutex protecting the list above */<br/></li>
<li></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/platform.h.html#L100" title="ocaml/runtime/caml/platform.h:100">caml_plat_mutex</a><br/></li>
<li><a id="L107">&#x200c;</a>&nbsp; <span class="linkable">caml_all_opened_channels_mutex</span> = <a href="caml/platform.h.html#L101" title="ocaml/runtime/caml/platform.h:101">CAML_PLAT_MUTEX_INITIALIZER</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Basic functions over type struct <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; These functions can be called directly from C.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; No locking is performed. */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Functions shared between input <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> output */<br/></li>
<li></span><br/></li>
<li><a id="L115">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">check_pending</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="signals.c.html#L295" title="ocaml/runtime/signals.c:295">caml_check_pending_actions</a>()) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Temporarily unlock the <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, to ensure locks are not held<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; while any signal handlers (<a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> finalisers, etc) are running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Don't do this for channels allocated <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> used from C,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; as their locks may <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> may not be taken depending on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="sak.c.html#L60" title="ocaml/runtime/sak.c:60">usage</a> pattern in the C code. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_FLAG_MANAGED_BY_GC) <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L360" title="ocaml/runtime/signals.c:360">caml_process_pending_actions</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_FLAG_MANAGED_BY_GC) <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L129">&#x200c;</a><a href="caml/config.h.html#L42" title="ocaml/runtime/caml/config.h:42">Caml_inline</a> <span class="Type">int</span> <span class="linkable">descriptor_is_in_binary_mode</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(_WIN32) || defined(__CYGWIN__)<br/></li>
<li></span>&nbsp; <span class="Type">int</span> oldmode = setmode(fd, <a href="sys.c.html#L212" title="ocaml/runtime/sys.c:212">O_TEXT</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (oldmode != -<span class="Constant">1</span> &amp;&amp; oldmode != <a href="sys.c.html#L212" title="ocaml/runtime/sys.c:212">O_TEXT</a>) setmode(fd, oldmode);<br/></li>
<li>&nbsp; <span class="Statement">return</span> oldmode == <a href="sys.c.html#L209" title="ocaml/runtime/sys.c:209">O_BINARY</a>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><a id="L140">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">link_channel</span> (<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>* <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;next = <a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a>;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;prev == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a>-&gt;prev = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li>&nbsp; <a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a> = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L149">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">unlink_channel</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;prev == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> == <a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a> = <a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a>-&gt;next;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a>-&gt;prev = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;prev-&gt;next = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;next;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;next != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;next-&gt;prev = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;prev;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;next = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;prev = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L164">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <span class="linkable">caml_open_descriptor_in</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = (<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *) <a href="memory.c.html#L550" title="ocaml/runtime/memory.c:550">caml_stat_alloc</a>(<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd = fd;<br/></li>
<li>&nbsp; <a href="signals.c.html#L161" title="ocaml/runtime/signals.c:161">caml_enter_blocking_section_no_pending</a>();<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset = <a href="#L54" title="ocaml/runtime/io.c:54">lseek</a>(fd, <span class="Constant">0</span>, <span class="Constant"><a href="#L48" title="ocaml/runtime/io.c:48">SEEK_CUR</a></span>);<br/></li>
<li>&nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff + <a href="caml/io.h.html#L29" title="ocaml/runtime/caml/io.h:29">IO_BUFFER_SIZE</a>;<br/></li>
<li>&nbsp; <a href="platform.c.html#L47" title="ocaml/runtime/platform.c:47">caml_plat_mutex_init</a>(&amp;<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;mutex);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;refcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;prev = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;next = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;name = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags = <a href="#L129" title="ocaml/runtime/io.c:129">descriptor_is_in_binary_mode</a>(fd) ? <span class="Constant">0</span> : CHANNEL_TEXT_MODE;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L184">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <span class="linkable">caml_open_descriptor_out</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="#L164" title="ocaml/runtime/io.c:164">caml_open_descriptor_in</a>(fd);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L193">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_close_channel</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>((<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_FLAG_MANAGED_BY_GC) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; close(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L93" title="ocaml/runtime/io.c:93">caml_channel_mutex_free</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) (*<a href="#L93" title="ocaml/runtime/io.c:93">caml_channel_mutex_free</a>)(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;name);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L202">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> <span class="linkable">caml_channel_size</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> here, end;<br/></li>
<li>&nbsp; <span class="Type">int</span> fd;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="#L115" title="ocaml/runtime/io.c:115">check_pending</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <span class="Comment">/* We extract data from [<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>] before dropping the OCaml lock, in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; someone else touches the block. */<br/></li>
<li></span>&nbsp; fd = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd;<br/></li>
<li>&nbsp; here = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_TEXT_MODE ? -<span class="Constant">1</span> : <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset;<br/></li>
<li>&nbsp; <a href="signals.c.html#L161" title="ocaml/runtime/signals.c:161">caml_enter_blocking_section_no_pending</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (here == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; here = <a href="#L54" title="ocaml/runtime/io.c:54">lseek</a>(fd, <span class="Constant">0</span>, <span class="Constant"><a href="#L48" title="ocaml/runtime/io.c:48">SEEK_CUR</a></span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (here == -<span class="Constant">1</span>) <span class="Statement">goto</span> <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; end = <a href="#L54" title="ocaml/runtime/io.c:54">lseek</a>(fd, <span class="Constant">0</span>, <span class="Constant"><a href="#L49" title="ocaml/runtime/io.c:49">SEEK_END</a></span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (end == -<span class="Constant">1</span>) <span class="Statement">goto</span> <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L54" title="ocaml/runtime/io.c:54">lseek</a>(fd, here, <span class="Constant"><a href="#L47" title="ocaml/runtime/io.c:47">SEEK_SET</a></span>) != here) <span class="Statement">goto</span> <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a>;<br/></li>
<li>&nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; <span class="Statement">return</span> end;<br/></li>
<li> <span class="Statement"><a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a></span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L227">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_channel_binary_mode</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_TEXT_MODE ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Output */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Attempt to flush the buffer. This will make room in the buffer for<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; at least one character. Returns true if the buffer is empty at the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; end of the flush, <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> false if some data remains in the buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L239">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_flush_partial</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> towrite, written;<br/></li>
<li> <span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="#L115" title="ocaml/runtime/io.c:115">check_pending</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li><br/></li>
<li>&nbsp; towrite = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff;<br/></li>
<li>&nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a> (towrite &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (towrite &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; written = <a href="unix.c.html#L99" title="ocaml/runtime/unix.c:99">caml_write_fd</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff, towrite);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (written == <a href="caml/osdeps.h.html#L35" title="ocaml/runtime/caml/osdeps.h:35">Io_interrupted</a>) <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset += written;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (written &lt; towrite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; memmove(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff + written, towrite - written);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr -= written;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr == <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Flush completely the buffer. */<br/></li>
<li></span><br/></li>
<li><a id="L261">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_flush</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">while</span> (! <a href="#L239" title="ocaml/runtime/io.c:239">caml_flush_partial</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)) <span class="Comment">/*nothing*/</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Output data */<br/></li>
<li></span><br/></li>
<li><a id="L268">&#x200c;</a><span class="PreProc">#define <span class="linkable">Putch</span>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, ch) </span><span class="Statement">do</span><span class="PreProc">{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)-&gt;curr &gt;= (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)-&gt;end) <a href="#L239" title="ocaml/runtime/io.c:239">caml_flush_partial</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);&nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; *((<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)-&gt;curr)++ = (ch);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">}</span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L273">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_putch</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <span class="Type">int</span> ch)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L268" title="ocaml/runtime/io.c:268">Putch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, ch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L278">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_putword</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> w)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (! <a href="#L227" title="ocaml/runtime/io.c:227">caml_channel_binary_mode</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>))<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L130" title="ocaml/runtime/fail_nat.c:130">caml_failwith</a>(<span class="Constant">&quot;output_binary_int: not a binary <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L273" title="ocaml/runtime/io.c:273">caml_putch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, w &gt;&gt; <span class="Constant">24</span>);<br/></li>
<li>&nbsp; <a href="#L273" title="ocaml/runtime/io.c:273">caml_putch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, w &gt;&gt; <span class="Constant">16</span>);<br/></li>
<li>&nbsp; <a href="#L273" title="ocaml/runtime/io.c:273">caml_putch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, w &gt;&gt; <span class="Constant">8</span>);<br/></li>
<li>&nbsp; <a href="#L273" title="ocaml/runtime/io.c:273">caml_putch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, w);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L288">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_putblock</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <span class="Type">char</span> *p, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> n, free;<br/></li>
<li><br/></li>
<li>&nbsp; n = len &gt;= <span class="Constant">INT_MAX</span> ? <span class="Constant">INT_MAX</span> : (<span class="Type">int</span>) len;<br/></li>
<li>&nbsp; free = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (n &lt; free) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write request small enough to fit in buffer: transfer to buffer. */<br/></li>
<li></span>&nbsp; &nbsp; memmove(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr, p, n);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr += n;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write request overflows buffer (<a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> just fills it up): transfer whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; fits to buffer <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> write the buffer */<br/></li>
<li></span>&nbsp; &nbsp; memmove(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr, p, free);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end;<br/></li>
<li>&nbsp; &nbsp; <a href="#L239" title="ocaml/runtime/io.c:239">caml_flush_partial</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> free;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L309">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_really_putblock</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *p, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> written;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; written = <a href="#L288" title="ocaml/runtime/io.c:288">caml_putblock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, p, len);<br/></li>
<li>&nbsp; &nbsp; p += written;<br/></li>
<li>&nbsp; &nbsp; len -= written;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L320">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_seek_out</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="#L261" title="ocaml/runtime/io.c:261">caml_flush</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="signals.c.html#L161" title="ocaml/runtime/signals.c:161">caml_enter_blocking_section_no_pending</a>();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L54" title="ocaml/runtime/io.c:54">lseek</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd, dest, <span class="Constant"><a href="#L47" title="ocaml/runtime/io.c:47">SEEK_SET</a></span>) != dest) {<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset = dest;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L332">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> <span class="linkable">caml_pos_out</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset + (<a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a>)(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Input */<br/></li>
<li></span><br/></li>
<li><a id="L339">&#x200c;</a><span class="Type">int</span> <span class="linkable">caml_do_read</span>(<span class="Type">int</span> fd, <span class="Type">char</span> *p, <span class="Type">unsigned</span> <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> r;<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; r = <a href="unix.c.html#L86" title="ocaml/runtime/unix.c:86">caml_read_fd</a>(fd, <span class="Constant">0</span>, p, n);<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (r == <a href="caml/osdeps.h.html#L35" title="ocaml/runtime/caml/osdeps.h:35">Io_interrupted</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> r;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L348">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">unsigned</span> <span class="Type">char</span> <span class="linkable">caml_refill</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> n;<br/></li>
<li> <span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="#L115" title="ocaml/runtime/io.c:115">check_pending</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; n = <a href="unix.c.html#L86" title="ocaml/runtime/unix.c:86">caml_read_fd</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (n == <a href="caml/osdeps.h.html#L35" title="ocaml/runtime/caml/osdeps.h:35">Io_interrupted</a>) <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n == <span class="Constant">0</span>) <a href="fail_nat.c.html#L168" title="ocaml/runtime/fail_nat.c:168">caml_raise_end_of_file</a>();<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset += n;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff + n;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<span class="Type">unsigned</span> <span class="Type">char</span>)(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff[<span class="Constant">0</span>]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L363">&#x200c;</a><span class="PreProc">#define <span class="linkable">Getch</span>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; ((<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)-&gt;curr &gt;= (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)-&gt;max&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp;&nbsp; ? <a href="#L348" title="ocaml/runtime/io.c:348">caml_refill</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp;&nbsp; : (</span><span class="Type">unsigned</span><span class="PreProc"> </span><span class="Type">char</span><span class="PreProc">) *((<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)-&gt;curr)++)<br/></li>
<li></span><br/></li>
<li><a id="L368">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">unsigned</span> <span class="Type">char</span> <span class="linkable">caml_getch</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L363" title="ocaml/runtime/io.c:363">Getch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L373">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> <span class="linkable">caml_getword</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span> res;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (! <a href="#L227" title="ocaml/runtime/io.c:227">caml_channel_binary_mode</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>))<br/></li>
<li>&nbsp; &nbsp; <a href="fail_nat.c.html#L130" title="ocaml/runtime/fail_nat.c:130">caml_failwith</a>(<span class="Constant">&quot;input_binary_int: not a binary <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>&quot;</span>);<br/></li>
<li>&nbsp; res = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">for</span>(i = <span class="Constant">0</span>; i &lt; <span class="Constant">4</span>; i++) {<br/></li>
<li>&nbsp; &nbsp; res = (res &lt;&lt; <span class="Constant">8</span>) + <a href="#L363" title="ocaml/runtime/io.c:363">Getch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L387">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">int</span> <span class="linkable">caml_getblock</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <span class="Type">char</span> *p, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> n, avail, nread;<br/></li>
<li> <span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="#L115" title="ocaml/runtime/io.c:115">check_pending</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; n = len &gt;= <span class="Constant">INT_MAX</span> ? <span class="Constant">INT_MAX</span> : (<span class="Type">int</span>) len;<br/></li>
<li>&nbsp; avail = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (n &lt;= avail) {<br/></li>
<li>&nbsp; &nbsp; memmove(p, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr, n);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr += n;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (avail &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; memmove(p, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr, avail);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr += avail;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> avail;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; nread = <a href="unix.c.html#L86" title="ocaml/runtime/unix.c:86">caml_read_fd</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nread == <a href="caml/osdeps.h.html#L35" title="ocaml/runtime/caml/osdeps.h:35">Io_interrupted</a>) <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset += nread;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff + nread;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; nread) n = nread;<br/></li>
<li>&nbsp; &nbsp; memmove(p, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff, n);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff + n;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Returns the number of bytes read. */<br/></li>
<li><a id="L416">&#x200c;</a></span><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">caml_really_getblock</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *chan, <span class="Type">char</span> *p, <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> k = n;<br/></li>
<li>&nbsp; <span class="Type">int</span> r;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (k &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; r = <a href="#L387" title="ocaml/runtime/io.c:387">caml_getblock</a>(chan, p, k);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r == <span class="Constant">0</span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; p += r;<br/></li>
<li>&nbsp; &nbsp; k -= r;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> n - k;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L429">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <span class="Type">void</span> <span class="linkable">caml_seek_in</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (dest &gt;= <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset - (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &amp;&amp; dest &lt;= <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset<br/></li>
<li>&nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_TEXT_MODE) == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max - (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset - dest);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L161" title="ocaml/runtime/signals.c:161">caml_enter_blocking_section_no_pending</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L54" title="ocaml/runtime/io.c:54">lseek</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd, dest, <span class="Constant"><a href="#L47" title="ocaml/runtime/io.c:47">SEEK_SET</a></span>) != dest) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset = dest;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L447">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> <span class="linkable">caml_pos_in</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset - (<a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a>)(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L452">&#x200c;</a><a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">caml_input_scan_line</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">char</span> * p;<br/></li>
<li>&nbsp; <span class="Type">int</span> n;<br/></li>
<li> <span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="#L115" title="ocaml/runtime/io.c:115">check_pending</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; p = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr;<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (p &gt;= <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* No more characters available in the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr &gt; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to make some room in the buffer by shifting the unread<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portion at the beginning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memmove(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr -= n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max -= n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p -= n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max &gt;= <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Buffer is full, no room to read more characters from the input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Return the number of characters in the buffer, with negative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sign to indicate that no newline was encountered. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill the buffer as much as possible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; n = <a href="unix.c.html#L86" title="ocaml/runtime/unix.c:86">caml_read_fd</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n == <a href="caml/osdeps.h.html#L35" title="ocaml/runtime/caml/osdeps.h:35">Io_interrupted</a>) <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End-of-file encountered. Return the number of characters in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffer, with negative sign since we haven't encountered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; a newline. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset += n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max += n;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (*p++ != <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; <span class="Comment">/* Found a newline. Return the length of the line, newline included. */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> (p - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* OCaml entry points for the I/O functions.&nbsp; Wrap struct <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; objects into a heap-allocated object.&nbsp; Perform locking<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> unlocking around the I/O operations. */<br/></li>
<li></span><br/></li>
<li><a id="L499">&#x200c;</a><span class="Type">void</span> <span class="linkable">caml_finalize_channel</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchan)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * chan = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchan);<br/></li>
<li>&nbsp; <span class="Type">int</span> notflushed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> ((chan-&gt;flags &amp; CHANNEL_FLAG_MANAGED_BY_GC) == <span class="Constant">0</span>) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; <span class="Comment">/* Check for channels that have not been closed explicitly. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (chan-&gt;fd != -<span class="Constant">1</span> &amp;&amp; chan-&gt;name &amp;&amp; <a href="misc.c.html#L238" title="ocaml/runtime/misc.c:238">caml_runtime_warnings_active</a>())<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;[ocaml] <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> opened on file '</span><span class="Special">%s</span><span class="Constant">' dies without being closed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chan-&gt;name);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (chan-&gt;max == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span> &amp;&amp; chan-&gt;curr != chan-&gt;buff) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is an unclosed out <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> (chan-&gt;max == <a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a>) with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; non-empty buffer: keep it around so the OCaml [at_exit] function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; gets a chance to flush it.&nbsp; We would want to simply flush the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> now, but (i) flushing can raise exceptions, <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> (ii) it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; is potentially a blocking operation.&nbsp; Both are forbidden in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; finalization function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Refs: https://github.com/ocaml/ocaml/issues/6902<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; https://github.com/ocaml/ocaml/pull/210<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (chan-&gt;name &amp;&amp; <a href="misc.c.html#L238" title="ocaml/runtime/misc.c:238">caml_runtime_warnings_active</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;[ocaml] (moreover, it has unflushed data)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; notflushed = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* Don't run concurrently with <a href="#L623" title="ocaml/runtime/io.c:623">caml_ml_out_channels_list</a> that may resurrect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; a dead <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> . */<br/></li>
<li></span>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li>&nbsp; chan-&gt;refcount --;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (chan-&gt;refcount &gt; <span class="Constant">0</span> || notflushed) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need to keep the <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> around, either because it is being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; added to the list returned by <a href="#L623" title="ocaml/runtime/io.c:623">caml_ml_out_channels_list</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> because it contains unflushed data. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L149" title="ocaml/runtime/io.c:149">unlink_channel</a>(chan);<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L93" title="ocaml/runtime/io.c:93">caml_channel_mutex_free</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) (*<a href="#L93" title="ocaml/runtime/io.c:93">caml_channel_mutex_free</a>)(chan);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(chan-&gt;name);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(chan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L542">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">compare_channel</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchan1, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchan2)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * chan1 = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchan1);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * chan2 = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchan2);<br/></li>
<li>&nbsp; <span class="Statement">return</span> (chan1 == chan2) ? <span class="Constant">0</span> : (chan1 &lt; chan2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L549">&#x200c;</a><span class="Type">static</span> <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> <span class="linkable">hash_channel</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchan)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> (<a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a>) (<a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchan));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L554">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="caml/custom.h.html#L27" title="ocaml/runtime/caml/custom.h:27">custom_operations</a> <span class="linkable">channel_operations</span> = {<br/></li>
<li>&nbsp; <span class="Constant">&quot;_chan&quot;</span>,<br/></li>
<li>&nbsp; <a href="#L499" title="ocaml/runtime/io.c:499">caml_finalize_channel</a>,<br/></li>
<li>&nbsp; <a href="#L542" title="ocaml/runtime/io.c:542">compare_channel</a>,<br/></li>
<li>&nbsp; <a href="#L549" title="ocaml/runtime/io.c:549">hash_channel</a>,<br/></li>
<li>&nbsp; <a href="caml/custom.h.html#L43" title="ocaml/runtime/caml/custom.h:43">custom_serialize_default</a>,<br/></li>
<li>&nbsp; <a href="caml/custom.h.html#L44" title="ocaml/runtime/caml/custom.h:44">custom_deserialize_default</a>,<br/></li>
<li>&nbsp; <a href="caml/custom.h.html#L45" title="ocaml/runtime/caml/custom.h:45">custom_compare_ext_default</a>,<br/></li>
<li>&nbsp; <a href="caml/custom.h.html#L46" title="ocaml/runtime/caml/custom.h:46">custom_fixed_length_default</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L565">&#x200c;</a><a href="caml/misc.h.html#L123" title="ocaml/runtime/caml/misc.h:123">CAMLexport</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_alloc_channel</span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *chan)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> res;<br/></li>
<li>&nbsp; res = <a href="custom.c.html#L90" title="ocaml/runtime/custom.c:90">caml_alloc_custom_mem</a>(&amp;<a href="#L554" title="ocaml/runtime/io.c:554">channel_operations</a>, <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(res) = chan;<br/></li>
<li>&nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L574">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_open_descriptor_in_with_flags</span>(<span class="Type">int</span> fd, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * chan = <a href="#L164" title="ocaml/runtime/io.c:164">caml_open_descriptor_in</a>(fd);<br/></li>
<li>&nbsp; chan-&gt;flags |= flags | CHANNEL_FLAG_MANAGED_BY_GC;<br/></li>
<li>&nbsp; chan-&gt;refcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li>&nbsp; <a href="#L140" title="ocaml/runtime/io.c:140">link_channel</a> (chan);<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L565" title="ocaml/runtime/io.c:565">caml_alloc_channel</a>(chan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L585">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_open_descriptor_in</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> fd) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L574" title="ocaml/runtime/io.c:574">caml_ml_open_descriptor_in_with_flags</a>(<a href="caml/mlvalues.h.html#L82" title="ocaml/runtime/caml/mlvalues.h:82">Int_val</a>(fd), <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L589">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_open_descriptor_out_with_flags</span>(<span class="Type">int</span> fd, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * chan = <a href="#L184" title="ocaml/runtime/io.c:184">caml_open_descriptor_out</a>(fd);<br/></li>
<li>&nbsp; chan-&gt;flags |= flags | CHANNEL_FLAG_MANAGED_BY_GC;<br/></li>
<li>&nbsp; chan-&gt;refcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li>&nbsp; <a href="#L140" title="ocaml/runtime/io.c:140">link_channel</a> (chan);<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L565" title="ocaml/runtime/io.c:565">caml_alloc_channel</a>(chan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L600">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_open_descriptor_out</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> fd) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L589" title="ocaml/runtime/io.c:589">caml_ml_open_descriptor_out_with_flags</a>(<a href="caml/mlvalues.h.html#L82" title="ocaml/runtime/caml/mlvalues.h:82">Int_val</a>(fd), <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L604">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_set_channel_name</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vname)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a>(vchannel, vname);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;name);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="str.c.html#L31" title="ocaml/runtime/str.c:31">caml_string_length</a>(vname) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;name = <a href="memory.c.html#L632" title="ocaml/runtime/memory.c:632">caml_stat_strdup</a>(<a href="caml/mlvalues.h.html#L329" title="ocaml/runtime/caml/mlvalues.h:329">String_val</a>(vname));<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;name = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L618">&#x200c;</a><span class="Type">struct</span> <span class="linkable">channel_list</span> {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>* <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a>* next;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L623">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_out_channels_list</span> (<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> unit)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L270" title="ocaml/runtime/caml/memory.h:270">CAMLparam0</a> ();<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L384" title="ocaml/runtime/caml/memory.h:384">CAMLlocal3</a> (res, tail, chan);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a> *<a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a> = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>, *cl_tmp;<br/></li>
<li>&nbsp; <a href="caml/mlvalues.h.html#L60" title="ocaml/runtime/caml/mlvalues.h:60">mlsize_t</a> i, num_channels = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L155" title="ocaml/runtime/caml/platform.h:155">caml_plat_lock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="#L103" title="ocaml/runtime/io.c:103">caml_all_opened_channels</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> != <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;next) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/misc.h.html#L247" title="ocaml/runtime/caml/misc.h:247">CAMLassert</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_FLAG_MANAGED_BY_GC);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Testing <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd &gt;= 0 looks unnecessary, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="#L672" title="ocaml/runtime/io.c:672">caml_ml_close_channel</a> changes max when setting fd to -1. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* refcount is incremented here to keep the <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> alive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;refcount ++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; num_channels++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; cl_tmp = <a href="memory.c.html#L494" title="ocaml/runtime/memory.c:494">caml_stat_alloc_noexc</a> (<span class="Statement"><a href="caml/fiber.h.html#L65" title="ocaml/runtime/caml/fiber.h:65">sizeof</a></span>(<span class="Type">struct</span> <a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cl_tmp == <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="misc.c.html#L108" title="ocaml/runtime/misc.c:108">caml_fatal_error</a> (<span class="Constant">&quot;<a href="#L623" title="ocaml/runtime/io.c:623">caml_ml_out_channels_list</a>: out of memory&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; cl_tmp-&gt;<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; cl_tmp-&gt;next = <a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a> = cl_tmp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/platform.h.html#L173" title="ocaml/runtime/caml/platform.h:173">caml_plat_unlock</a> (&amp;<a href="#L107" title="ocaml/runtime/io.c:107">caml_all_opened_channels_mutex</a>);<br/></li>
<li><br/></li>
<li>&nbsp; res = <a href="caml/mlvalues.h.html#L434" title="ocaml/runtime/caml/mlvalues.h:434">Val_emptylist</a>;<br/></li>
<li>&nbsp; cl_tmp = <span class="Constant"><a href="caml/misc.h.html#L71" title="ocaml/runtime/caml/misc.h:71">NULL</a></span>;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_channels; i++) {<br/></li>
<li>&nbsp; &nbsp; chan = <a href="#L565" title="ocaml/runtime/io.c:565">caml_alloc_channel</a> (<a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a>-&gt;<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; &nbsp; tail = res;<br/></li>
<li>&nbsp; &nbsp; res = <a href="alloc.c.html#L113" title="ocaml/runtime/alloc.c:113">caml_alloc_2</a>(<a href="caml/mlvalues.h.html#L435" title="ocaml/runtime/caml/mlvalues.h:435">Tag_cons</a>, chan, tail);<br/></li>
<li>&nbsp; &nbsp; cl_tmp = <a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a> = <a href="#L618" title="ocaml/runtime/io.c:618">channel_list</a>-&gt;next;<br/></li>
<li>&nbsp; &nbsp; <a href="memory.c.html#L559" title="ocaml/runtime/memory.c:559">caml_stat_free</a> (cl_tmp);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L665">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_channel_descriptor</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> fd = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel)-&gt;fd;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (fd == -<span class="Constant">1</span>) { errno = <span class="Constant">EBADF</span>; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>); }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(fd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L672">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_close_channel</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a>(vchannel);<br/></li>
<li>&nbsp; <span class="Type">int</span> result;<br/></li>
<li>&nbsp; <span class="Type">int</span> fd;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* For output channels, must have flushed before */<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <span class="Comment">/* Ensure that every read <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> write on the <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> will cause an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; immediate <a href="#L239" title="ocaml/runtime/io.c:239">caml_flush_partial</a> <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> <a href="#L348" title="ocaml/runtime/io.c:348">caml_refill</a>, thus raising a Sys_error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; exception */<br/></li>
<li></span>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end;<br/></li>
<li>&nbsp; <span class="Comment">/* Prevent any seek backward that would <a href="major_gc.c.html#L993" title="ocaml/runtime/major_gc.c:993">mark</a> the last bytes of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> buffer as valid */<br/></li>
<li></span>&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* If already closed, we are done */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd != -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; fd = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L161" title="ocaml/runtime/signals.c:161">caml_enter_blocking_section_no_pending</a>();<br/></li>
<li>&nbsp; &nbsp; result = close(fd);<br/></li>
<li>&nbsp; &nbsp; <a href="signals.c.html#L166" title="ocaml/runtime/signals.c:166">caml_leave_blocking_section</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == -<span class="Constant">1</span>) <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a> (<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L710" title="ocaml/runtime/io.c:710">EOVERFLOW</a> is the Unix98 <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> indicating that a file position <a href="ints.c.html#L491" title="ocaml/runtime/ints.c:491">or</a> file<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; size is not representable.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ERANGE is the ANSI C <a href="startup_byt.c.html#L77" title="ocaml/runtime/startup_byt.c:77">error</a> indicating that some argument to some<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function is out of range.&nbsp; This is less precise than <a href="#L710" title="ocaml/runtime/io.c:710">EOVERFLOW</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; but guaranteed to be defined on all ANSI C environments. */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L710" title="ocaml/runtime/io.c:710">EOVERFLOW</a><br/></li>
<li><a id="L710">&#x200c;</a></span><span class="PreProc">#define </span><span class="Constant"><span class="linkable">EOVERFLOW</span></span><span class="PreProc"> </span><span class="Constant">ERANGE<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L713">&#x200c;</a><span class="Type">static</span> <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> <span class="linkable">ml_channel_size</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> size;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; size = <a href="#L202" title="ocaml/runtime/io.c:202">caml_channel_size</a>(<a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L413" title="ocaml/runtime/caml/memory.h:413">CAMLreturnT</a>(<a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a>, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L725">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_channel_size</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> size = <a href="#L713" title="ocaml/runtime/io.c:713">ml_channel_size</a>(vchannel);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (size &gt; <a href="caml/mlvalues.h.html#L79" title="ocaml/runtime/caml/mlvalues.h:79">Max_long</a>) { errno = <span class="Constant"><a href="#L710" title="ocaml/runtime/io.c:710">EOVERFLOW</a></span>; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>); }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L732">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_channel_size_64</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/io.h.html#L120" title="ocaml/runtime/caml/io.h:120">Val_file_offset</a>(<a href="#L713" title="ocaml/runtime/io.c:713">ml_channel_size</a>(vchannel));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L737">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_set_binary_mode</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a>(vchannel, mode);<br/></li>
<li><span class="PreProc">#if defined(_WIN32) || defined(__CYGWIN__)<br/></li>
<li></span>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li><span class="PreProc">#if defined(_WIN32)<br/></li>
<li></span>&nbsp; <span class="Comment">/* The implementation of [<a href="unix.c.html#L86" title="ocaml/runtime/unix.c:86">caml_read_fd</a>] <a href="ints.c.html#L488" title="ocaml/runtime/ints.c:488">and</a> [<a href="unix.c.html#L99" title="ocaml/runtime/unix.c:99">caml_write_fd</a>] in win32.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; doesn't support socket I/O with CRLF conversion. */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> ((<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_FLAG_FROM_SOCKET) != <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &amp;&amp; ! <a href="caml/mlvalues.h.html#L424" title="ocaml/runtime/caml/mlvalues.h:424">Bool_val</a>(mode)) {<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">EINVAL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (setmode(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd, <a href="caml/mlvalues.h.html#L424" title="ocaml/runtime/caml/mlvalues.h:424">Bool_val</a>(mode) ? <a href="sys.c.html#L209" title="ocaml/runtime/sys.c:209">O_BINARY</a> : <a href="sys.c.html#L212" title="ocaml/runtime/sys.c:212">O_TEXT</a>) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L424" title="ocaml/runtime/caml/mlvalues.h:424">Bool_val</a>(mode))<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp;= ~CHANNEL_TEXT_MODE;<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags |= CHANNEL_TEXT_MODE;<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If the <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> is closed, DO NOT raise a &quot;bad file descriptor&quot;<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; exception, but do nothing (the buffer is already empty).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This is because some libraries will flush at exit, even on<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; file descriptors that may be closed.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L770">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_flush</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L261" title="ocaml/runtime/io.c:261">caml_flush</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L782">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_set_buffered</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a>(vchannel, mode);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="caml/mlvalues.h.html#L424" title="ocaml/runtime/caml/mlvalues.h:424">Bool_val</a>(mode)) {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp;= ~CHANNEL_FLAG_UNBUFFERED;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags |= CHANNEL_FLAG_UNBUFFERED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L261" title="ocaml/runtime/io.c:261">caml_flush</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a>(<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L798">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_is_buffered</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L423" title="ocaml/runtime/caml/mlvalues.h:423">Val_bool</a>( ! (<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags &amp; CHANNEL_FLAG_UNBUFFERED));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L804">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_output_char</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> ch)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a> (vchannel, ch);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="#L268" title="ocaml/runtime/io.c:268">Putch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(ch));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L115" title="ocaml/runtime/caml/io.h:115">Flush_if_unbuffered</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L816">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_output_int</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> w)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a> (vchannel, w);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="#L278" title="ocaml/runtime/io.c:278">caml_putword</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, (<span class="Type"><a href="caml/config.h.html#L126" title="ocaml/runtime/caml/config.h:126">uint32_t</a></span>) <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(w));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L115" title="ocaml/runtime/caml/io.h:115">Flush_if_unbuffered</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L828">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_output_bytes</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> buff, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L288" title="ocaml/runtime/caml/memory.h:288">CAMLparam4</a> (vchannel, buff, start, length);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> pos = <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(start);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> len = <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(length);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We cannot call <a href="#L309" title="ocaml/runtime/io.c:309">caml_really_putblock</a> here because buff may move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; during <a href="unix.c.html#L99" title="ocaml/runtime/unix.c:99">caml_write_fd</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> written = <a href="#L288" title="ocaml/runtime/io.c:288">caml_putblock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, &amp;<a href="caml/mlvalues.h.html#L315" title="ocaml/runtime/caml/mlvalues.h:315">Byte</a>(buff, pos), len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; pos += written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; len -= written;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L115" title="ocaml/runtime/caml/io.h:115">Flush_if_unbuffered</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L849">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_output</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> buff, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L828" title="ocaml/runtime/io.c:828">caml_ml_output_bytes</a> (vchannel, buff, start, length);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L855">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_seek_out</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a> (vchannel, pos);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="#L320" title="ocaml/runtime/io.c:320">caml_seek_out</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(pos));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L866">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_seek_out_64</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a> (vchannel, pos);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="#L320" title="ocaml/runtime/io.c:320">caml_seek_out</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <a href="caml/io.h.html#L121" title="ocaml/runtime/caml/io.h:121">File_offset_val</a>(pos));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L877">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_pos_out</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> pos;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; pos = <a href="#L332" title="ocaml/runtime/io.c:332">caml_pos_out</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (pos &gt; <a href="caml/mlvalues.h.html#L79" title="ocaml/runtime/caml/mlvalues.h:79">Max_long</a>) { errno = <span class="Constant"><a href="#L710" title="ocaml/runtime/io.c:710">EOVERFLOW</a></span>; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>); }<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(pos));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L889">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_pos_out_64</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> pos;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; pos = <a href="#L332" title="ocaml/runtime/io.c:332">caml_pos_out</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/io.h.html#L120" title="ocaml/runtime/caml/io.h:120">Val_file_offset</a>(pos));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L900">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_input_char</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> c;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; c = <a href="#L363" title="ocaml/runtime/io.c:363">Getch</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(c));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L912">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_input_int</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> i;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; i = <a href="#L373" title="ocaml/runtime/io.c:373">caml_getword</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li><span class="PreProc">#ifdef ARCH_SIXTYFOUR<br/></li>
<li></span>&nbsp; i = (i &lt;&lt; <span class="Constant">32</span>) &gt;&gt; <span class="Constant">32</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force sign extension */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(i));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L927">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_input</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> buff, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vstart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vlength)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L288" title="ocaml/runtime/caml/memory.h:288">CAMLparam4</a> (vchannel, buff, vstart, vlength);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> start, len;<br/></li>
<li>&nbsp; <span class="Type">int</span> n, avail, nread;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li> <span class="Statement">again</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="#L115" title="ocaml/runtime/io.c:115">check_pending</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <span class="Comment">/* We cannot call <a href="#L387" title="ocaml/runtime/io.c:387">caml_getblock</a> here because buff may move during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="unix.c.html#L86" title="ocaml/runtime/unix.c:86">caml_read_fd</a> */<br/></li>
<li></span>&nbsp; start = <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(vstart);<br/></li>
<li>&nbsp; len = <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(vlength);<br/></li>
<li>&nbsp; n = len &gt;= <span class="Constant">INT_MAX</span> ? <span class="Constant">INT_MAX</span> : (<span class="Type">int</span>) len;<br/></li>
<li>&nbsp; avail = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (n &lt;= avail) {<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="caml/mlvalues.h.html#L315" title="ocaml/runtime/caml/mlvalues.h:315">Byte</a>(buff, start), <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr, n);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr += n;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (avail &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="caml/mlvalues.h.html#L315" title="ocaml/runtime/caml/mlvalues.h:315">Byte</a>(buff, start), <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr, avail);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr += avail;<br/></li>
<li>&nbsp; &nbsp; n = avail;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; nread = <a href="unix.c.html#L86" title="ocaml/runtime/unix.c:86">caml_read_fd</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;fd, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;flags, <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;end - <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nread == <a href="caml/osdeps.h.html#L35" title="ocaml/runtime/caml/osdeps.h:35">Io_interrupted</a>) <span class="Statement">goto</span> again;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;offset += nread;<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;max = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff + nread;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; nread) n = nread;<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;<a href="caml/mlvalues.h.html#L315" title="ocaml/runtime/caml/mlvalues.h:315">Byte</a>(buff, start), <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff, n);<br/></li>
<li>&nbsp; &nbsp; <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;curr = <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>-&gt;buff + n;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(n));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L965">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_seek_in</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a> (vchannel, pos);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="#L429" title="ocaml/runtime/io.c:429">caml_seek_in</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <a href="caml/mlvalues.h.html#L78" title="ocaml/runtime/caml/mlvalues.h:78">Long_val</a>(pos));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L976">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_seek_in_64</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel, <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L280" title="ocaml/runtime/caml/memory.h:280">CAMLparam2</a> (vchannel, pos);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="#L429" title="ocaml/runtime/io.c:429">caml_seek_in</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>, <a href="caml/io.h.html#L121" title="ocaml/runtime/caml/io.h:121">File_offset_val</a>(pos));<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L431" title="ocaml/runtime/caml/mlvalues.h:431">Val_unit</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L987">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_pos_in</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> pos;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; pos = <a href="#L447" title="ocaml/runtime/io.c:447">caml_pos_in</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (pos &gt; <a href="caml/mlvalues.h.html#L79" title="ocaml/runtime/caml/mlvalues.h:79">Max_long</a>) { errno = <span class="Constant"><a href="#L710" title="ocaml/runtime/io.c:710">EOVERFLOW</a></span>; <a href="sys.c.html#L93" title="ocaml/runtime/sys.c:93">caml_sys_error</a>(<a href="caml/sys.h.html#L29" title="ocaml/runtime/caml/sys.h:29">NO_ARG</a>); }<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(pos));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L999">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_pos_in_64</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L33" title="ocaml/runtime/caml/io.h:33">file_offset</a> pos;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> *<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; pos = <a href="#L447" title="ocaml/runtime/io.c:447">caml_pos_in</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/io.h.html#L120" title="ocaml/runtime/caml/io.h:120">Val_file_offset</a>(pos));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1010">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_ml_input_scan_line</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L276" title="ocaml/runtime/caml/memory.h:276">CAMLparam1</a> (vchannel);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> * <a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a> = <a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel);<br/></li>
<li>&nbsp; <a href="caml/config.h.html#L140" title="ocaml/runtime/caml/config.h:140">intnat</a> res;<br/></li>
<li><br/></li>
<li>&nbsp; <a href="caml/io.h.html#L109" title="ocaml/runtime/caml/io.h:109">Lock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; res = <a href="#L452" title="ocaml/runtime/io.c:452">caml_input_scan_line</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/io.h.html#L111" title="ocaml/runtime/caml/io.h:111">Unlock</a>(<a href="caml/io.h.html#L39" title="ocaml/runtime/caml/io.h:39">channel</a>);<br/></li>
<li>&nbsp; <a href="caml/memory.h.html#L419" title="ocaml/runtime/caml/memory.h:419">CAMLreturn</a> (<a href="caml/mlvalues.h.html#L77" title="ocaml/runtime/caml/mlvalues.h:77">Val_long</a>(res));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1022">&#x200c;</a><a href="caml/misc.h.html#L124" title="ocaml/runtime/caml/misc.h:124">CAMLprim</a> <a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> <span class="linkable">caml_terminfo_rows</span>(<a href="caml/mlvalues.h.html#L57" title="ocaml/runtime/caml/mlvalues.h:57">value</a> vchannel)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="caml/mlvalues.h.html#L81" title="ocaml/runtime/caml/mlvalues.h:81">Val_int</a>(<a href="unix.c.html#L465" title="ocaml/runtime/unix.c:465">caml_num_rows_fd</a>(<a href="caml/io.h.html#L98" title="ocaml/runtime/caml/io.h:98">Channel</a>(vchannel)-&gt;fd));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
