<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/ocamltest/run_win32.c - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/ocamltest/run_win32.c - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L216">security_attributes</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L112">commandline_of_arguments</a></li>
<li><a href="#L222">create_input_handle</a></li>
<li><a href="#L236">create_output_handle</a></li>
<li><a href="#L64">find_program</a></li>
<li><a href="#L145">prepare_environment</a></li>
<li><a href="#L38">report_error</a></li>
<li><a href="#L266">run_command</a></li>
<li><a href="#L261">translate_finename</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L19">_WIN32_WINNT</a></li>
<li><a href="#L253">checkerr</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/**************************************************************************/<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Sebastien Hinderer, projet Gallium, INRIA Paris&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; Copyright 2016 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; All rights reserved.&nbsp; This file is distributed under the terms of&nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp;&nbsp; special exception on linking described in the file LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/**************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Run programs with redirections and timeouts under Windows */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GetTickCount64() requires Windows Vista or Server 2008 */<br/></li>
<li><a id="L19">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">_WIN32_WINNT</span> </span><span class="Constant">0x0600<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;wtypes.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;winbase.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;windows.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;process.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdarg.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;caml/memory.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;caml/osdeps.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;run.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;run_common.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L38">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">report_error</span>(<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">char</span> *file, <span class="Type">int</span> line,<br/></li>
<li>&nbsp; <span class="Type">const</span> <a href="run.h.html#L40" title="ocaml/ocamltest/run.h:40">command_settings</a> *settings,<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">char</span> *message, <span class="Type">const</span> WCHAR *argument)<br/></li>
<li>{<br/></li>
<li>&nbsp; WCHAR windows_error_message[<span class="Constant">1024</span>];<br/></li>
<li>&nbsp; DWORD <a href="run_unix.c.html#L40" title="ocaml/ocamltest/run_unix.c:40">error</a> = GetLastError();<br/></li>
<li>&nbsp; <span class="Type">char</span> *caml_error_message, buf[<span class="Constant">256</span>];<br/></li>
<li>&nbsp; <span class="Statement">if</span> (FormatMessage(<br/></li>
<li>&nbsp; &nbsp; FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">NULL</span>, <a href="run_unix.c.html#L40" title="ocaml/ocamltest/run_unix.c:40">error</a>, <span class="Constant">0</span>, windows_error_message,<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">sizeof</span>(windows_error_message)/<span class="Statement">sizeof</span>(WCHAR), <span class="Constant">NULL</span>) ) {<br/></li>
<li>&nbsp; &nbsp; caml_error_message = caml_stat_strdup_of_utf16(windows_error_message);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; caml_error_message = caml_stat_alloc(<span class="Constant">256</span>);<br/></li>
<li>&nbsp; &nbsp; sprintf(caml_error_message, <span class="Constant">&quot;unknown Windows <a href="run_unix.c.html#L40" title="ocaml/ocamltest/run_unix.c:40">error</a> #</span><span class="Special">%lu</span><span class="Constant">&quot;</span>, <a href="run_unix.c.html#L40" title="ocaml/ocamltest/run_unix.c:40">error</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> ( <a href="run_common.h.html#L23" title="ocaml/ocamltest/run_common.h:23">is_defined</a>(argument) )<br/></li>
<li>&nbsp; &nbsp; <a href="run_common.h.html#L41" title="ocaml/ocamltest/run_common.h:41">error_with_location</a>(file, line,<br/></li>
<li>&nbsp; &nbsp; &nbsp; settings, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, message, argument, caml_error_message);<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <a href="run_common.h.html#L41" title="ocaml/ocamltest/run_common.h:41">error_with_location</a>(file, line,<br/></li>
<li>&nbsp; &nbsp; &nbsp; settings, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, message, caml_error_message);<br/></li>
<li>&nbsp; caml_stat_free(caml_error_message);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L64">&#x200c;</a><span class="Type">static</span> WCHAR *<span class="linkable">find_program</span>(<span class="Type">const</span> WCHAR *program_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Type">int</span> max_path_length = <span class="Constant">512</span>;<br/></li>
<li>&nbsp; DWORD result;<br/></li>
<li>&nbsp; LPCWSTR searchpath = <span class="Constant">NULL</span>, extension = <span class="Constant">L&quot;.exe&quot;</span>;<br/></li>
<li>&nbsp; WCHAR **filepart = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; WCHAR *fullpath = malloc(max_path_length*<span class="Statement">sizeof</span>(WCHAR));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (fullpath == <span class="Constant">NULL</span>) <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; result = SearchPath<br/></li>
<li>&nbsp; (<br/></li>
<li>&nbsp; &nbsp; searchpath,<br/></li>
<li>&nbsp; &nbsp; program_name,<br/></li>
<li>&nbsp; &nbsp; extension,<br/></li>
<li>&nbsp; &nbsp; max_path_length,<br/></li>
<li>&nbsp; &nbsp; fullpath,<br/></li>
<li>&nbsp; &nbsp; filepart<br/></li>
<li>&nbsp; );<br/></li>
<li>&nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It may be an absolute path, return a copy of it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span> l = wcslen(program_name) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; free(fullpath);<br/></li>
<li>&nbsp; &nbsp; fullpath = malloc(l*<span class="Statement">sizeof</span>(WCHAR));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fullpath != <span class="Constant">NULL</span>) wcscpy(fullpath, program_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fullpath;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (result &lt;= max_path_length) <span class="Statement">return</span> fullpath;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* fullpath was too small, allocate a bigger one */<br/></li>
<li></span>&nbsp; free(fullpath);<br/></li>
<li><br/></li>
<li>&nbsp; result++; <span class="Comment">/* Take '\0' into account */<br/></li>
<li></span><br/></li>
<li>&nbsp; fullpath = malloc(result*<span class="Statement">sizeof</span>(WCHAR));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (fullpath == <span class="Constant">NULL</span>) <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; SearchPath<br/></li>
<li>&nbsp; (<br/></li>
<li>&nbsp; &nbsp; searchpath,<br/></li>
<li>&nbsp; &nbsp; program_name,<br/></li>
<li>&nbsp; &nbsp; extension,<br/></li>
<li>&nbsp; &nbsp; result,<br/></li>
<li>&nbsp; &nbsp; fullpath,<br/></li>
<li>&nbsp; &nbsp; filepart<br/></li>
<li>&nbsp; );<br/></li>
<li>&nbsp; <span class="Statement">return</span> fullpath;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L112">&#x200c;</a><span class="Type">static</span> WCHAR *<span class="linkable">commandline_of_arguments</span>(WCHAR **arguments)<br/></li>
<li>{<br/></li>
<li>&nbsp; WCHAR *commandline = <span class="Constant">NULL</span>, **arguments_p, *commandline_p;<br/></li>
<li>&nbsp; <span class="Type">int</span> args = <span class="Constant">0</span>; <span class="Comment">/* Number of arguments */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> commandline_length = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (*arguments == <span class="Constant">NULL</span>) <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; <span class="Comment">/* From here we know there is at least one argument */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* First compute number of arguments and commandline length */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (arguments_p = arguments; *arguments_p != <span class="Constant">NULL</span>; arguments_p++)<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; args++;<br/></li>
<li>&nbsp; &nbsp; commandline_length += wcslen(*arguments_p);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; commandline_length += args; <span class="Comment">/* args-1 ' ' between arguments + final '\0' */<br/></li>
<li></span><br/></li>
<li>&nbsp; <span class="Comment">/* Allocate memory and accumulate arguments separated by spaces */<br/></li>
<li></span>&nbsp; commandline = malloc(commandline_length*<span class="Statement">sizeof</span>(WCHAR));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (commandline == <span class="Constant">NULL</span>) <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; commandline_p = commandline;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (arguments_p = arguments; *arguments_p!=<span class="Constant">NULL</span>; arguments_p++)<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> l = wcslen(*arguments_p);<br/></li>
<li>&nbsp; &nbsp; memcpy(commandline_p, *arguments_p, l*<span class="Statement">sizeof</span>(WCHAR));<br/></li>
<li>&nbsp; &nbsp; commandline_p += l;<br/></li>
<li>&nbsp; &nbsp; *commandline_p = <span class="Constant">L' '</span>;<br/></li>
<li>&nbsp; &nbsp; commandline_p++;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; commandline[commandline_length-<span class="Constant">1</span>] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> commandline;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L145">&#x200c;</a><span class="Type">static</span> LPVOID <span class="linkable">prepare_environment</span>(WCHAR **localenv)<br/></li>
<li>{<br/></li>
<li>&nbsp; LPTCH p, r, env, process_env = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; WCHAR **q;<br/></li>
<li>&nbsp; <span class="Type">int</span> l, process_env_length, localenv_length, env_length;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (localenv == <span class="Constant">NULL</span>) <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; process_env = GetEnvironmentStrings();<br/></li>
<li>&nbsp; <span class="Statement">if</span> (process_env == <span class="Constant">NULL</span>) <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Compute length of process environment */<br/></li>
<li></span>&nbsp; process_env_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; p = process_env;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (*p != <span class="Special">L'\0'</span>) {<br/></li>
<li>&nbsp; &nbsp; l = wcslen(p) + <span class="Constant">1</span>; <span class="Comment">/* also count terminating '\0' */<br/></li>
<li></span>&nbsp; &nbsp; process_env_length += l;<br/></li>
<li>&nbsp; &nbsp; p += l;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Compute length of local environment */<br/></li>
<li></span>&nbsp; localenv_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (q = localenv; *q != <span class="Constant">NULL</span>; q++) {<br/></li>
<li>&nbsp; &nbsp; localenv_length += wcslen(*q) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Comment">/* Build new env that contains both process and local env */<br/></li>
<li></span>&nbsp; env_length = process_env_length + localenv_length + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; env = malloc(env_length * <span class="Statement">sizeof</span>(WCHAR));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (env == <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; FreeEnvironmentStrings(process_env);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; r = env;<br/></li>
<li>&nbsp; p = process_env;<br/></li>
<li>&nbsp; <span class="Comment">/* Copy process_env to env only if the given names are not in localenv */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (*p != <span class="Special">L'\0'</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">wchar_t</span> *pos_eq = wcschr(p, <span class="Constant">L'='</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> copy = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; l = wcslen(p) + <span class="Constant">1</span>; <span class="Comment">/* also count terminating '\0' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Temporarily change the = to \0 for wcscmp */<br/></li>
<li></span>&nbsp; &nbsp; *pos_eq = <span class="Special">L'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (q = localenv; *q != <span class="Constant">NULL</span>; q++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">wchar_t</span> *pos_eq2 = wcschr(*q, <span class="Constant">L'='</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare this name in localenv with the current one in processenv */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos_eq2) *pos_eq2 = <span class="Special">L'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!wcscmp(*q, p)) copy = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos_eq2) *pos_eq2 = <span class="Constant">L'='</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *pos_eq = <span class="Constant">L'='</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (copy) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* This name is not marked for deletion/update in localenv, so copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; memcpy(r, p, l * <span class="Statement">sizeof</span>(WCHAR));<br/></li>
<li>&nbsp; &nbsp; &nbsp; r += l;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; p += l;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; FreeEnvironmentStrings(process_env);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (q = localenv; *q != <span class="Constant">NULL</span>; q++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A string in localenv without '=' signals deletion, which has been done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">wchar_t</span> *pos_eq = wcschr(*q, <span class="Constant">L'='</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pos_eq) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; l = wcslen(*q) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; memcpy(r, *q, l * <span class="Statement">sizeof</span>(WCHAR));<br/></li>
<li>&nbsp; &nbsp; &nbsp; r += l;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; *r = <span class="Special">L'\0'</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> env;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L216">&#x200c;</a><span class="Type">static</span> SECURITY_ATTRIBUTES <span class="linkable">security_attributes</span> = {<br/></li>
<li>&nbsp; <span class="Statement">sizeof</span>(SECURITY_ATTRIBUTES), <span class="Comment">/* nLength */<br/></li>
<li></span>&nbsp; <span class="Constant">NULL</span>, <span class="Comment">/* lpSecurityDescriptor */<br/></li>
<li></span>&nbsp; TRUE <span class="Comment">/* bInheritHandle */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L222">&#x200c;</a><span class="Type">static</span> HANDLE <span class="linkable">create_input_handle</span>(<span class="Type">const</span> WCHAR *filename)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">return</span> CreateFile<br/></li>
<li>&nbsp; (<br/></li>
<li>&nbsp; &nbsp; filename,<br/></li>
<li>&nbsp; &nbsp; GENERIC_READ, <span class="Comment">/* DWORD desired_access */<br/></li>
<li></span>&nbsp; &nbsp; FILE_SHARE_READ, <span class="Comment">/* DWORD share_mode */<br/></li>
<li></span>&nbsp; &nbsp; &amp;<a href="#L216" title="ocaml/ocamltest/run_win32.c:216">security_attributes</a>,<br/></li>
<li>&nbsp; &nbsp; OPEN_EXISTING, <span class="Comment">/* DWORD creation_disposition */<br/></li>
<li></span>&nbsp; &nbsp; FILE_ATTRIBUTE_NORMAL, <span class="Comment">/* DWORD flags_and_attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">NULL</span> <span class="Comment">/* HANDLE template_file */<br/></li>
<li></span>&nbsp; );<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L236">&#x200c;</a><span class="Type">static</span> HANDLE <span class="linkable">create_output_handle</span>(<span class="Type">const</span> WCHAR *filename, <span class="Type">int</span> append)<br/></li>
<li>{<br/></li>
<li>&nbsp; DWORD desired_access = append ? FILE_APPEND_DATA : GENERIC_WRITE;<br/></li>
<li>&nbsp; DWORD share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;<br/></li>
<li>&nbsp; DWORD creation_disposition = append ? OPEN_ALWAYS : CREATE_ALWAYS;<br/></li>
<li>&nbsp; <span class="Statement">return</span> CreateFile<br/></li>
<li>&nbsp; (<br/></li>
<li>&nbsp; &nbsp; filename,<br/></li>
<li>&nbsp; &nbsp; desired_access,<br/></li>
<li>&nbsp; &nbsp; share_mode,<br/></li>
<li>&nbsp; &nbsp; &amp;<a href="#L216" title="ocaml/ocamltest/run_win32.c:216">security_attributes</a>,<br/></li>
<li>&nbsp; &nbsp; creation_disposition,<br/></li>
<li>&nbsp; &nbsp; FILE_ATTRIBUTE_NORMAL, <span class="Comment">/* DWORD flags_and_attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">NULL</span> <span class="Comment">/* HANDLE template_file */<br/></li>
<li></span>&nbsp; );<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L253">&#x200c;</a><span class="PreProc">#define <span class="linkable">checkerr</span>(condition, message, argument) \<br/></li>
<li></span><span class="Statement">if</span><span class="PreProc"> ( (condition) ) \<br/></li>
<li></span><span class="PreProc">{ \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="#L38" title="ocaml/ocamltest/run_win32.c:38">report_error</a>(</span><span class="Constant">__FILE__</span><span class="PreProc">, </span><span class="Constant">__LINE__</span><span class="PreProc">, settings, message, argument); \<br/></li>
<li></span><span class="PreProc">&nbsp; status = -</span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">goto</span><span class="PreProc"> cleanup; \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">else</span><span class="PreProc"> { }<br/></li>
<li></span><br/></li>
<li><a id="L261">&#x200c;</a><span class="Type">static</span> WCHAR *<span class="linkable">translate_finename</span>(WCHAR *filename)<br/></li>
<li>{<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!wcscmp(filename, <span class="Constant">L&quot;/dev/null&quot;</span>)) <span class="Statement">return</span> <span class="Constant">L&quot;NUL&quot;</span>; <span class="Statement">else</span> <span class="Statement">return</span> filename;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L266">&#x200c;</a><span class="Type">int</span> <span class="linkable">run_command</span>(<span class="Type">const</span> <a href="run.h.html#L40" title="ocaml/ocamltest/run.h:40">command_settings</a> *settings)<br/></li>
<li>{<br/></li>
<li>&nbsp; BOOL process_created = FALSE;<br/></li>
<li>&nbsp; <span class="Type">int</span> stdin_redirected = <span class="Constant">0</span>, stdout_redirected = <span class="Constant">0</span>, stderr_redirected = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Type">int</span> combined = <span class="Constant">0</span>; <span class="Comment">/* 1 if stdout and stderr are redirected to the same file */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> wait_again = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; WCHAR *program = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; WCHAR *commandline = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; LPVOID environment = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; LPCWSTR current_directory = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; STARTUPINFO startup_info;<br/></li>
<li>&nbsp; PROCESS_INFORMATION process_info;<br/></li>
<li>&nbsp; BOOL wait_result;<br/></li>
<li>&nbsp; DWORD status;<br/></li>
<li>&nbsp; ULONGLONG stamp, cur;<br/></li>
<li>&nbsp; DWORD timeout = (settings-&gt;timeout &gt; <span class="Constant">0</span>) ? settings-&gt;timeout * <span class="Constant">1000</span> : INFINITE;<br/></li>
<li><br/></li>
<li>&nbsp; JOBOBJECT_ASSOCIATE_COMPLETION_PORT port = {<span class="Constant">NULL</span>, <span class="Constant">NULL</span>};<br/></li>
<li>&nbsp; HANDLE hJob = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; DWORD completion_code;<br/></li>
<li>&nbsp; ULONG_PTR completion_key;<br/></li>
<li>&nbsp; LPOVERLAPPED pOverlapped;<br/></li>
<li><br/></li>
<li>&nbsp; ZeroMemory(&amp;startup_info, <span class="Statement">sizeof</span>(STARTUPINFO));<br/></li>
<li>&nbsp; startup_info.cb = <span class="Statement">sizeof</span>(STARTUPINFO);<br/></li>
<li>&nbsp; startup_info.dwFlags = STARTF_USESTDHANDLES;<br/></li>
<li><br/></li>
<li>&nbsp; program = <a href="#L64" title="ocaml/ocamltest/run_win32.c:64">find_program</a>(settings-&gt;program);<br/></li>
<li>&nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>(<br/></li>
<li>&nbsp; &nbsp; (program == <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;Could not find program to execute&quot;</span>,<br/></li>
<li>&nbsp; &nbsp;&nbsp; settings-&gt;program<br/></li>
<li>&nbsp; );<br/></li>
<li><br/></li>
<li>&nbsp; commandline = <a href="#L112" title="ocaml/ocamltest/run_win32.c:112">commandline_of_arguments</a>(settings-&gt;argv);<br/></li>
<li><br/></li>
<li>&nbsp; environment = <a href="#L145" title="ocaml/ocamltest/run_win32.c:145">prepare_environment</a>(settings-&gt;envp);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="run_common.h.html#L23" title="ocaml/ocamltest/run_common.h:23">is_defined</a>(settings-&gt;stdin_filename))<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; WCHAR *stdin_filename = <a href="#L261" title="ocaml/ocamltest/run_win32.c:261">translate_finename</a>(settings-&gt;stdin_filename);<br/></li>
<li>&nbsp; &nbsp; startup_info.hStdInput = <a href="#L222" title="ocaml/ocamltest/run_win32.c:222">create_input_handle</a>(stdin_filename);<br/></li>
<li>&nbsp; &nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( (startup_info.hStdInput == INVALID_HANDLE_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Could not redirect standard input&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; stdin_filename);<br/></li>
<li>&nbsp; &nbsp; stdin_redirected = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> startup_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="run_common.h.html#L23" title="ocaml/ocamltest/run_common.h:23">is_defined</a>(settings-&gt;stdout_filename))<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; WCHAR *stdout_filename = <a href="#L261" title="ocaml/ocamltest/run_win32.c:261">translate_finename</a>(settings-&gt;stdout_filename);<br/></li>
<li>&nbsp; &nbsp; startup_info.hStdOutput = <a href="#L236" title="ocaml/ocamltest/run_win32.c:236">create_output_handle</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; stdout_filename, settings-&gt;append<br/></li>
<li>&nbsp; &nbsp; );<br/></li>
<li>&nbsp; &nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( (startup_info.hStdOutput == INVALID_HANDLE_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Could not redirect standard output&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; stdout_filename);<br/></li>
<li>&nbsp; &nbsp; stdout_redirected = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> startup_info.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="run_common.h.html#L23" title="ocaml/ocamltest/run_common.h:23">is_defined</a>(settings-&gt;stderr_filename))<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stdout_redirected)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wcscmp(settings-&gt;stdout_filename, settings-&gt;stderr_filename) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startup_info.hStdError = startup_info.hStdOutput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stderr_redirected = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; combined = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (! stderr_redirected)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; WCHAR *stderr_filename = <a href="#L261" title="ocaml/ocamltest/run_win32.c:261">translate_finename</a>(settings-&gt;stderr_filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; startup_info.hStdError = <a href="#L236" title="ocaml/ocamltest/run_win32.c:236">create_output_handle</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; (<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stderr_filename, settings-&gt;append<br/></li>
<li>&nbsp; &nbsp; &nbsp; );<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( (startup_info.hStdError == INVALID_HANDLE_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Could not redirect standard <a href="run_unix.c.html#L40" title="ocaml/ocamltest/run_unix.c:40">error</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stderr_filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; stderr_redirected = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">else</span> startup_info.hStdError = GetStdHandle(STD_ERROR_HANDLE);<br/></li>
<li><br/></li>
<li>&nbsp; process_created = CreateProcess(<br/></li>
<li>&nbsp; &nbsp; program,<br/></li>
<li>&nbsp; &nbsp; commandline,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Comment">/* SECURITY_ATTRIBUTES process_attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Comment">/* SECURITY_ATTRIBUTES thread_attributes */<br/></li>
<li></span>&nbsp; &nbsp; TRUE, <span class="Comment">/* BOOL inherit_handles */<br/></li>
<li></span>&nbsp; &nbsp; CREATE_SUSPENDED | CREATE_UNICODE_ENVIRONMENT, <span class="Comment">/* DWORD creation_flags */<br/></li>
<li></span>&nbsp; &nbsp; environment,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Comment">/* LPCSTR current_directory */<br/></li>
<li></span>&nbsp; &nbsp; &amp;startup_info,<br/></li>
<li>&nbsp; &nbsp; &amp;process_info<br/></li>
<li>&nbsp; );<br/></li>
<li>&nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( (! process_created), <span class="Constant">&quot;CreateProcess failed&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; hJob = CreateJobObject(<span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( (hJob == <span class="Constant">NULL</span>), <span class="Constant">&quot;CreateJobObject failed&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( !AssignProcessToJobObject(hJob, process_info.hProcess),<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;AssignProcessToJob failed&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; port.CompletionPort =<br/></li>
<li>&nbsp; &nbsp; CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( (port.CompletionPort == <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">&quot;CreateIoCompletionPort failed&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( !SetInformationJobObject(<br/></li>
<li>&nbsp; &nbsp; hJob,<br/></li>
<li>&nbsp; &nbsp; JobObjectAssociateCompletionPortInformation,<br/></li>
<li>&nbsp; &nbsp; &amp;port, <span class="Statement">sizeof</span>(port)), <span class="Constant">&quot;SetInformationJobObject failed&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; ResumeThread(process_info.hThread);<br/></li>
<li>&nbsp; CloseHandle(process_info.hThread);<br/></li>
<li><br/></li>
<li>&nbsp; stamp = GetTickCount64();<br/></li>
<li>&nbsp; <span class="Statement">while</span> ((wait_result = GetQueuedCompletionStatus(port.CompletionPort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;completion_code,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;completion_key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pOverlapped,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; completion_code != JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO)<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (timeout != INFINITE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; cur = GetTickCount64();<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur &gt; stamp) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ULONGLONG elapsed = cur - stamp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeout = (timeout &gt; elapsed ? timeout - elapsed : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stamp = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (wait_result)<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The child has terminated before the timeout has expired */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( (! GetExitCodeProcess(process_info.hProcess, &amp;status)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Constant">&quot;GetExitCodeProcess failed&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; } <span class="Statement">else</span> <span class="Statement">if</span> (pOverlapped == <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The timeout has expired, terminate the process */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L253" title="ocaml/ocamltest/run_win32.c:253">checkerr</a>( (! TerminateJobObject(hJob, <span class="Constant">0</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Constant">&quot;TerminateJob failed&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; status = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; wait_again = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="run_common.h.html#L41" title="ocaml/ocamltest/run_common.h:41">error_with_location</a>(<span class="Constant">__FILE__</span>, <span class="Constant">__LINE__</span>, settings,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Constant">&quot;GetQueuedCompletionStatus failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="ocaml/ocamltest/run_win32.c:38">report_error</a>(<span class="Constant">__FILE__</span>, <span class="Constant">__LINE__</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; settings, <span class="Constant">&quot;Failure while waiting for process termination&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; status = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">cleanup</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; free(program);<br/></li>
<li>&nbsp; free(commandline);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (stdin_redirected) CloseHandle(startup_info.hStdInput);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (stdout_redirected) CloseHandle(startup_info.hStdOutput);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (stderr_redirected &amp;&amp; !combined) CloseHandle(startup_info.hStdError);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (wait_again)<br/></li>
<li>&nbsp; {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wait again but this time just 1sec to avoid being blocked */<br/></li>
<li></span>&nbsp; &nbsp; WaitForSingleObject(process_info.hProcess, <span class="Constant">1000</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (process_created) CloseHandle(process_info.hProcess);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (hJob != <span class="Constant">NULL</span>) CloseHandle(hJob);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (port.CompletionPort != <span class="Constant">NULL</span>) CloseHandle(port.CompletionPort);<br/></li>
<li>&nbsp; <span class="Statement">return</span> status;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
