<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/arrayLabels.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/arrayLabels.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L94">append</a></li>
<li><a href="#L123">blit</a></li>
<li><a href="#L284">combine</a></li>
<li><a href="#L100">concat</a></li>
<li><a href="#L112">copy</a></li>
<li><a href="#L221">exists</a></li>
<li><a href="#L232">exists2</a></li>
<li><a href="#L327">fast_sort</a></li>
<li><a href="#L116">fill</a></li>
<li><a href="#L255">find_index</a></li>
<li><a href="#L264">find_map</a></li>
<li><a href="#L270">find_mapi</a></li>
<li><a href="#L248">find_opt</a></li>
<li><a href="#L178">fold_left</a></li>
<li><a href="#L183">fold_left_map</a></li>
<li><a href="#L189">fold_right</a></li>
<li><a href="#L215">for_all</a></li>
<li><a href="#L227">for_all2</a></li>
<li><a href="#L71">init</a></li>
<li><a href="#L148">iter</a></li>
<li><a href="#L198">iter2</a></li>
<li><a href="#L153">iteri</a></li>
<li><a href="#L81">make_matrix</a></li>
<li><a href="#L158">map</a></li>
<li><a href="#L205">map2</a></li>
<li><a href="#L163">map_inplace</a></li>
<li><a href="#L168">mapi</a></li>
<li><a href="#L173">mapi_inplace</a></li>
<li><a href="#L237">mem</a></li>
<li><a href="#L243">memq</a></li>
<li><a href="#L139">of_list</a></li>
<li><a href="#L345">of_seq</a></li>
<li><a href="#L292">sort</a></li>
<li><a href="#L279">split</a></li>
<li><a href="#L317">stable_sort</a></li>
<li><a href="#L103">sub</a></li>
<li><a href="#L136">to_list</a></li>
<li><a href="#L334">to_seq</a></li>
<li><a href="#L339">to_seqi</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L30">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* </span><span class="Todo">NOTE</span><span class="Comment">:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is arrayLabels.mli, run tools/sync_stdlib_docs after editing it<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to generate array.mli.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is array.mli, do not edit it directly -- edit<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; arrayLabels.mli instead.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Array operations.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The labeled version of this module can be used as described in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!StdLabels} module.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L30">&#x200c;</a><span class="Statement">type</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><span class="linkable">t</span></span> <span class="Statement">=</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** An alias for the type of arrays. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%array_length&quot;<br/></li>
<li></span><span class="Comment">(** Return the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> (number of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>) of the given array. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%array_safe_get&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns the element number [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] of array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The first element has number 0.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> element has number [<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; You can also write [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>)] instead of [<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is outside the range 0 to [(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1)]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%array_safe_set&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] modifies array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in place, replacing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; element number [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] with [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; You can also write [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>) &lt;- <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] instead of [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is outside the range 0 to [<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_make_vect&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh array of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; initialized with [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; All the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of this new array are initially<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] (in the sense of the [==] predicate).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Consequently, if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is mutable, it is shared among all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of the array, and modifying [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] through <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the array entries<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; will modify all other entries at the same time.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="sys.mli.html#L188" title="ocaml/stdlib/sys.mli:188">max_array_length</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If the value of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating-point number, then the maximum<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> is only [Sys.<a href="sys.mli.html#L188" title="ocaml/stdlib/sys.mli:188">max_array_length</a> / 2].*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">create_float</span>: <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Type">array</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_make_float_vect&quot;<br/></li>
<li></span><span class="Comment">(** [create_float <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; with uninitialized <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><a id="L71">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">init</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> ~f] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh array of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; with element number [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] initialized to the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of [f <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; In other terms, [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> ~f] tabulates the results of [f]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; applied in order to the integers [0] to [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="sys.mli.html#L188" title="ocaml/stdlib/sys.mli:188">max_array_length</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If the <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> type of [f] is [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>], then the maximum<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> is only [Sys.<a href="sys.mli.html#L188" title="ocaml/stdlib/sys.mli:188">max_array_length</a> / 2].*)<br/></li>
<li></span><br/></li>
<li><a id="L81">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">make_matrix</span></span> : <span class="ocamlLCIdentifier">dimx</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dimy</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="array.mli.html#L81" title="ocaml/stdlib/array.mli:81">make_matrix</a> ~dimx ~dimy <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-dimensional array<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (an array of arrays) with first dimension [dimx] and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; second dimension [dimy]. All the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of this new matrix<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are initially physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The element ([<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>,y]) of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> matrix [m] is accessed<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; with the notation [m.(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>).(y)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if [dimx] or [dimy] is negative or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; greater than {!Sys.<a href="sys.mli.html#L188" title="ocaml/stdlib/sys.mli:188">max_array_length</a>}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If the value of [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating-point number, then the maximum<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> is only [Sys.<a href="sys.mli.html#L188" title="ocaml/stdlib/sys.mli:188">max_array_length</a> / 2]. *)<br/></li>
<li></span><br/></li>
<li><a id="L94">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">append</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a> v1 v2] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh array containing the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; concatenation of the arrays [v1] and [v2].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> v1 + <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> v2 &gt; Sys.<a href="sys.mli.html#L188" title="ocaml/stdlib/sys.mli:188">max_array_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L100">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">concat</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a>}, but concatenates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of arrays. *)<br/></li>
<li></span><br/></li>
<li><a id="L103">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sub</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh array of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; containing the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]; that is, if<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> &lt; 0], or [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &lt; 0], or [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &gt; <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L112">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">copy</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], that is, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh array<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; containing the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L116">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fill</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L121" title="ocaml/stdlib/bytesLabels.mli:121">fill</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] modifies the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in place,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; storing [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L123">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">blit</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">src</span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">src_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst</span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> ~src ~src_pos ~dst ~dst_pos ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] copies [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; from array [src], starting at element number [src_pos], to array [dst],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; starting at element number [dst_pos]. It works correctly even if<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [src] and [dst] are the same array, and the source and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; destination chunks overlap.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if [src_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [src], or if [dst_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [dst]. *)<br/></li>
<li></span><br/></li>
<li><a id="L136">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_list</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns the list of all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L139">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">of_list</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh array containing the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [Sys.<a href="sys.mli.html#L188" title="ocaml/stdlib/sys.mli:188">max_array_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Iterators} *)<br/></li>
<li></span><br/></li>
<li><a id="L148">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] in turn to all<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].&nbsp; It is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0); f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1); ()]. *)<br/></li>
<li></span><br/></li>
<li><a id="L153">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iteri</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>}, but the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the element as first argument,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and the element itself as second argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L158">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and builds an array with the results returned by [f]:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [[| f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0); f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1) |]]. *)<br/></li>
<li></span><br/></li>
<li><a id="L163">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map_inplace</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="array.mli.html#L163" title="ocaml/stdlib/array.mli:163">map_inplace</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and updates their values in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L168">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mapi</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}, but the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the element as first argument,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and the element itself as second argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L173">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mapi_inplace</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="array.mli.html#L163" title="ocaml/stdlib/array.mli:163">map_inplace</a>}, but the function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element as first argument, and the element itself as second argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L178">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> ~f ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f (... (f (f <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0)) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1)) ...) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1)],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L183">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left_map</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="array.mli.html#L183" title="ocaml/stdlib/array.mli:183">fold_left_map</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> combination of {!<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a>} and {!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>} that threads an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; accumulator through calls to [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L189">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_right</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L191" title="ocaml/stdlib/bytesLabels.mli:191">fold_right</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0) (f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1) ( ... (f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1) <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>) ...))],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Iterators on two arrays} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L198">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L191" title="ocaml/stdlib/seq.ml:191">iter2</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and [b].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the arrays are not the same <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.03 (4.05 in ArrayLabels)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L205">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and [b], and builds an array with the results returned by [f]:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [[| f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0) b.(0); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1) b.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> b - 1)|]].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the arrays are not the same <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.03 (4.05 in ArrayLabels) *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Array scanning} *)<br/></li>
<li></span><br/></li>
<li><a id="L215">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">for_all</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> ~f [|<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|]] checks if all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of the array satisfy the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [(f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) &amp;&amp; (f a2) &amp;&amp; ... &amp;&amp; (f an)].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><a id="L221">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exists</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> ~f [|<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|]] checks if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the array satisfies the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [(f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) || (f a2) || ... || (f an)].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><a id="L227">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">for_all2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a>}, but for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-argument predicate.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two arrays have different lengths.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><a id="L232">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exists2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>}, but for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-argument predicate.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two arrays have different lengths.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><a id="L237">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mem</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] is true if and only if [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is structurally <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to an element of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. there is an [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 0]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><a id="L243">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">memq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a>}, but uses physical equality<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; instead of structural equality to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> list <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><a id="L248">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_opt</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns the first element of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] that satisfies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the predicate [f], or [None] if there is no value that satisfies [f] in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L255">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_index</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L153" title="ocaml/stdlib/seq.ml:153">find_index</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns [Some <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>], where [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] that satisfies [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], if there is such an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It returns [None] if there is no such element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L264">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies [f] to the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in order, and returns the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; first <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the form [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], or [None] if <a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> exist.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L270">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_mapi</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Same as [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a>], but the predicate is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Arrays of pairs} *)<br/></li>
<li></span><br/></li>
<li><a id="L279">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">split</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> [|(<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>,<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>); ...; (an,bn)|]] is [([|<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|], [|<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn|])].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L284">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">combine</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="array.mli.html#L284" title="ocaml/stdlib/array.mli:284">combine</a> [|<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|] [|<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn|]] is [[|(<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>,<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>); ...; (an,bn)|]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Raise [Invalid_argument] if the two arrays have different lengths.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Sorting} *)<br/></li>
<li></span><br/></li>
<li><a id="L292">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Sort an array in increasing order according to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> comparison<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function.&nbsp; The comparison function must <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> 0 if its arguments<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> as <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> positive integer if the first is greater,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> negative integer if the first is smaller (see below for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; complete specification).&nbsp; For example, {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>} is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable comparison function. After calling [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>], the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; array is sorted in place in increasing order.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>] is guaranteed to run in constant heap space<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and (at most) logarithmic <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Heap Sort.&nbsp; It runs in constant<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Specification of the comparison function:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Let [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] be the array and [cmp] the comparison function.&nbsp; The following<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; must be true for all [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], [y], [z] in [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] :<br/></li>
<li></span><span class="Comment">-&nbsp;&nbsp; [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] &gt; 0 if and only if [cmp y <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] &lt; 0<br/></li>
<li></span><span class="Comment">-&nbsp;&nbsp; if [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] &gt;= 0 and [cmp y z] &gt;= 0 then [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> z] &gt;= 0<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>] returns, [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; reordered in such <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> way that for all <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> and j valid indices of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] :<br/></li>
<li></span><span class="Comment">-&nbsp;&nbsp; [cmp <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(j)] &gt;= 0 if and only if <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> &gt;= j<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L317">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stable_sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}, but the sorting algorithm is stable (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> that <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> are kept in their original order) and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; not guaranteed to run in constant heap space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Merge Sort. It uses <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> temporary array of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>/2], where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the array.&nbsp; It is usually faster<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; than the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation of {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L327">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fast_sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>} or {!<a href="array.mli.html#L317" title="ocaml/stdlib/array.mli:317">stable_sort</a>}, whichever is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; faster on typical <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Arrays and Sequences} *)<br/></li>
<li></span><br/></li>
<li><a id="L334">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_seq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Iterate on the array, in increasing order. Modifications of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; array during iteration will be reflected in the sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><a id="L339">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_seqi</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Iterate on the array, in increasing order, yielding indices along <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Modifications of the array during iteration will be reflected in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><a id="L345">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">of_seq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** Create an array from the generator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:array_concurrency Arrays and concurrency safety}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Care must be taken when concurrently accessing arrays from multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; domains: accessing an array will never crash <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> program, but unsynchronized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; accesses might yield surprising (non-sequentially-consistent) results.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:array_atomicity Atomicity}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Every array operation that accesses more than <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> array element is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; atomic. This includes iteration, scanning, sorting, splitting and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; combining arrays.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For example, consider the following program:<br/></li>
<li></span><span class="Comment">{[let <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> = 100_000_000<br/></li>
<li></span><span class="Comment">let <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> = ArrayLabels.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 1<br/></li>
<li></span><span class="Comment">let d1 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt;<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ArrayLabels.<a href="bytesLabels.mli.html#L170" title="ocaml/stdlib/bytesLabels.mli:170">iteri</a> ~f:(fun <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>) &lt;- <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> + 1) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">)<br/></li>
<li></span><span class="Comment">let d2 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt;<br/></li>
<li></span><span class="Comment">&nbsp; ArrayLabels.<a href="bytesLabels.mli.html#L170" title="ocaml/stdlib/bytesLabels.mli:170">iteri</a> ~f:(fun <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>) &lt;- 2 * <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> + 1) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">)<br/></li>
<li></span><span class="Comment">let () = Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; After executing this code, each <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is either [2], [3],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [4] or [5]. If atomicity is required, then the user must implement their own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; synchronization (for example, using {!Mutex.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>}).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:array_data_race Data races}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If two domains only access <a href="set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a> parts of the array, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; observed behaviour is the equivalent to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sequential interleaving of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; operations from the two domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; A <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> race is said to occur when two domains access the same array element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; without synchronization and at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the accesses is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> write.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; In the absence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the observed behaviour is equivalent to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequential interleaving of the operations from different domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Whenever possible, <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races should be avoided by using synchronization to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; mediate the accesses to the array <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Indeed, in the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, programs will not crash but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; observed behaviour may not be equivalent to any sequential interleaving of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; operations from different domains. Nevertheless, even in the presence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> read operation will <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the value of <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> prior write to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; that <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> (with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> few exceptions for <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> arrays).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:array_data_race_exceptions Float arrays}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Float arrays have two supplementary caveats in the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; First, the <a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> operation might <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> an array byte-by-byte. Data races<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; between such <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> operation and another operation might produce surprising<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; values due to tearing: partial writes interleaved with other operations can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> values that would not exist with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequential execution.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For instance, at the end of<br/></li>
<li></span><span class="Comment"> {[let zeros = Array.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 0.<br/></li>
<li></span><span class="Comment">let max_floats = Array.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> Float.<a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a><br/></li>
<li></span><span class="Comment">let <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> = Array.<a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> zeros<br/></li>
<li></span><span class="Comment">let d1 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Array.<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> zeros 0 <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> 0 <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>)<br/></li>
<li></span><span class="Comment">let d2 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Array.<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> max_floats 0 <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> 0 <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>)<br/></li>
<li></span><span class="Comment">let () = Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the [<a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a>] array might contain values that are neither [0.] nor [<a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Second, on 32-bit architectures, getting or setting <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> involves two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; separate memory accesses. In the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the user may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; observe tearing on any operation.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**/**)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Undocumented functions} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* The following is for system use only. Do not call directly. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_get</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%array_unsafe_get&quot;<br/></li>
<li></span><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_set</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%array_unsafe_set&quot;<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> Floatarray</span><span class="ocamlPreDef"> : </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">floatarray</span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;caml_floatarray_create&quot;<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">floatarray</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_length&quot;<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">floatarray</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_safe_get&quot;<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">floatarray</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_safe_set&quot;<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">unsafe_get</span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">floatarray</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_unsafe_get&quot;<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">unsafe_set</span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">floatarray</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_unsafe_set&quot;<br/></li>
<li></span><span class="PreProc">end<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
