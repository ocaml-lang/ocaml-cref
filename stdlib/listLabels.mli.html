<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/listLabels.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/listLabels.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L105">append</a></li>
<li><a href="#L389">assoc</a></li>
<li><a href="#L398">assoc_opt</a></li>
<li><a href="#L408">assq</a></li>
<li><a href="#L413">assq_opt</a></li>
<li><a href="#L450">combine</a></li>
<li><a href="#L145">compare</a></li>
<li><a href="#L53">compare_length_with</a></li>
<li><a href="#L46">compare_lengths</a></li>
<li><a href="#L116">concat</a></li>
<li><a href="#L202">concat_map</a></li>
<li><a href="#L66">cons</a></li>
<li><a href="#L131">equal</a></li>
<li><a href="#L275">exists</a></li>
<li><a href="#L288">exists2</a></li>
<li><a href="#L487">fast_sort</a></li>
<li><a href="#L345">filter</a></li>
<li><a href="#L195">filter_map</a></li>
<li><a href="#L355">filteri</a></li>
<li><a href="#L308">find</a></li>
<li><a href="#L351">find_all</a></li>
<li><a href="#L323">find_index</a></li>
<li><a href="#L331">find_map</a></li>
<li><a href="#L338">find_mapi</a></li>
<li><a href="#L315">find_opt</a></li>
<li><a href="#L123">flatten</a></li>
<li><a href="#L215">fold_left</a></li>
<li><a href="#L248">fold_left2</a></li>
<li><a href="#L208">fold_left_map</a></li>
<li><a href="#L220">fold_right</a></li>
<li><a href="#L256">fold_right2</a></li>
<li><a href="#L268">for_all</a></li>
<li><a href="#L282">for_all2</a></li>
<li><a href="#L71">hd</a></li>
<li><a href="#L99">init</a></li>
<li><a href="#L60">is_empty</a></li>
<li><a href="#L164">iter</a></li>
<li><a href="#L229">iter2</a></li>
<li><a href="#L170">iteri</a></li>
<li><a href="#L43">length</a></li>
<li><a href="#L177">map</a></li>
<li><a href="#L236">map2</a></li>
<li><a href="#L183">mapi</a></li>
<li><a href="#L294">mem</a></li>
<li><a href="#L419">mem_assoc</a></li>
<li><a href="#L424">mem_assq</a></li>
<li><a href="#L299">memq</a></li>
<li><a href="#L497">merge</a></li>
<li><a href="#L81">nth</a></li>
<li><a href="#L88">nth_opt</a></li>
<li><a href="#L514">of_seq</a></li>
<li><a href="#L362">partition</a></li>
<li><a href="#L370">partition_map</a></li>
<li><a href="#L429">remove_assoc</a></li>
<li><a href="#L435">remove_assq</a></li>
<li><a href="#L96">rev</a></li>
<li><a href="#L111">rev_append</a></li>
<li><a href="#L190">rev_map</a></li>
<li><a href="#L243">rev_map2</a></li>
<li><a href="#L462">sort</a></li>
<li><a href="#L492">sort_uniq</a></li>
<li><a href="#L444">split</a></li>
<li><a href="#L478">stable_sort</a></li>
<li><a href="#L76">tl</a></li>
<li><a href="#L509">to_seq</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L40">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* </span><span class="Todo">NOTE</span><span class="Comment">:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is listLabels.mli, run tools/sync_stdlib_docs after editing it<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to generate list.mli.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is list.mli, do not edit it directly -- edit<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; listLabels.mli instead.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** List operations.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Some functions are flagged as not tail-recursive.&nbsp; A tail-recursive<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function uses constant <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space, while <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> non-tail-recursive function<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; uses <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space proportional to the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of its list argument, which<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; can be <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> problem with very long lists.&nbsp; When the function takes several<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; list arguments, an approximate formula giving <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> <a href="arg.ml.html#L117" title="ocaml/stdlib/arg.ml:117">usage</a> (in <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; unspecified constant unit) is shown in parentheses.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The above considerations can usually be <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a> if your lists are not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; longer than about 10000 <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The labeled version of this module can be used as described in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!StdLabels} module.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L40">&#x200c;</a><span class="Statement">type</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><span class="linkable">t</span></span> <span class="Statement">=</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">=</span> <span class="Constant">[]</span> <span class="Statement">|</span> <span class="Statement">(::)</span> <span class="Statement">of</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Comment">(**)<br/></li>
<li></span><span class="Comment">(** An alias for the type of lists. *)<br/></li>
<li></span><br/></li>
<li><a id="L43">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">length</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> (number of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>) of the given list. *)<br/></li>
<li></span><br/></li>
<li><a id="L46">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">compare_lengths</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Compare the lengths of two lists. [<a href="list.mli.html#L46" title="ocaml/stdlib/list.mli:46">compare_lengths</a> <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a> <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; equivalent to [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> (<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>) (<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>)], except that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the computation stops after reaching the end of the shortest list.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L53">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">compare_length_with</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Compare the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list to an integer. [<a href="list.mli.html#L53" title="ocaml/stdlib/list.mli:53">compare_length_with</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; equivalent to [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> (<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>) <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>], except that the computation stops<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; after at most [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] iterations on the list.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L60">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">is_empty</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="stack.ml.html#L53" title="ocaml/stdlib/stack.ml:53">is_empty</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is true if and only if [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] has no <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. It is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="list.mli.html#L53" title="ocaml/stdlib/list.mli:53">compare_length_with</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a> 0 = 0].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.1<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L66">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">cons</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L28" title="ocaml/stdlib/seq.ml:28">cons</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> xs] is [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> :: xs]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.03 (4.05 in ListLabels)<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L71">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">hd</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Return the first element of the given list.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Failure if the list is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L76">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">tl</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Return the given list without its first element.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Failure if the list is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L81">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">nth</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Return the [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]-th element of the given list.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The first element (head of the list) is at <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> 0.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Failure if the list is too short.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is negative.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L88">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">nth_opt</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Return the [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]-th element of the given list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The first element (head of the list) is at <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Return [None] if the list is too short.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is negative.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L96">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rev</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** List reversal. *)<br/></li>
<li></span><br/></li>
<li><a id="L99">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">init</span></span> : <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> ~f] is [[f 0; f 1; ...; f (<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>-1)]], evaluated <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> to <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &lt; 0].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.06<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L105">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">append</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a> l0 <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] appends [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] to [l0].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Same function as the infix operator [@].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; @since 5.1 this function is tail-recursive.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L111">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rev_append</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="list.mli.html#L111" title="ocaml/stdlib/list.mli:111">rev_append</a> <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a> <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>] reverses [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] and concatenates it with [<a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This is equivalent to [(]{!<a href="list.mli.html#L96" title="ocaml/stdlib/list.mli:96">rev</a>}[ <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>) @ <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>].<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L116">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">concat</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Concatenate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of lists. The <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the argument are all<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; concatenated together (in the same order) to give the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Not tail-recursive<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the argument + <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the longest <a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a>-list).<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L123">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">flatten</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a>}. Not tail-recursive<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the argument + <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the longest <a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a>-list).<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Comparison} *)<br/></li>
<li></span><br/></li>
<li><a id="L131">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">equal</span></span> : <span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a></span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an] [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ..; bm]] holds when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the two <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> lists have the same <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>, and for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; pair of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [ai], [bi] at the same <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> ai bi].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Note: the [<a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a>] function may be called even if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; lists have different <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>. If you know your equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; function is costly, you may want to <a href="weak.ml.html#L58" title="ocaml/stdlib/weak.ml:58">check</a> {!<a href="list.mli.html#L46" title="ocaml/stdlib/list.mli:46">compare_lengths</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; first.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L145">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">compare</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> cmp [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an] [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bm]] performs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> lexicographic comparison of the two <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> lists,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; using the same ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> -&gt; <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] interface as {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>}:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a> :: <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] is smaller than [a2 :: <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>] (negative <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; if [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>] is smaller than [a2], or if they are <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> (0 <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] is smaller than [<a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - the <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> list [[]] is strictly smaller than non-<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> lists<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Note: the [cmp] function will be called even if the lists have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; different lengths.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Iterators} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L164">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an]] applies function [f] in turn to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [[<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an]]. It is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; f a2; ...; f an].<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L170">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iteri</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>}, but the function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.00<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L177">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> ~f [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an]] applies function [f] to [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>, ..., an],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and builds the list [[f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; f an]]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; with the results returned by [f].<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L183">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mapi</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}, but the function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.00<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L190">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rev_map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="list.mli.html#L190" title="ocaml/stdlib/list.mli:190">rev_map</a> ~f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] gives the same <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!<a href="list.mli.html#L96" title="ocaml/stdlib/list.mli:96">rev</a>}[ (]{!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}[ f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>)], but is more efficient.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L195">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">filter_map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> ~f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] applies [f] to every element of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>], filters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; out the [None] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> and returns the list of the arguments of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the [Some] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L202">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">concat_map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L63" title="ocaml/stdlib/seq.ml:63">concat_map</a> ~f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] gives the same <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a>}[ (]{!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}[ f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>)]. Tail-recursive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.10<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L208">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left_map</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="array.mli.html#L183" title="ocaml/stdlib/array.mli:183">fold_left_map</a>] is&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> combination of [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a>] and [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>] that threads an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; accumulator through calls to [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.11<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L215">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> ~f ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn]] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f (... (f (f <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>) <a href="bytes.ml.html#L610" title="ocaml/stdlib/bytes.ml:610">b2</a>) ...) bn].<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L220">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_right</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L191" title="ocaml/stdlib/bytesLabels.mli:191">fold_right</a> ~f [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an] ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a> (f a2 (... (f an <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>) ...))]. Not tail-recursive.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Iterators on two lists} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L229">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L191" title="ocaml/stdlib/seq.ml:191">iter2</a> ~f [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an] [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn]] calls in turn<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a> <a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; f an bn].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two lists are determined<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to have different lengths.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L236">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> ~f [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an] [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn]] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [[f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a> <a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; f an bn]].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two lists are determined<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to have different lengths.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L243">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rev_map2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="list.mli.html#L243" title="ocaml/stdlib/list.mli:243">rev_map2</a> ~f <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a> <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>] gives the same <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!<a href="list.mli.html#L96" title="ocaml/stdlib/list.mli:96">rev</a>}[ (]{!<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a>}[ f <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a> <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>)], but is more efficient.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L248">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left2</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L203" title="ocaml/stdlib/seq.ml:203">fold_left2</a> ~f ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an] [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn]] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f (... (f (f <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a> <a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>) a2 <a href="bytes.ml.html#L610" title="ocaml/stdlib/bytes.ml:610">b2</a>) ...) an bn].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two lists are determined<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to have different lengths.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L256">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_right2</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="list.mli.html#L256" title="ocaml/stdlib/list.mli:256">fold_right2</a> ~f [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an] [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn] ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a> <a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a> (f a2 <a href="bytes.ml.html#L610" title="ocaml/stdlib/bytes.ml:610">b2</a> (... (f an bn <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>) ...))].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two lists are determined<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to have different lengths. Not tail-recursive.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 List scanning} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L268">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">for_all</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> ~f [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an]] checks if all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the list<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; satisfy the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [(f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) &amp;&amp; (f a2) &amp;&amp; ... &amp;&amp; (f an)] for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> non-<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> list and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [true] if the list is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L275">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exists</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> ~f [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an]] checks if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the list satisfies the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [(f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) || (f a2) || ... || (f an)] for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> non-<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> list and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [false] if the list is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L282">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">for_all2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a>}, but for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-argument predicate.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two lists are determined<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to have different lengths.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L288">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exists2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>}, but for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-argument predicate.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two lists are determined<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to have different lengths.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L294">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mem</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] is true if and only if [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to an element of [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>].<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L299">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">memq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a>}, but uses physical equality instead of structural<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; equality to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> list <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 List searching} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L308">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> ~f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns the first element of the list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that satisfies the predicate [f].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Not_found if there is no value that satisfies [f] in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L315">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_opt</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> ~f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns the first element of the list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that satisfies the predicate [f].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Returns [None] if there is no value that satisfies [f] in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L323">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_index</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L153" title="ocaml/stdlib/seq.ml:153">find_index</a> ~f xs] returns [Some <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>], where [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; element of the list [xs] that satisfies [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], if there is such an element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; It returns [None] if there is no such element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L331">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a> ~f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] applies [f] to the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] in order,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and returns the first <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the form [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], or [None]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; if <a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.10<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L338">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_mapi</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Same as [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a>], but the predicate is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L345">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">filter</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> ~f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that satisfy the predicate [f]. The order of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> list is preserved.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L351">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_all</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="ephemeron.mli.html#L97" title="ocaml/stdlib/ephemeron.mli:97">find_all</a>] is another <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> for {!<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a>}.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L355">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">filteri</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a>}, but the predicate is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.11<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L362">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">partition</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> ~f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of lists [(<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>, <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>)], where<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] is the list of all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; satisfy the predicate [f], and [<a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>] is the list of all the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] that do not satisfy [f].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The order of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> list is preserved.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L370">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">partition_map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="PreProc">Either</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L594" title="ocaml/stdlib/seq.ml:594">partition_map</a> f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of lists [(<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>, <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>)] such that,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for each element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - if [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [Left y1], then [y1] is in [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>], and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - if [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [Right y2], then [y2] is in [<a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are included in [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] and [<a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>] in the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; relative order as the corresponding <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; In particular, [<a href="seq.ml.html#L594" title="ocaml/stdlib/seq.ml:594">partition_map</a> (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; if f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> then Left <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> else Right <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>) <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is equivalent to [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> f <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Association lists} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L389">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">assoc</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b<br/></li>
<li></span><span class="Comment">(** [<a href="list.mli.html#L389" title="ocaml/stdlib/list.mli:389">assoc</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns the value associated with <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in the list of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; pairs [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]. That is,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="list.mli.html#L389" title="ocaml/stdlib/list.mli:389">assoc</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [ ...; (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>,b); ...] = b]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if [(<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>,b)] is the leftmost binding of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Not_found if there is no value associated with [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L398">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">assoc_opt</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="list.mli.html#L398" title="ocaml/stdlib/list.mli:398">assoc_opt</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns the value associated with <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in the list of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; pairs [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]. That is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="list.mli.html#L398" title="ocaml/stdlib/list.mli:398">assoc_opt</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [ ...; (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>,b); ...] = Some b]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; if [(<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>,b)] is the leftmost binding of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Returns [None] if there is no value associated with [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L408">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">assq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="list.mli.html#L389" title="ocaml/stdlib/list.mli:389">assoc</a>}, but uses physical equality instead of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; structural equality to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> keys.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L413">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">assq_opt</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="list.mli.html#L398" title="ocaml/stdlib/list.mli:398">assoc_opt</a>}, but uses physical equality instead of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; structural equality to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> keys.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L419">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mem_assoc</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a></span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="list.mli.html#L389" title="ocaml/stdlib/list.mli:389">assoc</a>}, but simply <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> [true] if <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and [false] if no <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> exist for the given <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L424">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mem_assq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a></span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="list.mli.html#L419" title="ocaml/stdlib/list.mli:419">mem_assoc</a>}, but uses physical equality instead of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; structural equality to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> keys.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L429">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">remove_assoc</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="list.mli.html#L429" title="ocaml/stdlib/list.mli:429">remove_assoc</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns the list of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; pairs [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] without the first pair with <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], if any.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Not tail-recursive.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L435">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">remove_assq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="list.mli.html#L429" title="ocaml/stdlib/list.mli:429">remove_assoc</a>}, but uses physical equality instead<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of structural equality to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> keys. Not tail-recursive.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Lists of pairs} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L444">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">split</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Transform <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of pairs into <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of lists:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> [(<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>,<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>); ...; (an,bn)]] is [([<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an], [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn])].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Not tail-recursive.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L450">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">combine</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Transform <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of lists into <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of pairs:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="array.mli.html#L284" title="ocaml/stdlib/array.mli:284">combine</a> [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an] [<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>; ...; bn]] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [[(<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>,<a href="bytes.ml.html#L608" title="ocaml/stdlib/bytes.ml:608">b1</a>); ...; (an,bn)]].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the two lists<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; have different lengths. Not tail-recursive.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Sorting} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L462">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Sort <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list in increasing order according to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> comparison<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function. The comparison function must <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> 0 if its arguments<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> as <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> positive integer if the first is greater,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> negative integer if the first is smaller (see Array.<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a> for<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> complete specification). For example,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>} is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable comparison function.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The resulting list is sorted in increasing order.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>} is guaranteed to run in constant heap space<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (in addition to the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> list) and logarithmic<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Merge Sort. It runs in constant<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; heap space and logarithmic <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L478">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stable_sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}, but the sorting algorithm is guaranteed to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; be stable (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> that <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> are kept in their<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; original order).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Merge Sort. It runs in constant<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; heap space and logarithmic <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L487">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fast_sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>} or {!<a href="array.mli.html#L317" title="ocaml/stdlib/array.mli:317">stable_sort</a>}, whichever is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; faster on typical <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L492">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sort_uniq</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}, but also <a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> duplicates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02 (4.03 in ListLabels)<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L497">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">merge</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Merge two lists:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Assuming that [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] and [<a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>] are sorted according to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; comparison function [cmp], [<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a> ~cmp <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a> <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>] will <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sorted list containing all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] and [<a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If several <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Not tail-recursive (sum of the lengths of the arguments).<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Lists and Sequences} *)<br/></li>
<li></span><br/></li>
<li><a id="L509">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_seq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Iterate on the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.07<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L514">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">of_seq</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** Create <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list from <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.07<br/></li>
<li></span><span class="Comment"> *)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
