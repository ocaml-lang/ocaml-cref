<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/bytesLabels.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/bytesLabels.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L127">blit</a></li>
<li><a href="#L139">blit_string</a></li>
<li><a href="#L294">capitalize_ascii</a></li>
<li><a href="#L158">cat</a></li>
<li><a href="#L307">compare</a></li>
<li><a href="#L150">concat</a></li>
<li><a href="#L269">contains</a></li>
<li><a href="#L272">contains_from</a></li>
<li><a href="#L89">copy</a></li>
<li><a href="#L86">empty</a></li>
<li><a href="#L324">ends_with</a></li>
<li><a href="#L313">equal</a></li>
<li><a href="#L211">escaped</a></li>
<li><a href="#L201">exists</a></li>
<li><a href="#L111">extend</a></li>
<li><a href="#L121">fill</a></li>
<li><a href="#L185">fold_left</a></li>
<li><a href="#L191">fold_right</a></li>
<li><a href="#L197">for_all</a></li>
<li><a href="#L609">get_int16_be</a></li>
<li><a href="#L615">get_int16_le</a></li>
<li><a href="#L603">get_int16_ne</a></li>
<li><a href="#L627">get_int32_be</a></li>
<li><a href="#L633">get_int32_le</a></li>
<li><a href="#L621">get_int32_ne</a></li>
<li><a href="#L645">get_int64_be</a></li>
<li><a href="#L651">get_int64_le</a></li>
<li><a href="#L639">get_int64_ne</a></li>
<li><a href="#L580">get_int8</a></li>
<li><a href="#L591">get_uint16_be</a></li>
<li><a href="#L597">get_uint16_le</a></li>
<li><a href="#L585">get_uint16_ne</a></li>
<li><a href="#L575">get_uint8</a></li>
<li><a href="#L513">get_utf_16be_uchar</a></li>
<li><a href="#L530">get_utf_16le_uchar</a></li>
<li><a href="#L496">get_utf_8_uchar</a></li>
<li><a href="#L219">index</a></li>
<li><a href="#L239">index_from</a></li>
<li><a href="#L246">index_from_opt</a></li>
<li><a href="#L224">index_opt</a></li>
<li><a href="#L80">init</a></li>
<li><a href="#L524">is_valid_utf_16be</a></li>
<li><a href="#L541">is_valid_utf_16le</a></li>
<li><a href="#L507">is_valid_utf_8</a></li>
<li><a href="#L165">iter</a></li>
<li><a href="#L170">iteri</a></li>
<li><a href="#L289">lowercase_ascii</a></li>
<li><a href="#L75">make</a></li>
<li><a href="#L175">map</a></li>
<li><a href="#L180">mapi</a></li>
<li><a href="#L486">of_seq</a></li>
<li><a href="#L93">of_string</a></li>
<li><a href="#L278">rcontains_from</a></li>
<li><a href="#L229">rindex</a></li>
<li><a href="#L254">rindex_from</a></li>
<li><a href="#L261">rindex_from_opt</a></li>
<li><a href="#L234">rindex_opt</a></li>
<li><a href="#L693">set_int16_be</a></li>
<li><a href="#L699">set_int16_le</a></li>
<li><a href="#L687">set_int16_ne</a></li>
<li><a href="#L711">set_int32_be</a></li>
<li><a href="#L717">set_int32_le</a></li>
<li><a href="#L705">set_int32_ne</a></li>
<li><a href="#L729">set_int64_be</a></li>
<li><a href="#L735">set_int64_le</a></li>
<li><a href="#L723">set_int64_ne</a></li>
<li><a href="#L663">set_int8</a></li>
<li><a href="#L675">set_uint16_be</a></li>
<li><a href="#L681">set_uint16_le</a></li>
<li><a href="#L669">set_uint16_ne</a></li>
<li><a href="#L657">set_uint8</a></li>
<li><a href="#L517">set_utf_16be_uchar</a></li>
<li><a href="#L534">set_utf_16le_uchar</a></li>
<li><a href="#L500">set_utf_8_uchar</a></li>
<li><a href="#L460">split_on_char</a></li>
<li><a href="#L317">starts_with</a></li>
<li><a href="#L101">sub</a></li>
<li><a href="#L108">sub_string</a></li>
<li><a href="#L477">to_seq</a></li>
<li><a href="#L482">to_seqi</a></li>
<li><a href="#L97">to_string</a></li>
<li><a href="#L206">trim</a></li>
<li><a href="#L299">uncapitalize_ascii</a></li>
<li><a href="#L416">unsafe_of_string</a></li>
<li><a href="#L340">unsafe_to_string</a></li>
<li><a href="#L284">uppercase_ascii</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L304">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* </span><span class="Todo">NOTE</span><span class="Comment">:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is bytesLabels.mli, run tools/sync_stdlib_docs after editing it<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to generate <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.mli.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.mli, do not edit it directly -- edit<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; bytesLabels.mli instead.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Byte sequence operations.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; A byte sequence is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> mutable <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> structure that <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; fixed-<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> sequence of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>. Each byte can be indexed in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; constant time for reading or writing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>], we can access each of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] via its <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> in the sequence. Indexes <a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a> at<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [0], and we will call an <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> valid in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] if it falls within the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; range [[0...<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>-1]] (inclusive). A <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> is the point between two<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> or at the beginning or end of the sequence.&nbsp; We call <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> valid in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] if it falls within the range [[0...<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (inclusive). Note that the byte at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is between positions<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] and [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>+1].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Two parameters [<a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] are said to designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; range of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] if [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &gt;= 0] and [<a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a>] and [<a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a>+<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] are valid<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; positions in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Byte sequences can be modified in place, for instance via the [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and [<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a>] functions described below.&nbsp; See also strings (module<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!String}), which are almost the same <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> structure, but cannot be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; modified in place.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Bytes are represented by the OCaml type [<a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The labeled version of this module can be used as described in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!StdLabels} module.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.02<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%bytes_length&quot;<br/></li>
<li></span><span class="Comment">(** Return the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> (number of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>) of the argument. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%bytes_safe_get&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns the byte at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] in argument [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%bytes_safe_set&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] modifies [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] in place, replacing the byte at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; with [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_create_bytes&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new byte sequence of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence is uninitialized and <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> arbitrary <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; ]{!Sys.<a href="sys.mli.html#L185" title="ocaml/stdlib/sys.mli:185">max_string_length</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L75">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">make</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new byte sequence of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>], filled with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; ]{!Sys.<a href="sys.mli.html#L185" title="ocaml/stdlib/sys.mli:185">max_string_length</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L80">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">init</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> f] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh byte sequence of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; with character [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] initialized to the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of [f <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] (in increasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> order).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; ]{!Sys.<a href="sys.mli.html#L185" title="ocaml/stdlib/sys.mli:185">max_string_length</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L86">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">empty</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** A byte sequence of <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 0. *)<br/></li>
<li></span><br/></li>
<li><a id="L89">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">copy</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new byte sequence that <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the same <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L93">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">of_string</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new byte sequence that <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the same <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L97">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_string</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> that <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the same <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> as the given byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence. *)<br/></li>
<li></span><br/></li>
<li><a id="L101">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sub</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> ~<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new byte sequence of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; containing the subsequence of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that starts at <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and has <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; valid range of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L108">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sub_string</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a>} but <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> instead of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence. *)<br/></li>
<li></span><br/></li>
<li><a id="L111">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">extend</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L111" title="ocaml/stdlib/bytesLabels.mli:111">extend</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> ~<a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> ~<a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new byte sequence that <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], with [<a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a>] uninitialized <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> prepended and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>] uninitialized <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> appended to it. If [<a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a>] or [<a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is negative, then <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> are removed (instead of appended) from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the corresponding side of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> is negative or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; longer than {!Sys.<a href="sys.mli.html#L185" title="ocaml/stdlib/sys.mli:185">max_string_length</a>} <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05 in BytesLabels *)<br/></li>
<li></span><br/></li>
<li><a id="L121">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fill</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L121" title="ocaml/stdlib/bytesLabels.mli:121">fill</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> ~<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] modifies [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] in place, replacing [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; characters with [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>], starting at [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; valid range of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L127">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">blit</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">src</span>:<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">src_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst</span>:<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span>&nbsp; <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> ~src ~src_pos ~dst ~dst_pos ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] copies [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> from byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence [src], starting at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [src_pos], to byte sequence [dst],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [dst_pos]. It works correctly even if [src] and [dst] are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the same byte sequence, and the source and destination intervals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; overlap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [src_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of [src], or if [dst_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of [dst]. *)<br/></li>
<li></span><br/></li>
<li><a id="L139">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">blit_string</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">src</span>:<span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">src_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst</span>:<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span>&nbsp; <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L139" title="ocaml/stdlib/bytesLabels.mli:139">blit_string</a> ~src ~src_pos ~dst ~dst_pos ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] copies [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [src], starting at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [src_pos], to byte sequence [dst],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [dst_pos].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [src_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of [src], or if [dst_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of [dst].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05 in BytesLabels *)<br/></li>
<li></span><br/></li>
<li><a id="L150">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">concat</span></span> : <span class="ocamlLCIdentifier">sep</span>:<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** [<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a> ~sep sl] concatenates the list of byte sequences [sl],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; inserting the separator byte sequence [sep] between each, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; returns the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new byte sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is longer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Sys.<a href="sys.mli.html#L185" title="ocaml/stdlib/sys.mli:185">max_string_length</a>} <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L158">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">cat</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L158" title="ocaml/stdlib/bytesLabels.mli:158">cat</a> <a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a> <a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] concatenates [<a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>] and [<a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] and returns the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new byte sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is longer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Sys.<a href="sys.mli.html#L185" title="ocaml/stdlib/sys.mli:185">max_string_length</a>} <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05 in BytesLabels *)<br/></li>
<li></span><br/></li>
<li><a id="L165">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] applies function [f] in turn to all the <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; It is equivalent to [f (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 0); f (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 1); ...; f (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> - 1)); ()]. *)<br/></li>
<li></span><br/></li>
<li><a id="L170">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iteri</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>}, but the function is applied to the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the byte as first argument and the byte itself as second<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L175">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] applies function [f] in turn to all the <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] (in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; increasing <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> order) and stores the resulting <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new sequence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; that is returned as the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L180">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mapi</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L180" title="ocaml/stdlib/bytesLabels.mli:180">mapi</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] calls [f] with each character of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> (in increasing <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> order) and stores the resulting <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new sequence that is returned as the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L185">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [f (... (f (f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 0)) (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 1)) ...) (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> (<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1))],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L191">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_right</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L191" title="ocaml/stdlib/bytesLabels.mli:191">fold_right</a> f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [f (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 0) (f (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 1) ( ... (f (<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> (<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1)) <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>) ...))],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L197">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">for_all</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] checks if all characters in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] satisfy the predicate [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L201">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exists</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] checks if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> character of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] satisfies the predicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L206">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">trim</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the argument, without leading and trailing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; whitespace. The <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> regarded as whitespace are the ASCII<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; characters [' '], ['\012'], ['\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>'], ['\<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>'], and ['\<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>']. *)<br/></li>
<li></span><br/></li>
<li><a id="L211">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">escaped</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the argument, with special characters represented<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; by escape sequences, following the lexical conventions of OCaml.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; All characters outside the ASCII printable range (32..126) are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="#L211" title="ocaml/stdlib/bytesLabels.mli:211">escaped</a>, as well as backslash and double-<a href="filename.mli.html#L200" title="ocaml/stdlib/filename.mli:200">quote</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is longer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Sys.<a href="sys.mli.html#L185" title="ocaml/stdlib/sys.mli:185">max_string_length</a>} <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L219">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">index</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first occurrence of byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Not_found if [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] does not occur in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L224">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">index_opt</span></span>: <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="#L224" title="ocaml/stdlib/bytesLabels.mli:224">index_opt</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first occurrence of byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] or [None] if [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] does not occur in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L229">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rindex</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L229" title="ocaml/stdlib/bytesLabels.mli:229">rindex</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> occurrence of byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Not_found if [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] does not occur in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L234">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rindex_opt</span></span>: <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="#L234" title="ocaml/stdlib/bytesLabels.mli:234">rindex_opt</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> occurrence of byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] or [None] if [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] does not occur in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L239">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">index_from</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L239" title="ocaml/stdlib/bytesLabels.mli:239">index_from</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first occurrence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] after <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].&nbsp; [<a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; equivalent to [<a href="#L239" title="ocaml/stdlib/bytesLabels.mli:239">index_from</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 0 <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Not_found if [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] does not occur in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] after <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L246">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">index_from_opt</span></span>: <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="#L246" title="ocaml/stdlib/bytesLabels.mli:246">index_from_opt</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first occurrence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] after <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] or [None] if [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] does not occur in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; after <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="#L224" title="ocaml/stdlib/bytesLabels.mli:224">index_opt</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] is equivalent to [<a href="#L246" title="ocaml/stdlib/bytesLabels.mli:246">index_from_opt</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 0 <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L254">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rindex_from</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L254" title="ocaml/stdlib/bytesLabels.mli:254">rindex_from</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> occurrence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>+1].&nbsp; [<a href="#L229" title="ocaml/stdlib/bytesLabels.mli:229">rindex</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] is equivalent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to [<a href="#L254" title="ocaml/stdlib/bytesLabels.mli:254">rindex_from</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> (<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> - 1) <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>+1] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Not_found if [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] does not occur in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>+1]. *)<br/></li>
<li></span><br/></li>
<li><a id="L261">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rindex_from_opt</span></span>: <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="#L261" title="ocaml/stdlib/bytesLabels.mli:261">rindex_from_opt</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] returns the <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> occurrence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>+1] or [None] if [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; occur in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>+1].&nbsp; [<a href="#L234" title="ocaml/stdlib/bytesLabels.mli:234">rindex_opt</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="#L254" title="ocaml/stdlib/bytesLabels.mli:254">rindex_from</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> (<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> - 1) <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>+1] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L269">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">contains</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] tests if byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] appears in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L272">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">contains_from</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L272" title="ocaml/stdlib/bytesLabels.mli:272">contains_from</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] tests if byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] appears in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a>].&nbsp; [<a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] is equivalent to [<a href="#L272" title="ocaml/stdlib/bytesLabels.mli:272">contains_from</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> 0 <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a>] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L278">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">rcontains_from</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L278" title="ocaml/stdlib/bytesLabels.mli:278">rcontains_from</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="gc.mli.html#L527" title="ocaml/stdlib/gc.mli:527">stop</a> <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] tests if byte [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] appears in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="gc.mli.html#L527" title="ocaml/stdlib/gc.mli:527">stop</a>+1].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="gc.mli.html#L527" title="ocaml/stdlib/gc.mli:527">stop</a> &lt; 0] or [<a href="gc.mli.html#L527" title="ocaml/stdlib/gc.mli:527">stop</a>+1] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L284">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">uppercase_ascii</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the argument, with all lowercase letters<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; translated to uppercase, using the US-ASCII character <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.03 (4.05 in BytesLabels) *)<br/></li>
<li></span><br/></li>
<li><a id="L289">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">lowercase_ascii</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the argument, with all uppercase letters<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; translated to lowercase, using the US-ASCII character <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.03 (4.05 in BytesLabels) *)<br/></li>
<li></span><br/></li>
<li><a id="L294">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">capitalize_ascii</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the argument, with the first character <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to uppercase,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; using the US-ASCII character <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.03 (4.05 in BytesLabels) *)<br/></li>
<li></span><br/></li>
<li><a id="L299">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">uncapitalize_ascii</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the argument, with the first character <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to lowercase,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; using the US-ASCII character <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.03 (4.05 in BytesLabels) *)<br/></li>
<li></span><br/></li>
<li><a id="L304">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">t</span></span> <span class="Statement">=</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** An alias for the type of byte sequences. *)<br/></li>
<li></span><br/></li>
<li><a id="L307">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">compare</span></span>: <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** The comparison function for byte sequences, with the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; specification as {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>}.&nbsp; Along with the type [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; this function [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] allows the module [Bytes] to be passed as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument to the functors {!Set.Make} and {!Map.Make}. *)<br/></li>
<li></span><br/></li>
<li><a id="L313">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">equal</span></span>: <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** The equality function for byte sequences.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.03 (4.05 in BytesLabels) *)<br/></li>
<li></span><br/></li>
<li><a id="L317">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">starts_with</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">prefix</span> <span class="Comment">(* comment thwarts tools/sync_stdlib_docs *)</span> :<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L317" title="ocaml/stdlib/bytesLabels.mli:317">starts_with</a> ][~prefix <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is [true] if and only if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] starts with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [prefix].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L324">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">ends_with</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">suffix</span> <span class="Comment">(* comment thwarts tools/sync_stdlib_docs *)</span> :<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L324" title="ocaml/stdlib/bytesLabels.mli:324">ends_with</a> ][~suffix <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is [true] if and only if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] ends with [suffix].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:unsafe Unsafe conversions (for advanced users)}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This section describes unsafe, low-level conversion functions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; between [<a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>] and [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>]. They do not <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> the internal <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; used improperly, they can break the immutability invariant on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; strings provided by the [-safe-<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>] option. They are available for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; expert library authors, but for most purposes you should use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; always-correct {!<a href="int32.ml.html#L72" title="ocaml/stdlib/int32.ml:72">to_string</a>} and {!<a href="#L93" title="ocaml/stdlib/bytesLabels.mli:93">of_string</a>} instead.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L340">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">unsafe_to_string</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Unsafely convert <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence into <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; To reason about the use of [<a href="#L340" title="ocaml/stdlib/bytesLabels.mli:340">unsafe_to_string</a>], it is convenient to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; consider an &quot;ownership&quot; discipline. A piece of code that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; manipulates <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> &quot;owns&quot; it; there are several <a href="set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a> ownership<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; modes, including:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - Unique ownership: the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> may be accessed and mutated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - Shared ownership: the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> has several owners, that may only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; access it, not mutate it.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Unique ownership is linear: passing the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> to another piece of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; code means giving up ownership (we cannot write the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> again). A unique owner may decide to <a href="#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (giving up mutation rights on it), but shared <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> may not become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; uniquely-owned again.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; [<a href="#L340" title="ocaml/stdlib/bytesLabels.mli:340">unsafe_to_string</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] can only be used when the caller owns the byte<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; sequence [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] -- either uniquely or as shared immutable <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>. The<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; caller gives up ownership of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], and gains ownership of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; returned <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; There are two valid use-cases that respect this ownership<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; discipline:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; 1. Creating <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> by initializing and mutating <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that is never changed after initialization is performed.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment">let string_init <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> f : <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> =<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> = Bytes.<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> in<br/></li>
<li></span><span class="Comment">&nbsp; for <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> = 0 to <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1 do Bytes.<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> (f <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>) done;<br/></li>
<li></span><span class="Comment">&nbsp; Bytes.<a href="#L340" title="ocaml/stdlib/bytesLabels.mli:340">unsafe_to_string</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This function is safe because the byte sequence [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] will never be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; accessed or mutated after [<a href="#L340" title="ocaml/stdlib/bytesLabels.mli:340">unsafe_to_string</a>] is called. The<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [string_init] code gives up ownership of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], and returns the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ownership of the resulting <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> to its caller.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Note that it would be unsafe if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] was passed as an additional<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; parameter to the function [f] as it could escape this way and be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mutated in the future -- [string_init] would give up ownership of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] to pass it to [f], and could not call [<a href="#L340" title="ocaml/stdlib/bytesLabels.mli:340">unsafe_to_string</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; safely.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; We have provided the {!String.<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>}, {!String.<a href="#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>} and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!String.<a href="#L180" title="ocaml/stdlib/bytesLabels.mli:180">mapi</a>} functions to cover most cases of building<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; new strings. You should prefer those over [<a href="int32.ml.html#L72" title="ocaml/stdlib/int32.ml:72">to_string</a>] or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L340" title="ocaml/stdlib/bytesLabels.mli:340">unsafe_to_string</a>] whenever applicable.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; 2. Temporarily giving ownership of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> function<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that expects <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> uniquely owned <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> and returns ownership back, so<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that we can mutate the sequence again after the call ended.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment">let bytes_length (<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> : <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>) =<br/></li>
<li></span><span class="Comment">&nbsp; String.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> (Bytes.<a href="#L340" title="ocaml/stdlib/bytesLabels.mli:340">unsafe_to_string</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; In this use-case, we do not promise that [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] will never be mutated<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; after the call to [bytes_length <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. The {!String.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>} function<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; temporarily borrows unique ownership of the byte sequence<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (and sees it as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>]), but returns this ownership back to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the caller, which may assume that [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is still <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid byte<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; sequence after the call. Note that this is only correct because we<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; know that {!String.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>} does not capture its argument -- it could<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; escape by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> side-channel such as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> memoization combinator.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The caller may not mutate [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] while the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is borrowed (it has<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; temporarily given up ownership). This affects concurrent programs,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; but also higher-order functions: if {!String.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>} returned<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalOO.ml.html#L59" title="ocaml/stdlib/camlinternalOO.ml:59">closure</a> to be called later, [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] should not be mutated until this<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalOO.ml.html#L59" title="ocaml/stdlib/camlinternalOO.ml:59">closure</a> is fully applied and returns ownership.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L416">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">unsafe_of_string</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">(** Unsafely convert <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> shared <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence that should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; not be mutated.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The same ownership discipline that makes [<a href="#L340" title="ocaml/stdlib/bytesLabels.mli:340">unsafe_to_string</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; correct applies to [<a href="#L416" title="ocaml/stdlib/bytesLabels.mli:416">unsafe_of_string</a>]: you may use it if you were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the owner of the [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>] value, and you will own the <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>] in the same mode.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; In practice, unique ownership of <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> values is extremely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; difficult to reason about correctly. You should always assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; strings are shared, never uniquely owned.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For example, <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> literals are implicitly shared by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; compiler, so you never uniquely own them.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">let incorrect = Bytes.<a href="#L416" title="ocaml/stdlib/bytesLabels.mli:416">unsafe_of_string</a> &quot;hello&quot;<br/></li>
<li></span><span class="Comment">let <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> = Bytes.<a href="#L93" title="ocaml/stdlib/bytesLabels.mli:93">of_string</a> &quot;hello&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The first declaration is incorrect, because the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> literal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [&quot;hello&quot;] could be shared by the compiler with other parts of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; program, and mutating [incorrect] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> bug. You must always use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the second version, which performs <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> and is thus correct.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Assuming unique ownership of strings that are not <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; literals, but are (partly) built from <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> literals, is also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; incorrect. For example, mutating [<a href="#L416" title="ocaml/stdlib/bytesLabels.mli:416">unsafe_of_string</a> (&quot;foo&quot; ^ <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; could mutate the shared <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [&quot;foo&quot;] -- assuming <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> rope-like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; representation of strings. More generally, functions operating on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; strings will assume shared ownership, they do not preserve unique<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ownership. It is thus incorrect to assume unique ownership of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of [<a href="#L416" title="ocaml/stdlib/bytesLabels.mli:416">unsafe_of_string</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The only case we have reasonable confidence is safe is if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; produced [<a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>] is shared -- used as an immutable byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence. This is possibly useful for incremental migration of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; low-level programs that manipulate immutable sequences of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (for example {!Marshal.<a href="marshal.ml.html#L55" title="ocaml/stdlib/marshal.ml:55">from_bytes</a>}) and previously used the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>] type for this purpose.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L460">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">split_on_char</span></span>: <span class="ocamlLCIdentifier">sep</span>:<span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="#L460" title="ocaml/stdlib/bytesLabels.mli:460">split_on_char</a> sep <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the list of all (possibly <a href="#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; subsequences of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that are delimited by the [sep] character.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The function'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> is specified by the following invariants:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - The list is not <a href="#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - Concatenating its <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> using [sep] as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> separator returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; byte sequence <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> ([Bytes.<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a> (Bytes.<a href="#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> 1 sep)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (Bytes.<a href="#L460" title="ocaml/stdlib/bytesLabels.mli:460">split_on_char</a> sep <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>) = <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - No byte sequence in the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the [sep] character.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Iterators} *)<br/></li>
<li></span><br/></li>
<li><a id="L477">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_seq</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Iterate on the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>, in increasing <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> order. Modifications of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> during iteration will be reflected in the sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><a id="L482">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_seqi</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span><span class="Statement">)</span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Iterate on the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>, in increasing order, yielding indices along chars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><a id="L486">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">of_seq</span></span> : <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Create <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> from the generator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:utf UTF codecs and validations}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2:utf_8 UTF-8} *)<br/></li>
<li></span><br/></li>
<li><a id="L496">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_utf_8_uchar</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="PreProc">Uchar</span>.<span class="ocamlLCIdentifier"><a href="uchar.mli.html#L105" title="ocaml/stdlib/uchar.mli:105">utf_decode</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L496" title="ocaml/stdlib/bytesLabels.mli:496">get_utf_8_uchar</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] decodes an UTF-8 character at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [b]. *)<br/></li>
<li></span><br/></li>
<li><a id="L500">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_utf_8_uchar</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="PreProc">Uchar</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L500" title="ocaml/stdlib/bytesLabels.mli:500">set_utf_8_uchar</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> u] UTF-8 encodes [u] at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] in [b]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and returns the number of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] that were written starting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>]. If [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is [0] there was not enough space to encode [u]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] and [b] was <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> untouched. Otherwise <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new character can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; be encoded at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> + <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L507">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">is_valid_utf_8</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L507" title="ocaml/stdlib/bytesLabels.mli:507">is_valid_utf_8</a> b] is [true] if and only if [b] <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; UTF-8 <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2:utf_16be UTF-16BE} *)<br/></li>
<li></span><br/></li>
<li><a id="L513">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_utf_16be_uchar</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="PreProc">Uchar</span>.<span class="ocamlLCIdentifier"><a href="uchar.mli.html#L105" title="ocaml/stdlib/uchar.mli:105">utf_decode</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L513" title="ocaml/stdlib/bytesLabels.mli:513">get_utf_16be_uchar</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] decodes an UTF-16BE character at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] in [b]. *)<br/></li>
<li></span><br/></li>
<li><a id="L517">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_utf_16be_uchar</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="PreProc">Uchar</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L517" title="ocaml/stdlib/bytesLabels.mli:517">set_utf_16be_uchar</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> u] UTF-16BE encodes [u] at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] in [b]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and returns the number of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] that were written starting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>]. If [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is [0] there was not enough space to encode [u]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] and [b] was <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> untouched. Otherwise <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new character can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; be encoded at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> + <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L524">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">is_valid_utf_16be</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L524" title="ocaml/stdlib/bytesLabels.mli:524">is_valid_utf_16be</a> b] is [true] if and only if [b] <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; UTF-16BE <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2:utf_16le UTF-16LE} *)<br/></li>
<li></span><br/></li>
<li><a id="L530">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_utf_16le_uchar</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="PreProc">Uchar</span>.<span class="ocamlLCIdentifier"><a href="uchar.mli.html#L105" title="ocaml/stdlib/uchar.mli:105">utf_decode</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L530" title="ocaml/stdlib/bytesLabels.mli:530">get_utf_16le_uchar</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] decodes an UTF-16LE character at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] in [b]. *)<br/></li>
<li></span><br/></li>
<li><a id="L534">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_utf_16le_uchar</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="PreProc">Uchar</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L534" title="ocaml/stdlib/bytesLabels.mli:534">set_utf_16le_uchar</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> u] UTF-16LE encodes [u] at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] in [b]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and returns the number of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] that were written starting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>]. If [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is [0] there was not enough space to encode [u]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] and [b] was <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> untouched. Otherwise <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new character can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; be encoded at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> + <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L541">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">is_valid_utf_16le</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L541" title="ocaml/stdlib/bytesLabels.mli:541">is_valid_utf_16le</a> b] is [true] if and only if [b] <a href="#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; UTF-16LE <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Binary encoding/decoding of integers} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The functions in this section binary encode and decode integers to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and from byte sequences.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; All following functions raise [Invalid_argument] if the space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; needed at <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to decode or encode the integer is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; available.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Little-endian (resp. big-endian) encoding means that least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (resp. most) significant <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> are stored first.&nbsp; Big-endian is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; also known as network byte order.&nbsp; Native-endian encoding is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; either little-endian or big-endian depending on {!Sys.<a href="sys.mli.html#L181" title="ocaml/stdlib/sys.mli:181">big_endian</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; 32-bit and 64-bit integers are represented by the [<a href="bigarray.mli.html#L179" title="ocaml/stdlib/bigarray.mli:179">int32</a>] and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a>] types, which can be interpreted either as signed or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; unsigned numbers.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; 8-bit and 16-bit integers are represented by the [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] type,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; which has more <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a> than the binary encoding.&nbsp; These extra <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; are handled as follows:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {ul<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {- Functions that decode signed (resp. unsigned) 8-bit or 16-bit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; integers represented by [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] values sign-<a href="#L111" title="ocaml/stdlib/bytesLabels.mli:111">extend</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; (resp. <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>-<a href="#L111" title="ocaml/stdlib/bytesLabels.mli:111">extend</a>) their <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>.}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {- Functions that encode 8-bit or 16-bit integers represented by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] values <a href="buffer.ml.html#L285" title="ocaml/stdlib/buffer.ml:285">truncate</a> their <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> to their least significant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.}}<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L575">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_uint8</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L575" title="ocaml/stdlib/bytesLabels.mli:575">get_uint8</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> unsigned 8-bit integer starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L580">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int8</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L580" title="ocaml/stdlib/bytesLabels.mli:580">get_int8</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> signed 8-bit integer starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L585">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_uint16_ne</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L585" title="ocaml/stdlib/bytesLabels.mli:585">get_uint16_ne</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> native-endian unsigned 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L591">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_uint16_be</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L591" title="ocaml/stdlib/bytesLabels.mli:591">get_uint16_be</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> big-endian unsigned 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L597">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_uint16_le</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L597" title="ocaml/stdlib/bytesLabels.mli:597">get_uint16_le</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> little-endian unsigned 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L603">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int16_ne</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L603" title="ocaml/stdlib/bytesLabels.mli:603">get_int16_ne</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> native-endian signed 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L609">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int16_be</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L609" title="ocaml/stdlib/bytesLabels.mli:609">get_int16_be</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> big-endian signed 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L615">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int16_le</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L615" title="ocaml/stdlib/bytesLabels.mli:615">get_int16_le</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> little-endian signed 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L621">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int32_ne</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L179" title="ocaml/stdlib/bigarray.mli:179">int32</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L621" title="ocaml/stdlib/bytesLabels.mli:621">get_int32_ne</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> native-endian 32-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L627">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int32_be</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L179" title="ocaml/stdlib/bigarray.mli:179">int32</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L627" title="ocaml/stdlib/bytesLabels.mli:627">get_int32_be</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> big-endian 32-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L633">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int32_le</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L179" title="ocaml/stdlib/bigarray.mli:179">int32</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L633" title="ocaml/stdlib/bytesLabels.mli:633">get_int32_le</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> little-endian 32-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L639">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int64_ne</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L639" title="ocaml/stdlib/bytesLabels.mli:639">get_int64_ne</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> native-endian 64-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L645">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int64_be</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L645" title="ocaml/stdlib/bytesLabels.mli:645">get_int64_be</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> big-endian 64-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L651">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_int64_le</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L651" title="ocaml/stdlib/bytesLabels.mli:651">get_int64_le</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> little-endian 64-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L657">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_uint8</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L657" title="ocaml/stdlib/bytesLabels.mli:657">set_uint8</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> unsigned 8-bit integer starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L663">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int8</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L663" title="ocaml/stdlib/bytesLabels.mli:663">set_int8</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> signed 8-bit integer starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L669">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_uint16_ne</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L669" title="ocaml/stdlib/bytesLabels.mli:669">set_uint16_ne</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> native-endian unsigned 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L675">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_uint16_be</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L675" title="ocaml/stdlib/bytesLabels.mli:675">set_uint16_be</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> big-endian unsigned 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L681">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_uint16_le</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L681" title="ocaml/stdlib/bytesLabels.mli:681">set_uint16_le</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> little-endian unsigned 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L687">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int16_ne</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L687" title="ocaml/stdlib/bytesLabels.mli:687">set_int16_ne</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> native-endian signed 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L693">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int16_be</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L693" title="ocaml/stdlib/bytesLabels.mli:693">set_int16_be</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> big-endian signed 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L699">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int16_le</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L699" title="ocaml/stdlib/bytesLabels.mli:699">set_int16_le</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> little-endian signed 16-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L705">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int32_ne</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L179" title="ocaml/stdlib/bigarray.mli:179">int32</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L705" title="ocaml/stdlib/bytesLabels.mli:705">set_int32_ne</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> native-endian 32-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L711">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int32_be</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L179" title="ocaml/stdlib/bigarray.mli:179">int32</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L711" title="ocaml/stdlib/bytesLabels.mli:711">set_int32_be</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> big-endian 32-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L717">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int32_le</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L179" title="ocaml/stdlib/bigarray.mli:179">int32</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L717" title="ocaml/stdlib/bytesLabels.mli:717">set_int32_le</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> little-endian 32-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L723">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int64_ne</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L723" title="ocaml/stdlib/bytesLabels.mli:723">set_int64_ne</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> native-endian 64-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L729">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int64_be</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L729" title="ocaml/stdlib/bytesLabels.mli:729">set_int64_be</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> big-endian 64-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L735">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_int64_le</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L735" title="ocaml/stdlib/bytesLabels.mli:735">set_int64_le</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets [b]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> little-endian 64-bit integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at byte <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1:bytes_concurrency Byte sequences and concurrency safety}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Care must be taken when concurrently accessing byte sequences from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; multiple domains: accessing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence will never crash <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> program,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; but unsynchronized accesses might yield surprising<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (non-sequentially-consistent) results.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:byte_atomicity Atomicity}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Every byte sequence operation that accesses more than <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> byte is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; atomic. This includes iteration and scanning.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For example, consider the following program:<br/></li>
<li></span><span class="Comment">{[let <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> = 100_000_000<br/></li>
<li></span><span class="Comment">let b = Bytes.<a href="#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>&nbsp; ' '<br/></li>
<li></span><span class="Comment">let <a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> b f ()&nbsp; =<br/></li>
<li></span><span class="Comment">&nbsp; Bytes.<a href="#L170" title="ocaml/stdlib/bytesLabels.mli:170">iteri</a> (fun <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; Bytes.<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> b <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> (Char.<a href="char.mli.html#L21" title="ocaml/stdlib/char.mli:21">chr</a> (f (Char.code <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)))) b<br/></li>
<li></span><span class="Comment">let d1 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (<a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> b (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> + 1))<br/></li>
<li></span><span class="Comment">let d2 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (<a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> b (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; 2 * <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> + 1))<br/></li>
<li></span><span class="Comment">let () = Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> sequence [b] may contain <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> non-deterministic mixture<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of ['!'], ['A'], ['B'], and ['C'] values.<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp; &nbsp; After executing this code, each byte of the sequence [b] is either ['!'],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ['A'], ['B'], or ['C']. If atomicity is required, then the user must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; implement their own synchronization (for example, using {!Mutex.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>}).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:bytes_data_race Data races}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If two domains only access <a href="set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a> parts of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; observed behaviour is the equivalent to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sequential interleaving of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; operations from the two domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; A <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> race is said to occur when two domains access the same byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; without synchronization and at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the accesses is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> write.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; In the absence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the observed behaviour is equivalent to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequential interleaving of the operations from different domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Whenever possible, <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races should be avoided by using synchronization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to mediate the accesses to the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the sequence.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Indeed, in the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, programs will not crash but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; observed behaviour may not be equivalent to any sequential interleaving of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; operations from different domains. Nevertheless, even in the presence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> read operation will <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the value of <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> prior write to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; that <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:bytes_mixed_access Mixed-<a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> accesses }<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Another subtle point is that if <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> race involves mixed-<a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> writes and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; reads to the same <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a>, the order in which those writes and reads<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; are observed by domains is not specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For instance, the following code write sequentially <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 32-bit integer and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a>] to the same <a href="#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a><br/></li>
<li></span><span class="Comment">{[<br/></li>
<li></span><span class="Comment">let b = Bytes.<a href="#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> 10 '\000'<br/></li>
<li></span><span class="Comment">let d1 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Bytes.<a href="#L705" title="ocaml/stdlib/bytesLabels.mli:705">set_int32_ne</a> b 0 100; b.[0] &lt;- 'd' )<br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; In this situation, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> domain that observes the write of 'd' to b.[0] is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; guaranteed to also observe the write to indices [1], [2], or [3].<br/></li>
<li></span><br/></li>
<li><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**/**)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* The following is for system use only. Do not call directly. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_get</span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%bytes_unsafe_get&quot;<br/></li>
<li></span><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_set</span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%bytes_unsafe_set&quot;<br/></li>
<li></span><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_blit</span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">src</span>:<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">src_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst</span>:<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_blit_bytes&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_blit_string</span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier">src</span>:<span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">src_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst</span>:<span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst_pos</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span>&nbsp; <span class="Statement">=</span> <span class="Constant">&quot;caml_blit_string&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_fill</span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_fill_bytes&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="bytes.ml.html#L170" title="ocaml/stdlib/bytes.ml:170">unsafe_escape</a></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
