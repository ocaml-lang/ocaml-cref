<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/scanf.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/scanf.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L252">bscanf</a></li>
<li><a href="#L523">bscanf_format</a></li>
<li><a href="#L268">bscanf_opt</a></li>
<li><a href="#L541">format_from_string</a></li>
<li><a href="#L505">kscanf</a></li>
<li><a href="#L515">ksscanf</a></li>
<li><a href="#L495">scanf</a></li>
<li><a href="#L500">scanf_opt</a></li>
<li><a href="#L487">sscanf</a></li>
<li><a href="#L534">sscanf_format</a></li>
<li><a href="#L490">sscanf_opt</a></li>
<li><a href="#L551">unescaped</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L217">scanner</a></li>
<li><a href="#L241">scanner_opt</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Pierre Weis, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2002 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Introduction} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Functional <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> with <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The module {!Scanf} provides formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions or {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> scanners}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions can read from any <a href="bigarray.mli.html#L106" title="ocaml/stdlib/bigarray.mli:106">kind</a> of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>, including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; strings, files, or anything that can <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> characters. The more general<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; source of characters is named <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel} (or {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; scanning <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a>}) and has type {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>}. The more general<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function reads from any scanning <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> and is named<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Generally speaking, the formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions have 3 arguments:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - the first argument is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> source of characters for the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - the second argument is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> that specifies the values to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; read,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - the third argument is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> receiver function} that is applied to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; values read.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Hence, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> typical call to the formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function {!Scanf.<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a>} is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a> ic <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> f], where:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [ic] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> source of characters (typically <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel} with type {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>}),<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> (the same <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings as those used to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; material with module {!Printf} or {!Format}),<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> function that has as many arguments as the number of values to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; read in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> according to [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 A simple example} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** As suggested above, the expression [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a> ic &quot;%d&quot; f] reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> decimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; integer [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] from the source of characters [ic] and returns [f <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For instance,<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - if we use [<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>] as the source of characters ({!Scanning.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>} is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the predefined formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel that reads from standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>),<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - if we define the receiver [f] as [let f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> + 1],<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; then [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a> Scanning.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a> &quot;%d&quot; f] reads an integer [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> and returns [f <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] (that is [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> + 1]). Thus, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; evaluate [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a> <a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a> &quot;%d&quot; f], and then enter [41] at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; keyboard, the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> we <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> is [42].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> functional feature} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The OCaml scanning facility is reminiscent of the corresponding C feature.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; However, it is also largely different, simpler, and yet more powerful:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions are higher-order functionals and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; parameter passing mechanism is just the regular function application not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the variable assignment based mechanism which is typical for formatted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> in imperative languages; the OCaml <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings also feature<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; useful additions to easily define complex tokens; as expected within <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; functional programming language, the formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; support polymorphism, in particular arbitrary interaction with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; polymorphic user-defined scanners. Furthermore, the OCaml formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; facility is fully type-checked at compile time.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {b Unsynchronized accesses} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">[</span>@@@<span class="ocamlLCIdentifier">alert</span> <span class="ocamlLCIdentifier">unsynchronized_access<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">&quot;Unsynchronized accesses to Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a> are <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> programming <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>.&quot;<br/></li>
<li></span><span class="Statement">]<br/></li>
<li></span><br/></li>
<li> <span class="Comment">(**<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Unsynchronized accesses to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} may lead to an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; invalid {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>. Thus, concurrent accesses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>}<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> must be synchronized (for instance with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Mutex.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>}).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> Scanning</span><span class="ocamlPreDef"> : </span><span class="PreProc">sig<br/></li>
<li></span><br/></li>
<li><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** The notion of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel for the {!Scanf} module:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; those channels provide all the machinery necessary to read from any source<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of characters, including <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Stdlib.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} value.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; A Scanf.Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a> value is also called <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; channel} or equivalently <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> scanning <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a>}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The type {!Scanning.<a href="scanf.ml.html#L37" title="ocaml/stdlib/scanf.ml:37">scanbuf</a>} below is an alias for [Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Note that <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>] is not concurrency-safe: concurrent use<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; may produce arbitrary values or exceptions.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L37" title="ocaml/stdlib/scanf.ml:37">scanbuf</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** The type of scanning buffers. A scanning <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> is the source from which <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function gets characters. The scanning <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> holds the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a> of the <a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a>, plus <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> function to <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> the next <a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a> from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>, and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="scanf.ml.html#L80" title="ocaml/stdlib/scanf.ml:80">token</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> to store the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> matched so far.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Note: <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> scanning <a href="arg.ml.html#L169" title="ocaml/stdlib/arg.ml:169">action</a> may often require to examine <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> character in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; advance; when this 'lookahead' character does not belong to the <a href="scanf.ml.html#L80" title="ocaml/stdlib/scanf.ml:80">token</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; read, it is stored back in the scanning <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> and becomes the next<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; character yet to be read.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** The standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> notion for the {!Scanf} module.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [Scanning.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>] is the {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; attached to {!Stdlib.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Note: in the interactive system, when <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> is read from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Stdlib.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>}, the newline character that triggers evaluation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; part of the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>; thus, the scanning specifications must properly skip<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; this additional newline character (for instance, simply <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ['\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>'] as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> character of the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L39" title="ocaml/stdlib/scanf.ml:39">file_name</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** A convenient alias to designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.00<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L409" title="ocaml/stdlib/stdlib.ml:409">open_in</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L39" title="ocaml/stdlib/scanf.ml:39">file_name</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** [Scanning.<a href="stdlib.ml.html#L409" title="ocaml/stdlib/stdlib.ml:409">open_in</a> fname] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; channel for bufferized reading in text mode from <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> [fname].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="stdlib.ml.html#L409" title="ocaml/stdlib/stdlib.ml:409">open_in</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel that efficiently reads<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; characters in large chunks; in contrast, [<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a>] below returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channels that must read <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> character at <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> time, leading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> much slower scanning rate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L412" title="ocaml/stdlib/stdlib.ml:412">open_in_bin</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L39" title="ocaml/stdlib/scanf.ml:39">file_name</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** [Scanning.<a href="stdlib.ml.html#L412" title="ocaml/stdlib/stdlib.ml:412">open_in_bin</a> fname] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel for bufferized reading in binary mode from <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> [fname].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.mli.html#L1175" title="ocaml/stdlib/stdlib.mli:1175">close_in</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Closes the {!Stdlib.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} associated with the given<br/></li>
<li></span><span class="Comment">&nbsp; {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel.<br/></li>
<li></span><span class="Comment">&nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L120" title="ocaml/stdlib/scanf.ml:120">from_file</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L39" title="ocaml/stdlib/scanf.ml:39">file_name</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** An alias for {!Scanning.<a href="stdlib.ml.html#L409" title="ocaml/stdlib/stdlib.ml:409">open_in</a>} above. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L121" title="ocaml/stdlib/scanf.ml:121">from_file_bin</a></span><span class="ocamlSig"> : </span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** An alias for {!Scanning.<a href="stdlib.ml.html#L412" title="ocaml/stdlib/stdlib.ml:412">open_in_bin</a>} above. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="lexing.mli.html#L97" title="ocaml/stdlib/lexing.mli:97">from_string</a></span><span class="ocamlSig"> : </span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** [Scanning.<a href="lexing.mli.html#L97" title="ocaml/stdlib/lexing.mli:97">from_string</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel which reads from the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Reading starts from the first character in the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The end-of-<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> condition is <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> when the end of the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is reached.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="lexing.mli.html#L103" title="ocaml/stdlib/lexing.mli:103">from_function</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** [Scanning.<a href="lexing.mli.html#L103" title="ocaml/stdlib/lexing.mli:103">from_function</a> f] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel with the given function as its reading method.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; When scanning needs <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> more character, the given function is called.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; When the function has no more character to provide, it {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> must} <a href="condition.mli.html#L163" title="ocaml/stdlib/condition.mli:163">signal</a> an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; end-of-<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> condition by raising the exception [End_of_file].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a></span><span class="ocamlSig"> : </span><span class="PreProc">Stdlib</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** [Scanning.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a> ic] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel which reads from the regular {!Stdlib.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; channel [ic] argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Reading starts at <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> reading <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> of [ic].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L105" title="ocaml/stdlib/scanf.ml:105">end_of_input</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [Scanning.<a href="scanf.ml.html#L105" title="ocaml/stdlib/scanf.ml:105">end_of_input</a> ic] tests the end-of-<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> condition of the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L110" title="ocaml/stdlib/scanf.ml:110">beginning_of_input</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [Scanning.<a href="scanf.ml.html#L110" title="ocaml/stdlib/scanf.ml:110">beginning_of_input</a> ic] tests the beginning of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> condition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of the given {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="scanf.ml.html#L114" title="ocaml/stdlib/scanf.ml:114">name_of_input</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** [Scanning.<a href="scanf.ml.html#L114" title="ocaml/stdlib/scanf.ml:114">name_of_input</a> ic] returns the <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> of the character source<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for the given {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.09<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">end<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Type of formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions} *)<br/></li>
<li></span><br/></li>
<li><a id="L217">&#x200c;</a><span class="Statement">type</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><span class="linkable">scanner</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; &nbsp;&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="PreProc">Scanning</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a><br/></li>
<li></span><span class="Comment">(** The type of formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> scanners: [('<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>, 'b, '<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>, 'd) <a href="scanf.ml.html#L396" title="ocaml/stdlib/scanf.ml:396">scanner</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is the type of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function that reads from <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel according to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>; more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; precisely, if [<a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a>] is <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function, then [<a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ic <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> f] applies [f] to all the arguments specified by <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>], when [<a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a>] has read those arguments from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel [ic].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For instance, the {!Scanf.<a href="#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a>} function below has type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [('<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>, 'b, '<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>, 'd) <a href="scanf.ml.html#L396" title="ocaml/stdlib/scanf.ml:396">scanner</a>], since it is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; reads from {!Scanning.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>}: [<a href="#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a> <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> f] applies [f] to the arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; specified by [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>], reading those arguments from {!Stdlib.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>} as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; expected.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>] has <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> [%<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] indications, the corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions must be provided {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a>} receiver function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [f]. For instance, if [read_elem] is an <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function for values of type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>], then [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a> ic &quot;%<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>;&quot; read_elem f] reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] of type [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; followed by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [';'] character, and returns [f <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.10<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L241">&#x200c;</a><span class="Statement">type</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><span class="linkable">scanner_opt</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; &nbsp;&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="PreProc">Scanning</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">d</span> <span class="Type">option</span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a><br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Scan_failure</span> <span class="Statement">of</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** When the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> can not be read according to the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; specification, formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions typically raise exception<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [Scan_failure].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 The general formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function} *)<br/></li>
<li></span><br/></li>
<li><a id="L252">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">bscanf</span></span> : <span class="PreProc">Scanning</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="scanf.ml.html#L396" title="ocaml/stdlib/scanf.ml:396">scanner</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">(** [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a> ic <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> <a href="list.ml.html#L66" title="ocaml/stdlib/list.ml:66">r1</a> ... rN f] reads characters from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>} formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel [ic] and converts them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; values according to <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; As <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> final step, receiver function [f] is applied to the values read and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; gives the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a>] call.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For instance, if [f] is the function [fun <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> -&gt; <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> + 1], then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [Scanf.<a href="#L487" title="ocaml/stdlib/scanf.mli:487">sscanf</a> &quot;<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 1&quot; &quot;%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> = %<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>&quot; f] returns [2].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Arguments [<a href="list.ml.html#L66" title="ocaml/stdlib/list.ml:66">r1</a>] to [rN] are user-defined <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions that read the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument corresponding to the [%<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] conversions specified in the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L268">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">bscanf_opt</span></span> : <span class="PreProc">Scanning</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="scanf.ml.html#L399" title="ocaml/stdlib/scanf.ml:399">scanner_opt</a><br/></li>
<li></span><span class="Comment">(** Same as {!Scanf.<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a>}, but returns [None] in case of scanning <a href="seq.ml.html#L438" title="ocaml/stdlib/seq.ml:438">failure</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.0 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Format <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> description} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> character <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> which <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> three types of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; objects:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - plain characters, which are simply matched with the characters of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> (with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> special case for space and line feed, see {!Scanf.space}),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - conversion specifications, each of which causes reading and conversion of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> argument for the function [f] (see {!Scanf.conversion}),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - scanning indications to specify boundaries of tokens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (see scanning {!Scanf.indication}).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2:space The space character in <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** As mentioned above, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> plain character in the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; matched with the next character of the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>; however, two characters are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; special exceptions to this rule: the space character ([' '] or ASCII code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; 32) and the line feed character (['\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>'] or ASCII code 10).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; A space does not match <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single space character, but any amount of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; 'whitespace' in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>. More precisely, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> space inside the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> matches {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> any number} of <a href="format.ml.html#L362" title="ocaml/stdlib/format.ml:362">tab</a>, space, line feed and carriage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> characters. Similarly, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> line feed character in the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; matches either <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single line feed or <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> carriage <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> followed by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; feed.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Matching {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> any} amount of whitespace, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> space in the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; also matches no amount of whitespace at all; hence, the call [<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a> ib<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &quot;Price = %d $&quot; (fun <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> -&gt; <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>)] succeeds and returns [1] when reading an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> with various whitespace in it, such as [Price = 1 $],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [Price&nbsp; =&nbsp; 1&nbsp; &nbsp; $], or even [Price=1$].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2:conversion Conversion specifications in <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Conversion specifications consist in the [%] character, followed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; an optional flag, an optional <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> <a href="scanf.ml.html#L834" title="ocaml/stdlib/scanf.ml:834">width</a>, and followed by <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; two conversion characters.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The conversion characters and their meanings are:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [d]: reads an optionally signed decimal integer ([0-9]+).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>]: reads an optionally signed integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (usual <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> conventions for decimal ([0-9]+), hexadecimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; ([0x[0-9a-f]+] and [0X[0-9A-F]+]), octal ([0o[0-7]+]), and binary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; ([0b[0-1]+]) notations are understood).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [u]: reads an unsigned decimal integer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or [X]: reads an unsigned hexadecimal integer ([[0-9a-fA-F]+]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [o]: reads an unsigned octal integer ([[0-7]+]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> argument that spreads as much as possible, until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; following bounding condition holds:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {ul<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {- <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> whitespace has been found (see {!Scanf.space}),}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {- <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> scanning indication (see scanning {!Scanf.indication}) has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; encountered,}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {- the end-of-<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> has been reached.}}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Hence, this conversion always succeeds: it returns an <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> if the bounding condition holds when the <a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a> begins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [S]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> delimited <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> argument (delimiters and special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="bytesLabels.mli.html#L211" title="ocaml/stdlib/bytesLabels.mli:211">escaped</a> characters follow the lexical conventions of OCaml).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single character. To test the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> character<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; without reading it, specify <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="filename.mli.html#L122" title="ocaml/stdlib/filename.mli:122">null</a> <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> <a href="scanf.ml.html#L834" title="ocaml/stdlib/scanf.ml:834">width</a>, <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; specification [%0c]. Raise [Invalid_argument], if the <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> <a href="scanf.ml.html#L834" title="ocaml/stdlib/scanf.ml:834">width</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; specification is greater than 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [C]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single delimited character (delimiters and special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="bytesLabels.mli.html#L211" title="ocaml/stdlib/bytesLabels.mli:211">escaped</a> characters follow the lexical conventions of OCaml).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [f], [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>], [E], [g], [G]: reads an optionally signed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; floating-point number in decimal notation, in the style [dddd.ddd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>/E+-dd].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [h], [H]: reads an optionally signed floating-point number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; in hexadecimal notation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [F]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating point number according to the lexical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; conventions of OCaml (hence the decimal point is mandatory if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; exponent part is not mentioned).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [B]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> boolean argument ([true] or [false]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [b]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> boolean argument (for backward compatibility; do not use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; in new programs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [ld], [li], [lu], [lx], [lX], [<a href="bytes.ml.html#L775" title="ocaml/stdlib/bytes.ml:775">lo</a>]: reads an [<a href="bigarray.mli.html#L179" title="ocaml/stdlib/bigarray.mli:179">int32</a>] argument to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> specified by the second letter for regular integers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [nd], [ni], [nu], [nx], [nX], [no]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="bigarray.mli.html#L185" title="ocaml/stdlib/bigarray.mli:185">nativeint</a>] argument to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> specified by the second letter for regular integers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [Ld], [Li], [Lu], [Lx], [LX], [Lo]: reads an [<a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a>] argument to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> specified by the second letter for regular integers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [[ range ]]: reads characters that matches <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the characters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; mentioned in the range of characters [range] (or not mentioned in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; it, if the range starts with [^]). Reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>] that can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>, if the next <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> character does not match the range. The <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; characters from [c1] to [c2] (inclusively) is denoted by [c1-c2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Hence, [%[0-9]] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> representing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> decimal number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; or an <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> if no decimal digit is found; similarly,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [%[0-9a-f]] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> of hexadecimal digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; If <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> bracket appears in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> range, it must occur as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; first character of the range (or just after the [^] in case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; range negation); hence [[\]]] matches <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [\]] character and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [[^\]]] matches any character that is not [\]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Use [%%] and [%@] to include <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [%] or <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [@] in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> range.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>]: user-defined reader. Takes the next [ri] formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; function and applies it to the scanning <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [ib] to read the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; next argument. The <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> function [ri] must therefore have type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a> -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] and the argument read has type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [{ <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> %}]: reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> argument. The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; read must have the same type as the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> specification<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>]. For instance, [&quot;%{ %<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> %}&quot;] reads any <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; can read <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value of type [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>]; hence, if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [&quot;<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>:\&quot;number is %u\&quot;&quot;], then [Scanf.<a href="#L487" title="ocaml/stdlib/scanf.mli:487">sscanf</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> &quot;<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>: %{%<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>%}&quot;]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; succeeds and returns the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [&quot;number is %u&quot;].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [( <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> %)]: scanning <a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a>-<a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> substitution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [rf] in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>, then goes on scanning with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [rf] instead of scanning with [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [rf] must have the same type as the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; specification [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>] that it replaces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; For instance, [&quot;%( %<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> %)&quot;] reads any <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> that can read <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; of type [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; The conversion returns the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> read [rf], and then <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; read using [rf].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Hence, if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [&quot;\&quot;%4d\&quot;1234.00&quot;], then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [Scanf.<a href="#L487" title="ocaml/stdlib/scanf.mli:487">sscanf</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> &quot;%(%<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>%)&quot; (fun <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> -&gt; <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>, <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>)] evaluates to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(&quot;%4d&quot;, 1234)].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; This behaviour is not mere <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> substitution, since the conversion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; returns the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> read as additional argument. If you need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; pure <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> substitution, use special flag [_] to discard the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; extraneous argument: conversion [%_( <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> %)] reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [rf] and then behaves the same as <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [rf].&nbsp; Hence, if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [&quot;\&quot;%4d\&quot;1234.00&quot;], then [Scanf.<a href="#L487" title="ocaml/stdlib/scanf.mli:487">sscanf</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> &quot;%_(%<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>%)&quot;] is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; simply equivalent to [Scanf.<a href="#L487" title="ocaml/stdlib/scanf.mli:487">sscanf</a> &quot;1234.00&quot; &quot;%4d&quot;].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]: returns the number of lines read so far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]: returns the number of characters read so far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [N] or [L]: returns the number of tokens read so far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [!]: matches the end of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [%]: matches <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> [%] character in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [@]: matches <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> [@] character in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - [,]: does nothing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Following the [%] character that introduces <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> conversion, there may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the special flag [_]: the conversion that follows occurs as usual,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; but the resulting value is discarded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For instance, if [f] is the function [fun <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> -&gt; <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> + 1], and [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [&quot;<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 1&quot;], then [Scanf.<a href="#L487" title="ocaml/stdlib/scanf.mli:487">sscanf</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> &quot;%_s = %<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>&quot; f] returns [2].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> <a href="scanf.ml.html#L834" title="ocaml/stdlib/scanf.ml:834">width</a> is composed of an optional integer literal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; indicating the maximal <a href="scanf.ml.html#L834" title="ocaml/stdlib/scanf.ml:834">width</a> of the <a href="scanf.ml.html#L80" title="ocaml/stdlib/scanf.ml:80">token</a> to read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For instance, [%6d] reads an integer, having at most 6 decimal digits;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [%4f] reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> with at most 4 characters; and [%8[\000-\255]]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; returns the next 8 characters (or all the characters still available,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; if fewer than 8 characters are available in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Notes:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - as mentioned above, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] conversion always succeeds, even if there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; nothing to read in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>: in this case, it simply returns [&quot;&quot;].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - in addition to the relevant digits, ['_'] characters may appear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; inside numbers (this is reminiscent to the usual OCaml lexical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; conventions). If stricter scanning is desired, use the range<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; conversion facility instead of the number conversions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - the [<a href="#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a>] facility is not intended for heavy duty lexical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; analysis and parsing. If it appears not expressive enough for your<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; needs, several alternative <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>: regular expressions (module<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Str}), stream parsers, [ocamllex]-generated lexers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [ocamlyacc]-generated parsers.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2:indication Scanning indications in <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Scanning indications appear just after the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> conversions [%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and [%[ range ]] to delimit the end of the <a href="scanf.ml.html#L80" title="ocaml/stdlib/scanf.ml:80">token</a>. A scanning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; indication is introduced by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [@] character, followed by <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; plain character [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>]. It means that the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="scanf.ml.html#L80" title="ocaml/stdlib/scanf.ml:80">token</a> should end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; just <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> the next matching [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] (which is skipped). If no [<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; character is encountered, the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="scanf.ml.html#L80" title="ocaml/stdlib/scanf.ml:80">token</a> spreads as much as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; possible. For instance, [&quot;%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>@\<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>&quot;] reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> up to the next<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="format.ml.html#L362" title="ocaml/stdlib/format.ml:362">tab</a> character or to the end of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>. If <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [@] character appears<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; anywhere else in the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>, it is treated as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> plain character.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Note:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - As usual in <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings, [%] and [@] characters must be <a href="bytesLabels.mli.html#L211" title="ocaml/stdlib/bytesLabels.mli:211">escaped</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; using [%%] and [%@]; this rule still holds within range specifications<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and scanning indications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For instance, <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> [&quot;%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>@%%&quot;] reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> up to the next [%]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; character, and <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> [&quot;%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>@%@&quot;] reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> up to the next [@].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - The scanning indications introduce slight differences in the syntax of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Scanf} <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings, compared to those used for the {!Printf}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; module. However, the scanning indications are similar to those used in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the {!Format} module; hence, when producing formatted text to be scanned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; by {!Scanf.<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a>}, it is wise to use printing functions from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Format} module (or, if you need to use functions from {!Printf}, banish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; or carefully double <a href="weak.ml.html#L58" title="ocaml/stdlib/weak.ml:58">check</a> the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings that contain ['@']<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; characters).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Exceptions during scanning} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Scanners may raise the following exceptions when the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> cannot be read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; according to the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - Raise {!Scanf.Scan_failure} if the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> does not match the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - Raise [Failure] if <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> conversion to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number is not possible.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - Raise [End_of_file] if the end of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> is encountered while <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; characters are needed to read the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> conversion specification.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - Raise [Invalid_argument] if the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is invalid.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Note:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> consequence, scanning <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] conversion never raises exception<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [End_of_file]: if the end of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> is reached the conversion succeeds and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; simply returns the characters read so far, or [&quot;&quot;] if <a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> were ever read.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Specialised formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions} *)<br/></li>
<li></span><br/></li>
<li><a id="L487">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sscanf</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="scanf.ml.html#L396" title="ocaml/stdlib/scanf.ml:396">scanner</a><br/></li>
<li></span><span class="Comment">(** Same as {!Scanf.<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a>}, but reads from the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L490">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sscanf_opt</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="scanf.ml.html#L399" title="ocaml/stdlib/scanf.ml:399">scanner_opt</a><br/></li>
<li></span><span class="Comment">(** Same as {!Scanf.<a href="#L487" title="ocaml/stdlib/scanf.mli:487">sscanf</a>}, but returns [None] in case of scanning <a href="seq.ml.html#L438" title="ocaml/stdlib/seq.ml:438">failure</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.0 *)<br/></li>
<li></span><br/></li>
<li><a id="L495">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">scanf</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="scanf.ml.html#L396" title="ocaml/stdlib/scanf.ml:396">scanner</a><br/></li>
<li></span><span class="Comment">(** Same as {!Scanf.<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a>}, but reads from the predefined formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; channel {!Scanf.Scanning.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>} that is connected to {!Stdlib.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L500">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">scanf_opt</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="scanf.ml.html#L399" title="ocaml/stdlib/scanf.ml:399">scanner_opt</a><br/></li>
<li></span><span class="Comment">(** Same as {!Scanf.<a href="#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a>}, but returns [None] in case of scanning <a href="seq.ml.html#L438" title="ocaml/stdlib/seq.ml:438">failure</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.0 *)<br/></li>
<li></span><br/></li>
<li><a id="L505">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">kscanf</span></span> :<br/></li>
<li>&nbsp; <span class="PreProc">Scanning</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="PreProc">Scanning</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="effect.ml.html#L18" title="ocaml/stdlib/effect.ml:18">exn</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="scanf.ml.html#L396" title="ocaml/stdlib/scanf.ml:396">scanner</a><br/></li>
<li></span><span class="Comment">(** Same as {!Scanf.<a href="#L252" title="ocaml/stdlib/scanf.mli:252">bscanf</a>}, but takes an additional function argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [ef] that is called in case of <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>: if the scanning process or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> conversion fails, the scanning function aborts and calls the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> handling function [ef] with the formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; exception that aborted the scanning process as arguments.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L515">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">ksscanf</span></span> :<br/></li>
<li>&nbsp; <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="PreProc">Scanning</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="effect.ml.html#L18" title="ocaml/stdlib/effect.ml:18">exn</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="scanf.ml.html#L396" title="ocaml/stdlib/scanf.ml:396">scanner</a><br/></li>
<li></span><span class="Comment">(** Same as {!Scanf.<a href="scanf.ml.html#L1476" title="ocaml/stdlib/scanf.ml:1476">kscanf</a>} but reads from the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Reading <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings from <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>} *)<br/></li>
<li></span><br/></li>
<li><a id="L523">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">bscanf_format</span></span> :<br/></li>
<li>&nbsp; <span class="PreProc">Scanning</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">((</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">g</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">g<br/></li>
<li></span><span class="Comment">(** [<a href="#L523" title="ocaml/stdlib/scanf.mli:523">bscanf_format</a> ic <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> f] reads <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="scanf.ml.html#L80" title="ocaml/stdlib/scanf.ml:80">token</a> from the formatted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel [ic], according to the given <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>], and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; applies [f] to the resulting <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Scan_failure if the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> value read does not have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; same type as [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.09<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L534">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sscanf_format</span></span> :<br/></li>
<li>&nbsp; <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">((</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">g</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">g<br/></li>
<li></span><span class="Comment">(** Same as {!Scanf.<a href="#L523" title="ocaml/stdlib/scanf.mli:523">bscanf_format</a>}, but reads from the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.09<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L541">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">format_from_string</span></span> :<br/></li>
<li>&nbsp; <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a><br/></li>
<li></span><span class="Comment">(** [<a href="scanf.ml.html#L1516" title="ocaml/stdlib/scanf.ml:1516">format_from_string</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>] converts <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> argument to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; according to the given <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Scan_failure if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], considered as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>, does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; have the same type as [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.10<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L551">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">unescaped</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L551" title="ocaml/stdlib/scanf.mli:551">unescaped</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] with escape sequences (according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the lexical conventions of OCaml) replaced by their corresponding special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; characters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; More precisely, [Scanf.<a href="#L551" title="ocaml/stdlib/scanf.mli:551">unescaped</a>] has the following property:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for all <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], [Scanf.<a href="#L551" title="ocaml/stdlib/scanf.mli:551">unescaped</a> (String.<a href="bytesLabels.mli.html#L211" title="ocaml/stdlib/bytesLabels.mli:211">escaped</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>) = <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Always <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the argument, even if there is no escape sequence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in the argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Scan_failure if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is not properly <a href="bytesLabels.mli.html#L211" title="ocaml/stdlib/bytesLabels.mli:211">escaped</a> (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] has invalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; escape sequences or special characters that are not properly <a href="bytesLabels.mli.html#L211" title="ocaml/stdlib/bytesLabels.mli:211">escaped</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For instance, [Scanf.<a href="#L551" title="ocaml/stdlib/scanf.mli:551">unescaped</a> &quot;\&quot;&quot;] will fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.00<br/></li>
<li></span><span class="Comment">*)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
