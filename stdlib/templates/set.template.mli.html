<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/templates/set.template.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/templates/set.template.mli - ocaml</h1>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="../digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="../digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* </span><span class="Todo">NOTE</span><span class="Comment">: If this <a href="../digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.mli, do not edit it directly! Instead,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; edit templates/<a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.template.mli and run tools/sync_stdlib_docs *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Sets over ordered types.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This module implements the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> structure, given <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> total ordering<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function over the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. All operations over sets<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are purely applicative (no side-effects).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The implementation uses balanced binary trees, and is therefore<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; reasonably efficient: insertion and membership <a href="../seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> time<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; logarithmic in the <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, for instance.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The {!Make} functor constructs implementations for any type, given <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] function.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; For instance:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; module IntPairs =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type <a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = <a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; let <a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> (x0,y0) (x1,y1) =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; match Stdlib.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> x0 x1 with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 0 -&gt; Stdlib.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> y0 y1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | <a href="../arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a> -&gt; <a href="../arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; end<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; module PairsSet = Set.Make(IntPairs)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; let m = PairsSet.(<a href="../bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> |&gt; <a href="../ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (2,3) |&gt; <a href="../ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (5,7) |&gt; <a href="../ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (11,13))<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This creates <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new module [PairsSet], with <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new type [PairsSet.<a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of sets of [<a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module type </span><span class="PreProc">OrderedType</span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** A total ordering function over the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-argument function [f] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f e1 e2] is <a href="../int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> if the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [e1] and [e2] are <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f e1 e2] is strictly negative if [e1] is smaller than [e2],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and [f e1 e2] is strictly positive if [e1] is greater than [e2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Example: <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable ordering function is the generic structural<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comparison function {!Stdlib.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>}. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="Comment">(** Input signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module type </span><span class="PreProc">S</span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="PreProc">sig<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:sets Sets} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** The type of sets. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** The <a href="../bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> containing all <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; plus [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. If [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] was already in [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned unchanged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (the <a href="../stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then physically <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @<a href="../arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L30" title="ocaml/stdlib/map.ml:30">singleton</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L30" title="ocaml/stdlib/map.ml:30">singleton</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the <a href="../int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>-element <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> containing only [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> containing all <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; except [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. If [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] was not in [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned unchanged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (the <a href="../stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then physically <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @<a href="../arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Set <a href="../map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L33" title="ocaml/stdlib/set.ml:33">inter</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Set intersection. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Test if two sets are <a href="../set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L35" title="ocaml/stdlib/set.ml:35">diff</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Set difference: [<a href="../set.ml.html#L35" title="ocaml/stdlib/set.ml:35">diff</a> <a href="../list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a> <a href="../list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] <a href="../bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; that are not in [<a href="../list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L36" title="ocaml/stdlib/map.ml:36">cardinal</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return the number of <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:<a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> Elements} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return the list of all <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the given <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; The returned list is sorted in increasing order with respect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; to the ordering [Ord.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>], where [Ord] is the argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; given to {!Set.Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L38" title="ocaml/stdlib/set.ml:38">min_elt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return the smallest element of the given <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (with respect to the [Ord.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] ordering), or raise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [Not_found] if the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="../bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L39" title="ocaml/stdlib/set.ml:39">min_elt_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return the smallest element of the given <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (with respect to the [Ord.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] ordering), or [None]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; if the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="../bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L40" title="ocaml/stdlib/set.ml:40">max_elt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="../set.ml.html#L38" title="ocaml/stdlib/set.ml:38">min_elt</a>}, but returns the largest element of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; given <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L41" title="ocaml/stdlib/set.ml:41">max_elt_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="../set.ml.html#L39" title="ocaml/stdlib/set.ml:39">min_elt_opt</a>}, but returns the largest element of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; given <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L42" title="ocaml/stdlib/map.ml:42">choose</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return <a href="../int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of the given <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, or raise [Not_found] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="../bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. Which element is chosen is unspecified,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; but <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> will be chosen for <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> sets. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L43" title="ocaml/stdlib/map.ml:43">choose_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return <a href="../int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of the given <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, or [None] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="../bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. Which element is chosen is unspecified,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; but <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> will be chosen for <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> sets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:searching Searching} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the element of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] (according<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; to [Ord.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>]), or raise [Not_found] if no such element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.01 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the element of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] (according<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; to [Ord.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>]), or [None] if no such element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], where [f] is <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically increasing function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; returns the lowest element [<a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] such that [f <a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no such element <a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; For example, [<a href="../map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a> (fun <a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> -&gt; Ord.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0) <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the first element [<a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] where [Ord.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (intuitively: [<a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> &gt;= <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]), or raise [Not_found] if [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; any element of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L47" title="ocaml/stdlib/map.ml:47">find_first_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L47" title="ocaml/stdlib/map.ml:47">find_first_opt</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], where [f] is <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically increasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; function, returns an option containing the lowest element [<a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; such that [f <a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>], or [None] if no such element <a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L48" title="ocaml/stdlib/map.ml:48">find_last</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L48" title="ocaml/stdlib/map.ml:48">find_last</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], where [f] is <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically decreasing function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; returns the highest element [<a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] such that [f <a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no such element <a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L49" title="ocaml/stdlib/map.ml:49">find_last_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L49" title="ocaml/stdlib/map.ml:49">find_last_opt</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], where [f] is <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically decreasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; function, returns an option containing the highest element [<a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; such that [f <a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>], or [None] if no such element <a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:traversing Traversing} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] applies [f] in turn to all <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; The <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] are presented to [f] in increasing order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; with respect to the ordering over the type of the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes [(f xN ... (f x2 (f x1 <a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>))...)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; where [x1 ... xN] are the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], in increasing order. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:transforming Transforming} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> whose <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are [f a0],[f <a href="../camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>]... [f<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; aN], where [a0],[<a href="../camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>]...[aN] are the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; The <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are passed to [f] in increasing order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; with respect to the ordering over the type of the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; If no element of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is changed by [f], [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; unchanged. (If each <a href="../out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> of [f] is physically <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>, the returned <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is physically <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.04 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of all <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; that satisfy predicate [f]. If [f] satisfies every element in [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned unchanged (the <a href="../stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; physically <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @<a href="../arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured.*)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of all [<a href="../lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [f <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Some <a href="../lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] for <a href="../option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> element [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; For example,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; {[<a href="../map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> (fun <a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> -&gt; if <a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> mod 2 = 0 then Some (<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> / 2) else None) <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; is the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of halves of the even <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; If no element of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is changed or dropped by [f] (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [f <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Some <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] for each element [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]), then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned unchanged: the <a href="../stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; is then physically <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of sets [(<a href="../list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>, <a href="../list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>)], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [<a href="../list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>] is the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of all the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that satisfy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; predicate [f], and [<a href="../list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] is the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of all the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that do not satisfy [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> triple [(<a href="../array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>, present, <a href="../float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>)], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [<a href="../array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; strictly less than [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [<a href="../float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] is the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; strictly greater than [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [present] is [false] if [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="../bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> no element <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; or [true] if [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="../bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> an element <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:predicates Predicates and comparisons} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../stack.ml.html#L53" title="ocaml/stdlib/stack.ml:53">is_empty</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Test whether <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="../bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> or not. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] tests whether [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] belongs to the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="../list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a> <a href="../list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] tests whether the sets [<a href="../list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>] and [<a href="../list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, that is, contain <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Total ordering between sets. Can be used as the ordering function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; for doing sets of sets. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> <a href="../list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a> <a href="../list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] tests whether the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> [<a href="../list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>] is <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> [<a href="../list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] checks if all <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; satisfy the predicate [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> ~f <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] checks if at least <a href="../int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> satisfies the predicate [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:converting Converting} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a> <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is {!<a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>}[ <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a> <a href="../array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] creates <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> from <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; This is usually more efficient than folding [<a href="../ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a>] over the list,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; except perhaps for lists with many duplicated <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L68" title="ocaml/stdlib/map.ml:68">to_seq_from</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="../map.ml.html#L68" title="ocaml/stdlib/map.ml:68">to_seq_from</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] iterates on <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; in ascending order, from [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Iterate on the whole <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, in ascending order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../map.ml.html#L67" title="ocaml/stdlib/map.ml:67">to_rev_seq</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Iterate on the whole <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, in descending order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../buffer.ml.html#L313" title="ocaml/stdlib/buffer.ml:313">add_seq</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Add the given <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> to the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, in order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../buffer.ml.html#L315" title="ocaml/stdlib/buffer.ml:315">of_seq</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Build <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> from the given <a href="../map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="Comment">(** Output signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> Make</span><span class="ocamlPreDef"> </span><span class="ocamlModParam">(</span><span class="PreProc">Ord</span><span class="ocamlPreMPRestr"> </span><span class="ocamlMPRestr">:</span><span class="ocamlPreMPRestr"> </span><span class="PreProc">OrderedType</span><span class="ocamlModParam">)</span><span class="ocamlPreDef"> : </span><span class="PreProc">S</span><span class="ocamlPreDef"> </span><span class="Statement">with</span> <span class="Statement">type</span> <span class="ocamlLCIdentifier"><a href="../set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span> <span class="Statement">=</span> <span class="PreProc">Ord</span>.<span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Functor building an implementation of the <a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> structure<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; given <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> totally ordered type. *)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
