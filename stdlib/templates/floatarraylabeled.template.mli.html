<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/templates/floatarraylabeled.template.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/templates/floatarraylabeled.template.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L52">append</a></li>
<li><a href="#L79">blit</a></li>
<li><a href="#L58">concat</a></li>
<li><a href="#L69">copy</a></li>
<li><a href="#L40">create</a></li>
<li><a href="#L160">exists</a></li>
<li><a href="#L237">fast_sort</a></li>
<li><a href="#L73">fill</a></li>
<li><a href="#L181">find_index</a></li>
<li><a href="#L189">find_map</a></li>
<li><a href="#L194">find_mapi</a></li>
<li><a href="#L175">find_opt</a></li>
<li><a href="#L130">fold_left</a></li>
<li><a href="#L135">fold_right</a></li>
<li><a href="#L155">for_all</a></li>
<li><a href="#L25">get</a></li>
<li><a href="#L45">init</a></li>
<li><a href="#L101">iter</a></li>
<li><a href="#L142">iter2</a></li>
<li><a href="#L106">iteri</a></li>
<li><a href="#L22">length</a></li>
<li><a href="#L36">make</a></li>
<li><a href="#L111">map</a></li>
<li><a href="#L147">map2</a></li>
<li><a href="#L261">map_from_array</a></li>
<li><a href="#L115">map_inplace</a></li>
<li><a href="#L256">map_to_array</a></li>
<li><a href="#L120">mapi</a></li>
<li><a href="#L125">mapi_inplace</a></li>
<li><a href="#L165">mem</a></li>
<li><a href="#L170">mem_ieee</a></li>
<li><a href="#L93">of_list</a></li>
<li><a href="#L252">of_seq</a></li>
<li><a href="#L30">set</a></li>
<li><a href="#L203">sort</a></li>
<li><a href="#L228">stable_sort</a></li>
<li><a href="#L61">sub</a></li>
<li><a href="#L90">to_list</a></li>
<li><a href="#L243">to_seq</a></li>
<li><a href="#L247">to_seqi</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L17">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Nicolas Ojeda Bar, LexiFi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2018 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="../digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="../digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><a id="L17">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">t</span></span> <span class="Statement">=</span> <span class="ocamlLCIdentifier">floatarray<br/></li>
<li></span><span class="Comment">(** The type of <a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> arrays with packed representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L22">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">length</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> (number of <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>) of the given floatarray. *)<br/></li>
<li></span><br/></li>
<li><a id="L25">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** [<a href="../bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns the element number [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] of floatarray [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is outside the range 0 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [(<a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L30">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] modifies floatarray [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in place, replacing element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; number [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] with [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is outside the range 0 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [(<a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L36">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">make</span></span> : <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>], initialized with [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="../sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L40">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">create</span></span> : <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; with uninitialized <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="../sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L45">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">init</span></span> : <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> ~f] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; with element number [<a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] initialized to the <a href="../stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of [f <a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; In other terms, [<a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> ~f] tabulates the results of [f]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; applied to the integers [0] to [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="../sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L52">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">append</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a> v1 v2] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray containing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; concatenation of the floatarrays [v1] and [v2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> v1 + <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> v2 &gt; Sys.<a href="../sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L58">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">concat</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="../seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a>}, but concatenates <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of floatarrays. *)<br/></li>
<li></span><br/></li>
<li><a id="L61">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sub</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span>:<span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> ~<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; containing the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> number [<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] to [<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of floatarray [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; designate <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]; that is, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> &lt; 0], or [<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &lt; 0], or [<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &gt; <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L69">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">copy</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], that is, <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; containing the same <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L73">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fill</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span>:<span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L121" title="ocaml/stdlib/bytesLabels.mli:121">fill</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> ~<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] modifies the floatarray [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in place,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; storing [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> number [<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] to [<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="../out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; designate <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L79">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">blit</span></span> : <span class="ocamlLCIdentifier">src</span>:<span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">src_pos</span>:<span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst</span>:<span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">dst_pos</span>:<span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span>:<span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="../buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> ~src ~src_pos ~dst ~dst_pos ~<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] copies [<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; from floatarray [src], starting at element number [src_pos],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to floatarray [dst], starting at element number [dst_pos].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; It works correctly even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [src] and [dst] are the same floatarray, and the source and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; destination chunks overlap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [src_pos] and [<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; designate <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [src], or if [dst_pos] and [<a href="../list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; designate <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [dst]. *)<br/></li>
<li></span><br/></li>
<li><a id="L90">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_list</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="../camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns the list of all the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L93">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">of_list</span></span> : <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a> <a href="../array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray containing the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of [<a href="../array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if the <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of [<a href="../array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [Sys.<a href="../sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>].*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Iterators} *)<br/></li>
<li></span><br/></li>
<li><a id="L101">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="../stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] in turn to all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].&nbsp; It is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0); f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1); ...; f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1); ()]. *)<br/></li>
<li></span><br/></li>
<li><a id="L106">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iteri</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="../stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>}, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; function is applied with the <a href="../bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the element as first argument,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and the element itself as second argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L111">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and builds <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]. *)<br/></li>
<li></span><br/></li>
<li><a id="L115">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map_inplace</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="../array.mli.html#L163" title="ocaml/stdlib/array.mli:163">map_inplace</a> f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and updates their values in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L120">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mapi</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="../bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; function is applied to the <a href="../bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the element as first argument,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and the element itself as second argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L125">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mapi_inplace</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="../array.mli.html#L163" title="ocaml/stdlib/array.mli:163">map_inplace</a>}, but the function is applied to the <a href="../bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element as first argument, and the element itself as second argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L130">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> ~f <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> ~<a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [f (... (f (f <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(0)) <a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(1)) ...) <a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray [<a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L135">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_right</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span>:'<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L191" title="ocaml/stdlib/bytesLabels.mli:191">fold_right</a> f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0) (f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1) ( ... (f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1) <a href="../bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>) ...))],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Iterators on two arrays} *)<br/></li>
<li></span><br/></li>
<li><a id="L142">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [Array.<a href="../seq.ml.html#L191" title="ocaml/stdlib/seq.ml:191">iter2</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] applies function [f] to all the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and [b].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if the floatarrays are not the same <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L147">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map2</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] applies function [f] to all the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and [b], and builds <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [[| f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0) b.(0); ...; f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1) b.(<a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> b - 1)|]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if the floatarrays are not the same <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Array scanning} *)<br/></li>
<li></span><br/></li>
<li><a id="L155">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">for_all</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> ~f [|<a href="../camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|]] checks if all <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the floatarray<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; satisfy the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [(f <a href="../camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) &amp;&amp; (f a2) &amp;&amp; ... &amp;&amp; (f an)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L160">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exists</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="../bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> f [|<a href="../camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|]] checks if at least <a href="../int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the floatarray satisfies the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [(f <a href="../camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) || (f a2) || ... || (f an)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L165">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mem</span></span> : <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span>:<span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="../ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] is true if and only if there is an element of [<a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; structurally <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], <a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. there is an [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [<a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; that [<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 0]. *)<br/></li>
<li></span><br/></li>
<li><a id="L170">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mem_ieee</span></span> : <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span>:<span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="../ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a>}, but uses IEEE equality instead of structural equality. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Array searching} *)<br/></li>
<li></span><br/></li>
<li><a id="L175">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_opt</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(* [<a href="../ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns the first element of the array [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] that satisfies<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the predicate [f]. Returns [None] if there is no value that satisfies [f]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in the array [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L181">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_index</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="../seq.ml.html#L153" title="ocaml/stdlib/seq.ml:153">find_index</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns [Some <a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>], where [<a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is the <a href="../bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element of the array [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] that satisfies [f <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], if there is such an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It returns [None] if there is no such element.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L189">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_map</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(* [<a href="../seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies [f] to the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in order, and returns<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the first <a href="../stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the form [Some <a href="../lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], or [None] if <a href="../option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> exist.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L194">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_mapi</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Same as [<a href="../seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a>], but the predicate is applied to the <a href="../bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Sorting} *)<br/></li>
<li></span><br/></li>
<li><a id="L203">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Sort <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray in increasing order according to <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; function.&nbsp; The comparison function must <a href="../seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> 0 if its arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> as <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> positive integer if the first is greater,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> negative integer if the first is smaller (see below for <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; complete specification).&nbsp; For example, {!Stdlib.<a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>} is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable comparison function.&nbsp; After calling [<a href="../array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>], the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; array is sorted in place in increasing order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="../array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>] is guaranteed to run in constant heap space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and (at most) logarithmic <a href="../effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The <a href="../arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Heap Sort.&nbsp; It runs in constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="../effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Specification of the comparison function:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Let [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] be the floatarray and [cmp] the comparison function. The following<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; must be true for all [<a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], [y], [z] in [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] :<br/></li>
<li></span><span class="Comment">-&nbsp; &nbsp; &nbsp; [cmp <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] &gt; 0 if and only if [cmp y <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] &lt; 0<br/></li>
<li></span><span class="Comment">-&nbsp; &nbsp; &nbsp; if [cmp <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] &gt;= 0 and [cmp y z] &gt;= 0 then [cmp <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> z] &gt;= 0<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; When [<a href="../array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>] returns, [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] <a href="../bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the same <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as <a href="../arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; reordered in such <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> way that for all <a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> and j valid indices of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] :<br/></li>
<li></span><span class="Comment">-&nbsp; &nbsp; &nbsp; [cmp <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>) <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(j)] &gt;= 0 if and only if <a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> &gt;= j<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L228">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stable_sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="../array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}, but the sorting algorithm is stable (<a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="../camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> that <a href="../int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="../int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> are kept in their original order) and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; not guaranteed to run in constant heap space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The <a href="../arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Merge Sort. It uses <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; floatarray of <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>/2], where [<a href="../buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; It is usually faster than the <a href="../arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation of {!<a href="../array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L237">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fast_sort</span></span> : <span class="ocamlLCIdentifier">cmp</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="../array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>} or {!<a href="../array.mli.html#L317" title="ocaml/stdlib/array.mli:317">stable_sort</a>}, whichever is faster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; on typical <a href="../in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Float arrays and Sequences} *)<br/></li>
<li></span><br/></li>
<li><a id="L243">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_seq</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Iterate on the floatarray, in increasing order. Modifications of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; floatarray during iteration will be reflected in the sequence. *)<br/></li>
<li></span><br/></li>
<li><a id="L247">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_seqi</span></span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Iterate on the floatarray, in increasing order, yielding indices along<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. Modifications of the floatarray during iteration will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; reflected in the sequence. *)<br/></li>
<li></span><br/></li>
<li><a id="L252">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">of_seq</span></span> : <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Create an array from the generator. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L256">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map_to_array</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span><span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array<br/></li>
<li></span><span class="Comment">(** [<a href="../float.mli.html#L740" title="ocaml/stdlib/float.mli:740">map_to_array</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and builds an array with the results returned by [f]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [[| f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0); f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1); ...; f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="../buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1) |]]. *)<br/></li>
<li></span><br/></li>
<li><a id="L261">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map_from_array</span></span> : <span class="ocamlLCIdentifier">f</span>:<span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="../float.mli.html#L745" title="ocaml/stdlib/float.mli:745">map_from_array</a> ~f <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and builds <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:floatarray_concurrency Arrays and concurrency safety}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Care must be taken when concurrently accessing <a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> arrays from multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; domains: accessing an array will never crash <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> program, but unsynchronized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; accesses might yield surprising (non-sequentially-consistent) results.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:floatarray_atomicity Atomicity}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Every <a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array operation that accesses more than <a href="../int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> array element is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; not atomic. This includes iteration, scanning, sorting, splitting and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; combining arrays.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For example, consider the following program:<br/></li>
<li></span><span class="Comment">{[let <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> = 100_000_000<br/></li>
<li></span><span class="Comment">let <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> = Float.ArrayLabels.<a href="../bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 1.<br/></li>
<li></span><span class="Comment">let <a href="../map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> f () =<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Float.ArrayLabels.<a href="../bytesLabels.mli.html#L170" title="ocaml/stdlib/bytesLabels.mli:170">iteri</a> ~f:(fun <a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; Float.Array.<a href="../bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> (f <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)) <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">let d1 = Domain.<a href="../domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (<a href="../map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> (fun <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> +. 1.))<br/></li>
<li></span><span class="Comment">let d2 = Domain.<a href="../domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (<a href="../map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> (fun <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt;&nbsp; 2. *. <a href="../camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> +. 1.))<br/></li>
<li></span><span class="Comment">let () = Domain.<a href="../domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="../domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; After executing this code, each <a href="../printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> of the <a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array [<a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [2.], [3.], [4.] or [5.]. If atomicity is required, then the user must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; implement their own synchronization (for example, using {!Mutex.<a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>}).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:floatarray_data_race Data races}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If two domains only access <a href="../set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a> parts of the array, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; observed behaviour is the equivalent to <a href="../option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sequential interleaving of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the operations from the two domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; A <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> race is said to occur when two domains access the same array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element without synchronization and at least <a href="../int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the accesses is <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; write. In the absence of <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the observed behaviour is equivalent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to <a href="../option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sequential interleaving of the operations from different domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Whenever possible, <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races should be avoided by using synchronization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to mediate the accesses to the array <a href="../set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Indeed, in the presence of <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, programs will not crash but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; observed behaviour may not be equivalent to any sequential interleaving of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; operations from different domains. Nevertheless, even in the presence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> read operation will <a href="../seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the value of <a href="../option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> prior write to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; that <a href="../printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> with <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> few exceptions.<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2:floatarray_datarace_tearing Tearing }<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Float arrays have two supplementary caveats in the presence of <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; First, the <a href="../buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> operation might <a href="../oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> an array byte-by-byte. Data races<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; between such <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> operation and another operation might produce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; surprising values due to tearing: partial writes interleaved with other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; operations can <a href="../buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> values that would not exist with <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; execution.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For instance, at the end of<br/></li>
<li></span><span class="Comment">{[let zeros = Float.Array.<a href="../bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 0.<br/></li>
<li></span><span class="Comment">let max_floats = Float.Array.<a href="../bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> Float.<a href="../stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a><br/></li>
<li></span><span class="Comment">let <a href="../camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> = Float.Array.<a href="../oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> zeros<br/></li>
<li></span><span class="Comment">let d1 = Domain.<a href="../domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Float.Array.<a href="../buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> zeros 0 <a href="../camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> 0 <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>)<br/></li>
<li></span><span class="Comment">let d2 = Domain.<a href="../domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Float.Array.<a href="../buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> max_floats 0 <a href="../camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> 0 <a href="../nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>)<br/></li>
<li></span><span class="Comment">let () = Domain.<a href="../domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="../domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; the [<a href="../camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a>] <a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array might contain values that are neither [0.]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; nor [<a href="../stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Second, on 32-bit architectures, getting or setting <a href="../camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="../printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> involves two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; separate memory accesses. In the presence of <a href="../weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the user may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; observe tearing on any operation.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**/**)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Undocumented functions} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* These functions are for system use only. Do not call directly. *)<br/></li>
<li></span><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_get</span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%floatarray_unsafe_get&quot;<br/></li>
<li></span><span class="Statement">external</span> <span class="ocamlLCIdentifier">unsafe_set</span> : <span class="ocamlLCIdentifier"><a href="../sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="../random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%floatarray_unsafe_set&quot;<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
