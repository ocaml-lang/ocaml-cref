<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/map.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/map.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L79">add</a></li>
<li><a href="#L356">add_seq</a></li>
<li><a href="#L88">add_to_list</a></li>
<li><a href="#L148">bindings</a></li>
<li><a href="#L142">cardinal</a></li>
<li><a href="#L177">choose</a></li>
<li><a href="#L183">choose_opt</a></li>
<li><a href="#L54">compare</a></li>
<li><a href="#L317">compare</a></li>
<li><a href="#L76">empty</a></li>
<li><a href="#L311">equal</a></li>
<li><a href="#L326">exists</a></li>
<li><a href="#L258">filter</a></li>
<li><a href="#L266">filter_map</a></li>
<li><a href="#L191">find</a></li>
<li><a href="#L200">find_first</a></li>
<li><a href="#L212">find_first_opt</a></li>
<li><a href="#L218">find_last</a></li>
<li><a href="#L224">find_last_opt</a></li>
<li><a href="#L195">find_opt</a></li>
<li><a href="#L239">fold</a></li>
<li><a href="#L321">for_all</a></li>
<li><a href="#L304">is_empty</a></li>
<li><a href="#L233">iter</a></li>
<li><a href="#L247">map</a></li>
<li><a href="#L254">mapi</a></li>
<li><a href="#L167">max_binding</a></li>
<li><a href="#L172">max_binding_opt</a></li>
<li><a href="#L307">mem</a></li>
<li><a href="#L118">merge</a></li>
<li><a href="#L155">min_binding</a></li>
<li><a href="#L161">min_binding_opt</a></li>
<li><a href="#L337">of_list</a></li>
<li><a href="#L360">of_seq</a></li>
<li><a href="#L285">partition</a></li>
<li><a href="#L111">remove</a></li>
<li><a href="#L106">singleton</a></li>
<li><a href="#L292">split</a></li>
<li><a href="#L333">to_list</a></li>
<li><a href="#L347">to_rev_seq</a></li>
<li><a href="#L343">to_seq</a></li>
<li><a href="#L351">to_seq_from</a></li>
<li><a href="#L129">union</a></li>
<li><a href="#L94">update</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L70">key</a></li>
<li><a href="#L51">t</a></li>
<li><a href="#L73">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* </span><span class="Todo">NOTE</span><span class="Comment">: If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.mli, do not edit it directly! Instead,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; edit templates/<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.template.mli and run tools/sync_stdlib_docs *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Association <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> over ordered types.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This module implements applicative association <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>, also known as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; finite maps or dictionaries, given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> total ordering function<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; over the keys.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; All operations over maps are purely applicative (no side-effects).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The implementation uses balanced binary trees, and therefore searching<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and insertion <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> time logarithmic in the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; For instance:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; module IntPairs =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; let <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> (x0,y0) (x1,y1) =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; match Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> x0 x1 with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 0 -&gt; Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> y0 y1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a> -&gt; <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; end<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; module PairsMap = Map.Make(IntPairs)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; let m = PairsMap.(<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> |&gt; <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (0,1) &quot;hello&quot; |&gt; <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (1,0) &quot;world&quot;)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This creates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new module [PairsMap], with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> PairsMap.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of maps from [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] to ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. In this example, [m] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; values so its type is [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> PairsMap.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module type </span><span class="PreProc">OrderedType</span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="PreProc">sig<br/></li>
<li><a id="L51">&#x200c;</a></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">t</span><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> keys. *)<br/></li>
<li></span><br/></li>
<li><a id="L54">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">compare</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** A total ordering function over the keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-argument function [f] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f e1 e2] is <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> if the keys [e1] and [e2] are <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f e1 e2] is strictly negative if [e1] is smaller than [e2],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and [f e1 e2] is strictly positive if [e1] is greater than [e2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Example: <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable ordering function is the generic structural<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comparison function {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>}. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="Comment">(** Input signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module type </span><span class="PreProc">S</span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="PreProc">sig<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:maps Maps} *)<br/></li>
<li></span><br/></li>
<li><a id="L70">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">key</span><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> keys. *)<br/></li>
<li></span><br/></li>
<li><a id="L73">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="Statement">!</span><span class="ocamlSig">+'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">t</span><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** The type of maps from type [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] to type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L76">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">empty</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** The <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L79">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">add</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> containing the same <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m], plus <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] to [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>]. If [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] was already bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; in [m] to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value that is physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m] is returned unchanged (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; then physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [m]). Otherwise, the previous binding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] in [m] disappears.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><a id="L88">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">add_to_list</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L28" title="ocaml/stdlib/map.ml:28">add_to_list</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> m] is [m] with [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] mapped to [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; that [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> :: Map.<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> m] if [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] was bound in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m] and [[<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]] otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L94">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">update</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> f m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> containing the same <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m], except for the binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>]. Depending on the value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [y] where [y] is [f (<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> m)], the binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; added, removed or updated. If [y] is [None], the binding is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; removed if it <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>; otherwise, if [y] is [Some z] then [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; is associated to [z] in the resulting <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.&nbsp; If [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] was already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; bound in [m] to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value that is physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [z], [m]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; is returned unchanged (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [m]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.06 *)<br/></li>
<li></span><br/></li>
<li><a id="L106">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">singleton</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L30" title="ocaml/stdlib/map.ml:30">singleton</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns the <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>-element <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> that <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [y] for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L111">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">remove</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> containing the same <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m], except for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] which is unbound in the returned <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] was not in [m], [m] is returned unchanged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [m]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><a id="L118">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">merge</span></span><span class="ocamlSig">:<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a> f m1 m2] computes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> whose keys are <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of the keys of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m1] and of [m2]. The presence of each such binding, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; corresponding value, is determined with the function [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; In terms of the [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a>] operation, we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> (<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a> f m1 m2) = f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> (<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m1) (<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m2)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; for any <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], provided that [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> None None = None].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L129">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">union</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a> f m1 m2] computes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> whose keys are <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of the keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; of [m1] and of [m2].&nbsp; When the same binding is defined in both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; arguments, the function [f] is used to <a href="array.mli.html#L284" title="ocaml/stdlib/array.mli:284">combine</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; This is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> special case of [<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a>]: [<a href="map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a> f m1 m2] is equivalent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; to [<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a> f' m1 m2], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - [f' _key None None = None]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - [f' _key (Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>) None = Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - [f' _key None (Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>) = Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - [f' <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> (Some v1) (Some v2) = f <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> v1 v2]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><a id="L142">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">cardinal</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return the number of <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:<a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> Bindings} *)<br/></li>
<li></span><br/></li>
<li><a id="L148">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">bindings</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return the list of all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; The returned list is sorted in increasing order of keys with respect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; to the ordering [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>], where [Ord] is the argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; given to {!Map.Make}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L155">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">min_binding</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return the binding with the smallest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (with respect to the [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] ordering), or raise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [Not_found] if the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L161">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">min_binding_opt</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return the binding with the smallest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> in the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (with respect to the [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] ordering), or [None]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; if the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L167">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">max_binding</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="map.ml.html#L38" title="ocaml/stdlib/map.ml:38">min_binding</a>}, but returns the binding with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the largest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> in the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L172">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">max_binding_opt</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="map.ml.html#L39" title="ocaml/stdlib/map.ml:39">min_binding_opt</a>}, but returns the binding with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the largest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> in the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L177">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">choose</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> binding of the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, or raise [Not_found] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. Which binding is chosen is unspecified,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; but <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> will be chosen for <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> maps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L183">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">choose_opt</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Return <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> binding of the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, or [None] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. Which binding is chosen is unspecified,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; but <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> will be chosen for <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> maps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:searching Searching} *)<br/></li>
<li></span><br/></li>
<li><a id="L191">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> value of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [m],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no binding for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L195">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_opt</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] if the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> value of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; in [m] is [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], or [None] if no binding for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L200">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_first</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a> f m], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically increasing function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; returns the binding of [m] with the lowest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] such that [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no such <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; For example, [<a href="map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a> (fun <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> -&gt; Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0) m] will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the first binding [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>, <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] of [m] where [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (intuitively: [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> &gt;= <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]), or raise [Not_found] if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; any element of [m].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L212">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_first_opt</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L47" title="ocaml/stdlib/map.ml:47">find_first_opt</a> f m], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically increasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; function, returns an option containing the binding of [m] with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; lowest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] such that [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>], or [None] if no such <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L218">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_last</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L48" title="ocaml/stdlib/map.ml:48">find_last</a> f m], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically decreasing function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; returns the binding of [m] with the highest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] such that [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no such <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><a id="L224">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_last_opt</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L49" title="ocaml/stdlib/map.ml:49">find_last_opt</a> f m], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically decreasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; function, returns an option containing the binding of [m] with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the highest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] such that [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>], or [None] if no such <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:traversing Traversing} *)<br/></li>
<li></span><br/></li>
<li><a id="L233">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">iter</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> f m] applies [f] to all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> [m].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [f] receives the <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> as first argument, and the associated value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; as second argument.&nbsp; The <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are passed to [f] in increasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; order with respect to the ordering over the type of the keys. *)<br/></li>
<li></span><br/></li>
<li><a id="L239">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fold</span></span><span class="ocamlSig">:<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a> f m <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes [(f kN dN ... (f k1 d1 <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>)...)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; where [k1 ... kN] are the keys of all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in [m]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (in increasing order), and [d1 ... dN] are the associated <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:transforming Transforming} *)<br/></li>
<li></span><br/></li>
<li><a id="L247">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with same domain as [m], where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; associated value [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] of all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; replaced by the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the application of [f] to [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; The <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are passed to [f] in increasing order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; with respect to the ordering over the type of the keys. *)<br/></li>
<li></span><br/></li>
<li><a id="L254">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mapi</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}, but the function receives as arguments both the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> and the associated value for each binding of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L258">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">filter</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> f m] returns the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in [m]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; that satisfy predicate [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>]. If every binding in [m] satisfies [f],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m] is returned unchanged (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [m])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><a id="L266">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">filter_map</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> f m] applies the function [f] to every binding of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m], and builds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> from the results. For each binding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [(<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>, <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>)] in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - if [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] is [None] then [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] is not in the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - if [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] is [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>'] then the binding [(<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>, <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>')]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is in the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; For example, the following function on maps whose values are lists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fun _k li -&gt; match li with [] -&gt; None | _::<a href="list.mli.html#L76" title="ocaml/stdlib/list.mli:76">tl</a> -&gt; Some <a href="list.mli.html#L76" title="ocaml/stdlib/list.mli:76">tl</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; ]}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; drops all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] whose value is an <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> list, and pops<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the first element of each value that is non-<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><a id="L285">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">partition</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> f m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of maps [(m1, m2)], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m1] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] that satisfy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; predicate [f], and [m2] is the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [m] that do not satisfy [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L292">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">split</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> triple [(<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>, <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>, <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>)], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] whose <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; is strictly less than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] is the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] whose <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; is strictly greater than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>] is [None] if [m] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> no binding for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] if [m] binds [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] to [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:predicates Predicates and comparisons} *)<br/></li>
<li></span><br/></li>
<li><a id="L304">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">is_empty</span></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Test whether <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> or not. *)<br/></li>
<li></span><br/></li>
<li><a id="L307">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mem</span></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns [true] if [m] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; and [false] otherwise. *)<br/></li>
<li></span><br/></li>
<li><a id="L311">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">equal</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> cmp m1 m2] tests whether the maps [m1] and [m2] are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, that is, contain <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> keys and associate them with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.&nbsp; [cmp] is the equality predicate used to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> associated with the keys. *)<br/></li>
<li></span><br/></li>
<li><a id="L317">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">compare</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Total ordering between maps.&nbsp; The first argument is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> total ordering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; used to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> associated with <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> keys in the two maps. *)<br/></li>
<li></span><br/></li>
<li><a id="L321">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">for_all</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> f m] checks if all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; satisfy the predicate [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L326">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">exists</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> f m] checks if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> binding of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; satisfies the predicate [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** {1:converting Converting} *)<br/></li>
<li></span><br/></li>
<li><a id="L333">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_list</span></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a> m] is {!<a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a>}[ m].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L337">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">of_list</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a> bs] adds the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [bs] to the <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; in list order (if <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> is bound twice in [bs] the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; takes over).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L343">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_seq</span></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Iterate on the whole <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, in ascending order of keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><a id="L347">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_rev_seq</span></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Iterate on the whole <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, in descending order of keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.12 *)<br/></li>
<li></span><br/></li>
<li><a id="L351">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_seq_from</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L68" title="ocaml/stdlib/map.ml:68">to_seq_from</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> m] iterates on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; in ascending order of keys, from <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] or above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><a id="L356">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">add_seq</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Add the given <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> to the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, in order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><a id="L360">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">of_seq</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Build <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> from the given <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="Comment">(** Output signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> Make</span><span class="ocamlPreDef"> </span><span class="ocamlModParam">(</span><span class="PreProc">Ord</span><span class="ocamlPreMPRestr"> </span><span class="ocamlMPRestr">:</span><span class="ocamlPreMPRestr"> </span><span class="PreProc">OrderedType</span><span class="ocamlModParam">)</span><span class="ocamlPreDef"> : </span><span class="PreProc">S</span><span class="ocamlPreDef"> </span><span class="Statement">with</span> <span class="Statement">type</span> <span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span> <span class="Statement">=</span> <span class="PreProc">Ord</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Functor building an implementation of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> structure<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> totally ordered type. *)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
