<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/stdlib.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/stdlib.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L1175">close_in</a></li>
<li><a href="#L1181">close_in_noerr</a></li>
<li><a href="#L1051">close_out</a></li>
<li><a href="#L1059">close_out_noerr</a></li>
<li><a href="#L41">failwith</a></li>
<li><a href="#L978">flush</a></li>
<li><a href="#L984">flush_all</a></li>
<li><a href="#L1167">in_channel_length</a></li>
<li><a href="#L1103">input</a></li>
<li><a href="#L1140">input_binary_int</a></li>
<li><a href="#L1135">input_byte</a></li>
<li><a href="#L1092">input_char</a></li>
<li><a href="#L1096">input_line</a></li>
<li><a href="#L1146">input_value</a></li>
<li><a href="#L38">invalid_arg</a></li>
<li><a href="#L186">max</a></li>
<li><a href="#L181">min</a></li>
<li><a href="#L1075">open_in</a></li>
<li><a href="#L1079">open_in_bin</a></li>
<li><a href="#L1085">open_in_gen</a></li>
<li><a href="#L958">open_out</a></li>
<li><a href="#L964">open_out_bin</a></li>
<li><a href="#L970">open_out_gen</a></li>
<li><a href="#L1046">out_channel_length</a></li>
<li><a href="#L997">output</a></li>
<li><a href="#L1013">output_binary_int</a></li>
<li><a href="#L1008">output_byte</a></li>
<li><a href="#L993">output_bytes</a></li>
<li><a href="#L987">output_char</a></li>
<li><a href="#L990">output_string</a></li>
<li><a href="#L1003">output_substring</a></li>
<li><a href="#L1021">output_value</a></li>
<li><a href="#L1158">pos_in</a></li>
<li><a href="#L1035">pos_out</a></li>
<li><a href="#L882">prerr_bytes</a></li>
<li><a href="#L876">prerr_char</a></li>
<li><a href="#L895">prerr_endline</a></li>
<li><a href="#L889">prerr_float</a></li>
<li><a href="#L886">prerr_int</a></li>
<li><a href="#L899">prerr_newline</a></li>
<li><a href="#L879">prerr_string</a></li>
<li><a href="#L851">print_bytes</a></li>
<li><a href="#L845">print_char</a></li>
<li><a href="#L864">print_endline</a></li>
<li><a href="#L858">print_float</a></li>
<li><a href="#L855">print_int</a></li>
<li><a href="#L868">print_newline</a></li>
<li><a href="#L848">print_string</a></li>
<li><a href="#L938">read_float</a></li>
<li><a href="#L929">read_float_opt</a></li>
<li><a href="#L925">read_int</a></li>
<li><a href="#L917">read_int_opt</a></li>
<li><a href="#L906">read_line</a></li>
<li><a href="#L1120">really_input</a></li>
<li><a href="#L1128">really_input_string</a></li>
<li><a href="#L1153">seek_in</a></li>
<li><a href="#L1029">seek_out</a></li>
<li><a href="#L1184">set_binary_mode_in</a></li>
<li><a href="#L1062">set_binary_mode_out</a></li>
<li><a href="#L839">stderr</a></li>
<li><a href="#L833">stdin</a></li>
<li><a href="#L836">stdout</a></li>
<li><a href="#L1324">string_of_format</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L1322">format</a></li>
<li><a href="#L1320">format4</a></li>
<li><a href="#L1317">format6</a></li>
<li><a href="#L670">fpclass</a></li>
<li><a href="#L827">in_channel</a></li>
<li><a href="#L945">open_flag</a></li>
<li><a href="#L830">out_channel</a></li>
<li><a href="#L1215">ref</a></li>
<li><a href="#L1245">result</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L690">^</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The OCaml Standard library.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This module is automatically opened at the beginning of each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; compilation. All components of this module can therefore be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; referred by their short <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a>, without prefixing them by [Stdlib].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; In particular, it provides the basic operations over the built-in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; types (numbers, booleans, byte sequences, strings, exceptions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; references, lists, arrays, <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>-<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channels, ...) and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {{!modules}standard library modules}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Exceptions} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">raise</span> : <span class="Type"><a href="effect.ml.html#L18" title="ocaml/stdlib/effect.ml:18">exn</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%raise&quot;<br/></li>
<li></span><span class="Comment">(** Raise the given exception value *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">raise_notrace</span> : <span class="Type"><a href="effect.ml.html#L18" title="ocaml/stdlib/effect.ml:18">exn</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%raise_notrace&quot;<br/></li>
<li></span><span class="Comment">(** A faster version [raise] which does not record the backtrace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L38">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">invalid_arg</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Raise exception [Invalid_argument] with the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L41">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">failwith</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Raise exception [Failure] with the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Exit<br/></li>
<li></span><span class="Comment">(** The [Exit] exception is not raised by any library function.&nbsp; It is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; provided for use in your programs. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Match_failure</span> <span class="Statement">of</span> <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@<span class="ocamlLCIdentifier">ocaml</span>.<span class="ocamlLCIdentifier">warn_on_literal_pattern</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exception raised when <a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> of the cases of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pattern-matching<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; apply. The arguments are the <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> of the match keyword in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; source code (<a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a>, line number, column number). *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Assert_failure</span> <span class="Statement">of</span> <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@<span class="ocamlLCIdentifier">ocaml</span>.<span class="ocamlLCIdentifier">warn_on_literal_pattern</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exception raised when an assertion fails. The arguments are the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> of the assert keyword in the source code (<a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a>, line<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; number, column number). *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Invalid_argument</span> <span class="Statement">of</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@<span class="ocamlLCIdentifier">ocaml</span>.<span class="ocamlLCIdentifier">warn_on_literal_pattern</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exception raised by library functions to <a href="condition.mli.html#L163" title="ocaml/stdlib/condition.mli:163">signal</a> that the given<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; arguments do not <a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> sense. The <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> gives <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> information to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the programmer. As <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> general rule, this exception should not be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; caught, it denotes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> programming <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> and the code should be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; modified not to trigger it. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Failure</span> <span class="Statement">of</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@<span class="ocamlLCIdentifier">ocaml</span>.<span class="ocamlLCIdentifier">warn_on_literal_pattern</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exception raised by library functions to <a href="condition.mli.html#L163" title="ocaml/stdlib/condition.mli:163">signal</a> that they are<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; undefined on the given arguments. The <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is meant to give <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; information to the programmer; you must not pattern match on the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> literal because it may change in future versions (use<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Failure _ instead). *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Not_found<br/></li>
<li></span><span class="Comment">(** Exception raised by search functions when the desired object could<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; not be found. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Out_of_memory<br/></li>
<li></span><span class="Comment">(** Exception raised by the garbage collector when there is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; insufficient memory to complete the computation. (Not reliable for<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; allocations on the minor heap.) *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Stack_overflow<br/></li>
<li></span><span class="Comment">(** Exception raised by the bytecode interpreter when the evaluation<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> reaches its maximal <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. This often indicates infinite or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; excessively deep recursion in the user'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> program.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Before 4.10, it was not fully implemented by the native-code<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; compiler. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Sys_error</span> <span class="Statement">of</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@<span class="ocamlLCIdentifier">ocaml</span>.<span class="ocamlLCIdentifier">warn_on_literal_pattern</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exception raised by the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>/<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions to report an<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; operating system <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>. The <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is meant to give <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; information to the programmer; you must not pattern match on the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> literal because it may change in future versions (use<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Sys_error _ instead). *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">End_of_file<br/></li>
<li></span><span class="Comment">(** Exception raised by <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions to <a href="condition.mli.html#L163" title="ocaml/stdlib/condition.mli:163">signal</a> that the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; has been reached. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Division_by_zero<br/></li>
<li></span><span class="Comment">(** Exception raised by integer division and remainder operations when<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; their second argument is <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Sys_blocked_io<br/></li>
<li></span><span class="Comment">(** A special case of Sys_error raised when no I/O is possible on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; non-blocking I/O channel. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Undefined_recursive_module</span> <span class="Statement">of</span> <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@<span class="ocamlLCIdentifier">ocaml</span>.<span class="ocamlLCIdentifier">warn_on_literal_pattern</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exception raised when an ill-founded recursive module definition<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is evaluated. The arguments are the <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> of the definition in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the source code (<a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a>, line number, column number). *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Comparisons} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">=</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>&quot;<br/></li>
<li></span><span class="Comment">(** [e1 = e2] tests for structural equality of [e1] and [e2].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Mutable structures (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. references and arrays) are <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if and only if their <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a> are structurally <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; even if the two mutable objects are not the same physical object.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Equality between functional values raises [Invalid_argument].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Equality between cyclic <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> structures may not terminate.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Left-associative operator, see {!Ocaml_operators} for more information. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">&lt;&gt;</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%notequal&quot;<br/></li>
<li></span><span class="Comment">(** Negation of {!Stdlib.( = )}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">&lt;</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%lessthan&quot;<br/></li>
<li></span><span class="Comment">(** See {!Stdlib.( &gt;= )}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">&gt;</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%greaterthan&quot;<br/></li>
<li></span><span class="Comment">(** See {!Stdlib.( &gt;= )}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator,&nbsp; see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">&lt;=</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%lessequal&quot;<br/></li>
<li></span><span class="Comment">(** See {!Stdlib.( &gt;= )}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator,&nbsp; see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">&gt;=</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%greaterequal&quot;<br/></li>
<li></span><span class="Comment">(** Structural ordering functions. These functions coincide with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the usual orderings over integers, characters, strings, byte sequences<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and floating-point numbers, and <a href="bytesLabels.mli.html#L111" title="ocaml/stdlib/bytesLabels.mli:111">extend</a> them to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; total ordering over all types.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The ordering is compatible with [( = )]. As in the case<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of [( = )], mutable structures are compared by <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Comparison between functional values raises [Invalid_argument].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Comparison between cyclic structures may not terminate.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns [0] if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [y],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> negative integer if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is less than [y], and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> positive integer<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is greater than [y].&nbsp; The ordering implemented by [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is compatible with the comparison predicates [=], [&lt;] and [&gt;]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; defined above,&nbsp; with <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> difference on the treatment of the <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> value<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Stdlib.<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>}.&nbsp; Namely, the comparison predicates treat [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as different from any other <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> value, including itself;<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; while [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] treats [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to itself and less than any<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; other <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> value.&nbsp; This treatment of [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] ensures that [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; defines <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> total ordering relation.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] applied to functional values may raise [Invalid_argument].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] applied to cyclic structures may not terminate.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] function can be used as the comparison function<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; required by the {!Set.Make} and {!Map.Make} functors, as well as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the {!List.<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>} and {!Array.<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>} functions. *)<br/></li>
<li></span><br/></li>
<li><a id="L181">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">min</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Return the smaller of the two arguments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is unspecified if <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the arguments <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> value [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L186">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">max</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Return the greater of the two arguments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is unspecified if <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the arguments <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> value [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">==</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%<a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a>&quot;<br/></li>
<li></span><span class="Comment">(** [e1 == e2] tests for physical equality of [e1] and [e2].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; On mutable types such as references, arrays, byte sequences, records with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mutable <a href="printexc.ml.html#L39" title="ocaml/stdlib/printexc.ml:39">fields</a> and objects with mutable instance variables,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [e1 == e2] is true if and only if physical modification of [e1]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; also affects [e2].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; On non-mutable types, the behavior of [( == )] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; implementation-dependent; however, it is guaranteed that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [e1 == e2] implies [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> e1 e2 = 0].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Left-associative operator,&nbsp; see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">!=</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%noteq&quot;<br/></li>
<li></span><span class="Comment">(** Negation of {!Stdlib.( == )}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator,&nbsp; see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Boolean operations} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">not</span> : <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%boolnot&quot;<br/></li>
<li></span><span class="Comment">(** The boolean negation. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%sequand&quot;<br/></li>
<li></span><span class="Comment">(** The boolean 'and'. Evaluation is sequential, <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a>-to-<a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in [e1 &amp;&amp; e2], [e1] is evaluated first, and if it returns [false],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [e2] is not evaluated at all.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Right-associative operator,&nbsp; see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">||</span> <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%sequor&quot;<br/></li>
<li></span><span class="Comment">(** The boolean 'or'. Evaluation is sequential, <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a>-to-<a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in [e1 || e2], [e1] is evaluated first, and if it returns [true],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [e2] is not evaluated at all.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Right-associative operator,&nbsp; see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Debugging} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__LOC__</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_LOC&quot;<br/></li>
<li></span><span class="Comment">(** [__LOC__] returns the <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> at which this expression appears in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> currently being parsed by the compiler, with the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> of OCaml: &quot;File %S, line %d, characters %d-%d&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__FILE__</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_FILE&quot;<br/></li>
<li></span><span class="Comment">(** [__FILE__] returns the <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> currently being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; parsed by the compiler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__LINE__</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_LINE&quot;<br/></li>
<li></span><span class="Comment">(** [__LINE__] returns the line number at which this expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; appears in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> currently being parsed by the compiler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__MODULE__</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_MODULE&quot;<br/></li>
<li></span><span class="Comment">(** [__MODULE__] returns the module <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; parsed by the compiler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__POS__</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_POS&quot;<br/></li>
<li></span><span class="Comment">(** [__POS__] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> tuple [(<a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>,lnum,cnum,enum)], corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to the <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> at which this expression appears in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; currently being parsed by the compiler. [<a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>] is the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; filename, [lnum] the line number, [cnum] the character <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the line and [enum] the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> character <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in the line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__FUNCTION__</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_FUNCTION&quot;<br/></li>
<li></span><span class="Comment">(** [__FUNCTION__] returns the <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> of the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> function or method, including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; any enclosing modules or classes.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.12 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__LOC_OF__</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_LOC&quot;<br/></li>
<li></span><span class="Comment">(** [__LOC_OF__ expr] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair [(loc, expr)] where [loc] is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> of [expr] in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> currently being parsed by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; compiler, with the standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> of OCaml: &quot;File %S, line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; %d, characters %d-%d&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__LINE_OF__</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_LINE&quot;<br/></li>
<li></span><span class="Comment">(** [__LINE_OF__ expr] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair [(line, expr)], where [line] is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; line number at which the expression [expr] appears in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; currently being parsed by the compiler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">__POS_OF__</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%loc_POS&quot;<br/></li>
<li></span><span class="Comment">(** [__POS_OF__ expr] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair [(loc,expr)], where [loc] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; tuple [(<a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>,lnum,cnum,enum)] corresponding to the <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; which the expression [expr] appears in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> currently being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; parsed by the compiler. [<a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>] is the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> filename, [lnum] the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; line number, [cnum] the character <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in the line and [enum]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> character <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in the line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.02<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Composition operators} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">|&gt;</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">=</span> <span class="Constant">&quot;%revapply&quot;<br/></li>
<li></span><span class="Comment">(** Reverse-application operator: [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> |&gt; f |&gt; g] is exactly equivalent<br/></li>
<li></span><span class="Comment"> to [g (f (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>))].<br/></li>
<li></span><span class="Comment"> Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment"> @since 4.01<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> @@ <span class="Statement">)</span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">=</span> <span class="Constant">&quot;%apply&quot;<br/></li>
<li></span><span class="Comment">(** Application operator: [g @@ f @@ <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is exactly equivalent to<br/></li>
<li></span><span class="Comment"> [g (f (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>))].<br/></li>
<li></span><span class="Comment"> Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment"> @since 4.01<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Integer arithmetic} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Integers are [Sys.<a href="sys.mli.html#L175" title="ocaml/stdlib/sys.mli:175">int_size</a>] <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a> wide.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; All operations are taken modulo 2{^[Sys.<a href="sys.mli.html#L175" title="ocaml/stdlib/sys.mli:175">int_size</a>]}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; They do not fail on overflow. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">~</span>- <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%negint&quot;<br/></li>
<li></span><span class="Comment">(** Unary negation. You can also write [- <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] instead of [~- <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Unary operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">~</span>+ <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%identity&quot;<br/></li>
<li></span><span class="Comment">(** Unary addition. You can also write [+ <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] instead of [~+ <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Unary operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L48" title="ocaml/stdlib/int32.ml:48">succ</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%succint&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L48" title="ocaml/stdlib/int32.ml:48">succ</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> + 1]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L49" title="ocaml/stdlib/int32.ml:49">pred</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%predint&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L49" title="ocaml/stdlib/int32.ml:49">pred</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> - 1]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> + <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%addint&quot;<br/></li>
<li></span><span class="Comment">(** Integer addition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> - <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%subint&quot;<br/></li>
<li></span><span class="Comment">(** Integer subtraction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, , see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">*</span> <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%mulint&quot;<br/></li>
<li></span><span class="Comment">(** Integer multiplication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> / <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%divint&quot;<br/></li>
<li></span><span class="Comment">(** Integer division.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Integer division rounds the real quotient of its arguments towards <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; More precisely, if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0] and [y &gt; 0], [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> / y] is the greatest integer<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; less than or <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to the real quotient of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] by [y].&nbsp; Moreover,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [(- <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>) / y = <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> / (- y) = - (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> / y)].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Division_by_zero if the second argument is 0.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">mod</span> <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%modint&quot;<br/></li>
<li></span><span class="Comment">(** Integer remainder.&nbsp; If [y] is not <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> mod y] satisfies the following properties:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> / y) * y + <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> mod y] and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="int32.ml.html#L50" title="ocaml/stdlib/int32.ml:50">abs</a>(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> mod y) &lt;= <a href="int32.ml.html#L50" title="ocaml/stdlib/int32.ml:50">abs</a>(y) - 1].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If [y = 0], [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> mod y] raises [Division_by_zero].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Note that [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> mod y] is negative only if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &lt; 0].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Division_by_zero if [y] is <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L50" title="ocaml/stdlib/int32.ml:50">abs</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L50" title="ocaml/stdlib/int32.ml:50">abs</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the absolute value of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. On [<a href="int32.ml.html#L51" title="ocaml/stdlib/int32.ml:51">min_int</a>] this<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is [<a href="int32.ml.html#L51" title="ocaml/stdlib/int32.ml:51">min_int</a>] itself and thus remains negative. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L52" title="ocaml/stdlib/int32.ml:52">max_int</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** The greatest representable integer. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L51" title="ocaml/stdlib/int32.ml:51">min_int</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** The smallest representable integer. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {2 Bitwise operations} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">land</span> <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%andint&quot;<br/></li>
<li></span><span class="Comment">(** Bitwise logical and.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">lor</span> <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%orint&quot;<br/></li>
<li></span><span class="Comment">(** Bitwise logical or.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">lxor</span> <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%xorint&quot;<br/></li>
<li></span><span class="Comment">(** Bitwise logical exclusive or.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="Statement"><a href="stdlib.ml.html#L104" title="ocaml/stdlib/stdlib.ml:104">lnot</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Bitwise logical negation. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">lsl</span> <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%lslint&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> lsl m] shifts [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] to the <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> by [m] <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is unspecified if [m &lt; 0] or [m &gt; Sys.<a href="sys.mli.html#L175" title="ocaml/stdlib/sys.mli:175">int_size</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">lsr</span> <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%lsrint&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> lsr m] shifts [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] to the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> by [m] <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; This is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> logical shift: zeroes are inserted regardless of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the sign of [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is unspecified if [m &lt; 0] or [m &gt; Sys.<a href="sys.mli.html#L175" title="ocaml/stdlib/sys.mli:175">int_size</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">asr</span> <span class="Statement">)</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%asrint&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> asr m] shifts [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] to the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> by [m] <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; This is an arithmetic shift: the sign bit of [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is replicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is unspecified if [m &lt; 0] or [m &gt; Sys.<a href="sys.mli.html#L175" title="ocaml/stdlib/sys.mli:175">int_size</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Floating-point arithmetic}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; OCaml'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> floating-point numbers follow the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; IEEE 754 standard, using double <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a> (64 <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a>) numbers.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Floating-point operations never raise an exception on overflow,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; underflow, division by <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, etc.&nbsp; Instead, special IEEE numbers<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are returned as appropriate, such as [<a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>] for [1.0 /. 0.0],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="stdlib.ml.html#L181" title="ocaml/stdlib/stdlib.ml:181">neg_infinity</a>] for [-1.0 /. 0.0], and [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] ('not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number')<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for [0.0 /. 0.0].&nbsp; These special numbers then propagate through<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; floating-point computations as expected: for instance,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [1.0 /. <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>] is [0.0], basic arithmetic operations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ([+.], [-.], [*.], [/.]) with [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as an argument <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], ...<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">~</span>-. <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%negfloat&quot;<br/></li>
<li></span><span class="Comment">(** Unary negation. You can also write [-. <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] instead of [~-. <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Unary operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">~</span>+. <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%identity&quot;<br/></li>
<li></span><span class="Comment">(** Unary addition. You can also write [+. <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] instead of [~+. <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Unary operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> +. <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%addfloat&quot;<br/></li>
<li></span><span class="Comment">(** Floating-point addition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> -. <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%subfloat&quot;<br/></li>
<li></span><span class="Comment">(** Floating-point subtraction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">*</span>. <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%mulfloat&quot;<br/></li>
<li></span><span class="Comment">(** Floating-point multiplication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> /. <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%divfloat&quot;<br/></li>
<li></span><span class="Comment">(** Floating-point division.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Left-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">**</span> <span class="Statement">)</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_power_float&quot;</span> <span class="Constant">&quot;<a href="complex.ml.html#L79" title="ocaml/stdlib/complex.ml:79">pow</a>&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exponentiation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L57" title="ocaml/stdlib/complex.ml:57">sqrt</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_sqrt_float&quot;</span> <span class="Constant">&quot;<a href="complex.ml.html#L57" title="ocaml/stdlib/complex.ml:57">sqrt</a>&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Square root. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L74" title="ocaml/stdlib/complex.ml:74">exp</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_exp_float&quot;</span> <span class="Constant">&quot;<a href="complex.ml.html#L74" title="ocaml/stdlib/complex.ml:74">exp</a>&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exponential. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L77" title="ocaml/stdlib/complex.ml:77">log</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_log_float&quot;</span> <span class="Constant">&quot;<a href="complex.ml.html#L77" title="ocaml/stdlib/complex.ml:77">log</a>&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Natural logarithm. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">log10</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_log10_float&quot;</span> <span class="Constant">&quot;log10&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Base 10 logarithm. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">expm1</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_expm1_float&quot;</span> <span class="Constant">&quot;caml_expm1&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [expm1 <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] computes [<a href="complex.ml.html#L74" title="ocaml/stdlib/complex.ml:74">exp</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -. 1.0], giving numerically-accurate results<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; even if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> to [0.0].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">log1p</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_log1p_float&quot;</span> <span class="Constant">&quot;caml_log1p&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [log1p <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] computes [<a href="complex.ml.html#L77" title="ocaml/stdlib/complex.ml:77">log</a>(1.0 +. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)] (natural logarithm),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; giving numerically-accurate results even if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> to [0.0].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">cos</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_cos_float&quot;</span> <span class="Constant">&quot;cos&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Cosine.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">sin</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_sin_float&quot;</span> <span class="Constant">&quot;sin&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Sine.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">tan</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_tan_float&quot;</span> <span class="Constant">&quot;tan&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Tangent.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">acos</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_acos_float&quot;</span> <span class="Constant">&quot;acos&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Arc cosine.&nbsp; The argument must fall within the range [[-1.0, 1.0]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [0.0] and [<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">asin</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_asin_float&quot;</span> <span class="Constant">&quot;asin&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Arc sine.&nbsp; The argument must fall within the range [[-1.0, 1.0]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [-<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>/2] and [<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>/2]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">atan</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_atan_float&quot;</span> <span class="Constant">&quot;atan&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Arc tangent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [-<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>/2] and [<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>/2]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">atan2</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_atan2_float&quot;</span> <span class="Constant">&quot;atan2&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [atan2 y <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the arc tangent of [y /. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].&nbsp; The signs of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and [y] are used to determine the quadrant of the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [-<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>] and [<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">hypot</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_hypot_float&quot;</span> <span class="Constant">&quot;caml_hypot&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [hypot <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns [<a href="complex.ml.html#L57" title="ocaml/stdlib/complex.ml:57">sqrt</a>(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> *. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> + y *. y)], that is, the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a><br/></li>
<li></span><span class="Comment">&nbsp; of the hypotenuse of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>-angled triangle with sides of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a><br/></li>
<li></span><span class="Comment">&nbsp; [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and [y], or, equivalently, the distance of the point [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>,y)]<br/></li>
<li></span><span class="Comment">&nbsp; to origin.&nbsp; If <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or [y] is infinite, returns [<a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>]<br/></li>
<li></span><span class="Comment">&nbsp; even if the other is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>].<br/></li>
<li></span><span class="Comment">&nbsp; @since 4.00&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">cosh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_cosh_float&quot;</span> <span class="Constant">&quot;cosh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic cosine.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">sinh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_sinh_float&quot;</span> <span class="Constant">&quot;sinh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic sine.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">tanh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_tanh_float&quot;</span> <span class="Constant">&quot;tanh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic tangent.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">acosh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_acosh_float&quot;</span> <span class="Constant">&quot;caml_acosh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic arc cosine.&nbsp; The argument must fall within the range<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [[1.0, inf]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [0.0] and [inf].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">asinh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_asinh_float&quot;</span> <span class="Constant">&quot;caml_asinh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic arc sine.&nbsp; The argument and <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> range over the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; real line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">atanh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_atanh_float&quot;</span> <span class="Constant">&quot;caml_atanh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic arc tangent.&nbsp; The argument must fall within the range<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [[-1.0, 1.0]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and ranges over the entire real line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">ceil</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_ceil_float&quot;</span> <span class="Constant">&quot;ceil&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Round above to an integer value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [ceil f] returns the least integer value greater than or <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is returned as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">floor</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_floor_float&quot;</span> <span class="Constant">&quot;floor&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Round below to an integer value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [floor f] returns the greatest integer value less than or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is returned as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">abs_float</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%absfloat&quot;<br/></li>
<li></span><span class="Comment">(** [abs_float f] returns the absolute value of [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">copysign</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">=</span> <span class="Constant">&quot;caml_copysign_float&quot;</span> <span class="Constant">&quot;caml_copysign&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [copysign <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> whose absolute value is that of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; and whose sign is that of [y].&nbsp; If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], returns [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>].<br/></li>
<li></span><span class="Comment">&nbsp; If [y] is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], returns either [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or [-. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], but it is not<br/></li>
<li></span><span class="Comment">&nbsp; specified which.<br/></li>
<li></span><span class="Comment">&nbsp; @since 4.00&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">mod_float</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_fmod_float&quot;</span> <span class="Constant">&quot;fmod&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [mod_float <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] returns the remainder of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] with respect to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [b].&nbsp; The returned value is [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> -. <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> *. b], where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is the quotient [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> /. b] rounded towards <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> to an integer. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">frexp</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_frexp_float&quot;<br/></li>
<li></span><span class="Comment">(** [frexp f] returns the pair of the significant<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and the exponent of [f].&nbsp; When [f] is <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; significant [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and the exponent [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] of [f] are <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>.&nbsp; When [f] is non-<a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, they are defined by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f = <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> *. 2 ** <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] and [0.5 &lt;= <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &lt; 1.0]. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">ldexp</span> : <span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">])</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">untagged</span><span class="Statement">])</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">])</span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Constant">&quot;caml_ldexp_float&quot;</span> <span class="Constant">&quot;caml_ldexp_float_unboxed&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [ldexp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> *. 2 ** <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">modf</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">*</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_modf_float&quot;<br/></li>
<li></span><span class="Comment">(** [modf f] returns the pair of the fractional and integral<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; part of [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%floatofint&quot;<br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.float_of_int}. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">float_of_int</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%floatofint&quot;<br/></li>
<li></span><span class="Comment">(** Convert an integer to floating-point. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="buffer.ml.html#L285" title="ocaml/stdlib/buffer.ml:285">truncate</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%intoffloat&quot;<br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.int_of_float}. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">int_of_float</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%intoffloat&quot;<br/></li>
<li></span><span class="Comment">(** Truncate the given floating-point number to an integer.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is unspecified if the argument is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] or falls outside the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; range of representable integers. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** Positive <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L181" title="ocaml/stdlib/stdlib.ml:181">neg_infinity</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** Negative <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** A special floating-point value denoting the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; undefined operation such as [0.0 /. 0.0].&nbsp; Stands for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; 'not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number'.&nbsp; Any floating-point operation with [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument returns [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>, unless otherwise specified in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; IEEE 754 standard.&nbsp; As for floating-point comparisons,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [=], [&lt;], [&lt;=], [&gt;] and [&gt;=] <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> [false] and [&lt;&gt;] returns [true]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; if <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> or both of their arguments is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> quiet NaN since 5.1;&nbsp; it was <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> signaling NaN <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The largest positive finite value of type [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L187" title="ocaml/stdlib/stdlib.ml:187">min_float</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The smallest positive, non-<a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, non-denormalized value of type [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L189" title="ocaml/stdlib/stdlib.ml:189">epsilon_float</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The difference between [1.0] and the smallest exactly representable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; floating-point number greater than [1.0]. *)<br/></li>
<li></span><br/></li>
<li><a id="L670">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">fpclass</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">FP_normal</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** Normal number, <a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> of the below *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">FP_subnormal</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** Number very <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> to 0.0, has reduced <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a> *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">FP_zero</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** Number is 0.0 or -0.0 *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">FP_infinite</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** Number is positive or negative <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a> *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">FP_nan</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** Not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number: <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of an undefined operation *)<br/></li>
<li></span><span class="Comment">(** The five classes of floating-point numbers, as determined by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the {!Stdlib.classify_float} function. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">classify_float</span> : <span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">])</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="float.mli.html#L202" title="ocaml/stdlib/float.mli:202">fpclass</a></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Constant">&quot;caml_classify_float&quot;</span> <span class="Constant">&quot;caml_classify_float_unboxed&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Return the class of the given floating-point number:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; normal, subnormal, <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, infinite, or not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 String operations}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; More <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> operations are provided in module {!String}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L690">&#x200c;</a><span class="Statement">val</span> <span class="Statement">(</span> <span class="Statement">^</span> <span class="Statement">)</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** String concatenation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is longer then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; than {!Sys.<a href="sys.mli.html#L185" title="ocaml/stdlib/sys.mli:185">max_string_length</a>} <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Character operations}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; More character operations are provided in module {!Char}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">int_of_char</span> : <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%identity&quot;<br/></li>
<li></span><span class="Comment">(** Return the ASCII code of the argument. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L223" title="ocaml/stdlib/stdlib.ml:223">char_of_int</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a><br/></li>
<li></span><span class="Comment">(** Return the character with the given ASCII code.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if the argument is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; outside the range 0--255. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Unit operations} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">ignore</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%ignore&quot;<br/></li>
<li></span><span class="Comment">(** Discard the value of its argument and <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> [()].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; For instance, [ignore(f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)] discards the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the side-effecting function [f].&nbsp; It is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>; ()], except that the latter may generate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; compiler warning; writing [ignore(f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)] instead<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; avoids the warning. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 String conversion functions} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L253" title="ocaml/stdlib/stdlib.ml:253">string_of_bool</a></span> : <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> boolean. As the returned values<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; may be shared, the user should not modify them directly.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L260" title="ocaml/stdlib/stdlib.ml:260">bool_of_string_opt</a></span>: <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Convert the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> boolean.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Return [None] if the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is not [&quot;true&quot;] or [&quot;false&quot;].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L255" title="ocaml/stdlib/stdlib.ml:255">bool_of_string</a></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.<a href="stdlib.ml.html#L260" title="ocaml/stdlib/stdlib.ml:260">bool_of_string_opt</a>}, but raise<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [Invalid_argument &quot;<a href="stdlib.ml.html#L255" title="ocaml/stdlib/stdlib.ml:255">bool_of_string</a>&quot;] instead of returning [None]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L265" title="ocaml/stdlib/stdlib.ml:265">string_of_int</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> representation of an integer, in decimal. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L270" title="ocaml/stdlib/stdlib.ml:270">int_of_string_opt</a></span>: <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Convert the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> to an integer.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is read in decimal (by default, or if the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; begins with [0u]), in hexadecimal (if it begins with [0x] or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [0X]), in octal (if it begins with [0o] or [0O]), or in binary<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (if it begins with [0b] or [0B]).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The [0u] prefix reads the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> as an unsigned integer in the range<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [[0, 2*<a href="int32.ml.html#L52" title="ocaml/stdlib/int32.ml:52">max_int</a>+1]].&nbsp; If the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> exceeds {!<a href="int32.ml.html#L52" title="ocaml/stdlib/int32.ml:52">max_int</a>}<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; it is converted to the signed integer<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="int32.ml.html#L51" title="ocaml/stdlib/int32.ml:51">min_int</a> + <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> - <a href="int32.ml.html#L52" title="ocaml/stdlib/int32.ml:52">max_int</a> - 1].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The [_] (underscore) character can appear anywhere in the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and is <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Return [None] if the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid representation of an<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; integer, or if the integer represented exceeds the range of integers<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; representable in type [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">int_of_string</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_int_of_string&quot;<br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.<a href="stdlib.ml.html#L270" title="ocaml/stdlib/stdlib.ml:270">int_of_string_opt</a>}, but raise<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [Failure &quot;int_of_string&quot;] instead of returning [None]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L287" title="ocaml/stdlib/stdlib.ml:287">string_of_float</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating-point number.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This conversion can involve <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> loss of <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a>. For greater <a href="gc.mli.html#L113" title="ocaml/stdlib/gc.mli:113">control</a> over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the manner in which the number is printed, see {!Printf}. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L291" title="ocaml/stdlib/stdlib.ml:291">float_of_string_opt</a></span>: <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Convert the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>.&nbsp; The <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is read in decimal<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (by default) or in hexadecimal (marked by [0x] or [0X]).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> of decimal floating-point numbers is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [ [-] dd.ddd (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>|E) [+|-] dd ], where [d] stands for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> decimal digit.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> of hexadecimal floating-point numbers is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [ [-] 0(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>|X) hh.hhh (<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>|P) [+|-] dd ], where [h] stands for an<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; hexadecimal digit and [d] for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> decimal digit.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; In both cases, at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the integer and fractional parts must be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; given; the exponent part is optional.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The [_] (underscore) character can appear anywhere in the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and is <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Depending on the execution platforms, other representations of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; floating-point numbers can be accepted, but should not be relied upon.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Return [None] if the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">float_of_string</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_float_of_string&quot;<br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.<a href="stdlib.ml.html#L291" title="ocaml/stdlib/stdlib.ml:291">float_of_string_opt</a>}, but raise<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [Failure &quot;float_of_string&quot;] instead of returning [None]. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Pair operations} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">fst</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%field0&quot;<br/></li>
<li></span><span class="Comment">(** Return the first component of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">snd</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">=</span> <span class="Constant">&quot;%field1&quot;<br/></li>
<li></span><span class="Comment">(** Return the second component of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 List operations}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; More list operations are provided in module {!List}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="Statement">(</span> @ <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [l0 @ <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] appends [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>] to [l0]. Same function as {!List.<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a>}.<br/></li>
<li></span><span class="Comment">&nbsp; Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">&nbsp; @since 5.1 this function is tail-recursive.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Input/<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Note: all <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>/<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions can raise [Sys_error] when the system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; calls they invoke fail. *)<br/></li>
<li></span><br/></li>
<li><a id="L827">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">in_channel</span><br/></li>
<li></span><span class="Comment">(** The type of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L830">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">out_channel</span><br/></li>
<li></span><span class="Comment">(** The type of <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L833">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stdin</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** The standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> for the process. *)<br/></li>
<li></span><br/></li>
<li><a id="L836">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stdout</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a><br/></li>
<li></span><span class="Comment">(** The standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> for the process. *)<br/></li>
<li></span><br/></li>
<li><a id="L839">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stderr</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a><br/></li>
<li></span><span class="Comment">(** The standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> for the process. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {2 Output functions on standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>} *)<br/></li>
<li></span><br/></li>
<li><a id="L845">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_char</span></span> : <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> character on standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L848">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_string</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> on standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L851">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_bytes</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence on standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><a id="L855">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_int</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print an integer, in decimal, on standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L858">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_float</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating-point number, in decimal, on standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The conversion of the number to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> uses {!<a href="stdlib.ml.html#L287" title="ocaml/stdlib/stdlib.ml:287">string_of_float</a>} and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; can involve <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> loss of <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L864">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_endline</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>, followed by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline character, on<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> and <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L868">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_newline</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline character on standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>, and <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>. This can be used to simulate line<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; buffering of standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {2 Output functions on standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>} *)<br/></li>
<li></span><br/></li>
<li><a id="L876">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">prerr_char</span></span> : <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> character on standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L879">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">prerr_string</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> on standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L882">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">prerr_bytes</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence on standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><a id="L886">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">prerr_int</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print an integer, in decimal, on standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L889">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">prerr_float</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating-point number, in decimal, on standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The conversion of the number to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> uses {!<a href="stdlib.ml.html#L287" title="ocaml/stdlib/stdlib.ml:287">string_of_float</a>} and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; can involve <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> loss of <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L895">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">prerr_endline</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>, followed by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline character on standard<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> and <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L899">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">prerr_newline</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline character on standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>, and <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {2 Input functions on standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>} *)<br/></li>
<li></span><br/></li>
<li><a id="L906">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">read_line</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Flush standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>, then read characters from standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; until <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline character is encountered.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Return the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> of all characters read, without the newline character<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; at the end.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise End_of_file if the end of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached at the beginning of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; line.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L917">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">read_int_opt</span></span>: <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Flush standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>, then read <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> line from standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and convert it to an integer.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Return [None] if the line read is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid representation of an integer.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L925">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">read_int</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.<a href="stdlib.ml.html#L510" title="ocaml/stdlib/stdlib.ml:510">read_int_opt</a>}, but raise [Failure &quot;int_of_string&quot;]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; instead of returning [None]. *)<br/></li>
<li></span><br/></li>
<li><a id="L929">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">read_float_opt</span></span>: <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Flush standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>, then read <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> line from standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and convert it to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating-point number.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Return [None] if the line read is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; floating-point number.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.05<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L938">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">read_float</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.<a href="stdlib.ml.html#L512" title="ocaml/stdlib/stdlib.ml:512">read_float_opt</a>}, but raise [Failure &quot;float_of_string&quot;]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; instead of returning [None]. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {2 General <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions} *)<br/></li>
<li></span><br/></li>
<li><a id="L945">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">open_flag</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">Open_rdonly</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for reading. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_wronly</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for writing. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_append</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for appending: always write at end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_creat</span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> if it does not exist. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_trunc</span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> if it already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_excl</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** fail if Open_creat and the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_binary</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open in binary mode (no conversion). *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_text</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** open in text mode (may perform conversions). *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_nonblock</span>&nbsp; &nbsp; <span class="Comment">(** open in non-blocking mode. *)<br/></li>
<li></span><span class="Comment">(** Opening modes for {!Stdlib.<a href="stdlib.ml.html#L330" title="ocaml/stdlib/stdlib.ml:330">open_out_gen</a>} and<br/></li>
<li></span><span class="Comment">&nbsp; {!Stdlib.<a href="stdlib.ml.html#L404" title="ocaml/stdlib/stdlib.ml:404">open_in_gen</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L958">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_out</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a><br/></li>
<li></span><span class="Comment">(** Open the named <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> for writing, and <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; on that <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, positioned at the beginning of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>. The<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is truncated to <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> if it already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. It<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is created if it does not already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L964">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_out_bin</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a><br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.<a href="stdlib.ml.html#L335" title="ocaml/stdlib/stdlib.ml:335">open_out</a>}, but the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is opened in binary mode,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; so that no translation takes place during writes. On operating<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; systems that do not distinguish between text mode and binary<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mode, this function behaves like {!Stdlib.<a href="stdlib.ml.html#L335" title="ocaml/stdlib/stdlib.ml:335">open_out</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L970">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_out_gen</span></span> : <span class="ocamlLCIdentifier"><a href="in_channel.ml.html#L18" title="ocaml/stdlib/in_channel.ml:18">open_flag</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a><br/></li>
<li></span><span class="Comment">(** [<a href="stdlib.ml.html#L330" title="ocaml/stdlib/stdlib.ml:330">open_out_gen</a> mode perm filename] opens the named <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> for writing,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as described above. The extra argument [mode]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; specifies the opening mode. The extra argument [perm] specifies<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> permissions, in case the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> must be created.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Stdlib.<a href="stdlib.ml.html#L335" title="ocaml/stdlib/stdlib.ml:335">open_out</a>} and {!Stdlib.<a href="stdlib.ml.html#L338" title="ocaml/stdlib/stdlib.ml:338">open_out_bin</a>} are special<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; cases of this function. *)<br/></li>
<li></span><br/></li>
<li><a id="L978">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">flush</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Flush the <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> associated with the given <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; performing all pending writes on that channel.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Interactive programs must be careful about flushing standard<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> and standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> at the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> time. *)<br/></li>
<li></span><br/></li>
<li><a id="L984">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">flush_all</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Flush all open <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channels; ignore <a href="printexc.ml.html#L299" title="ocaml/stdlib/printexc.ml:299">errors</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L987">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_char</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write the character on the given <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L990">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_string</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> on the given <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L993">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_bytes</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write the byte sequence on the given <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><a id="L997">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> oc <a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a> <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] writes [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters from byte sequence [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; starting at <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>], to the given <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel [oc].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L1003">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_substring</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as [<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>] but <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> as argument instead of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><a id="L1008">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_byte</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> 8-bit integer (as the single character with that code)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; on the given <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. The given integer is taken modulo<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; 256. *)<br/></li>
<li></span><br/></li>
<li><a id="L1013">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_binary_int</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> integer in binary <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> (4 <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>, big-endian)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; on the given <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The given integer is taken modulo 2{^32}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The only reliable way to read it back is through the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Stdlib.<a href="#L1140" title="ocaml/stdlib/stdlib.mli:1140">input_binary_int</a>} function. The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> is compatible across<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; all machines for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> given version of OCaml. *)<br/></li>
<li></span><br/></li>
<li><a id="L1021">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_value</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write the representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> structured value of any type<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> channel. Circularities and sharing inside the value<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are detected and preserved. The object can be read back,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; by the function {!Stdlib.<a href="#L1146" title="ocaml/stdlib/stdlib.mli:1146">input_value</a>}. See the description of module<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Marshal} for more information. {!Stdlib.<a href="stdlib.ml.html#L386" title="ocaml/stdlib/stdlib.ml:386">output_value</a>} is equivalent<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to {!Marshal.<a href="marshal.mli.html#L63" title="ocaml/stdlib/marshal.mli:63">to_channel</a>} with an <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> list of flags. *)<br/></li>
<li></span><br/></li>
<li><a id="L1029">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">seek_out</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1029" title="ocaml/stdlib/stdlib.mli:1029">seek_out</a> chan <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] sets the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> writing <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for channel [chan]. This works only for regular files. On<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; files of other kinds (such as terminals, pipes and sockets),<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the behavior is unspecified. *)<br/></li>
<li></span><br/></li>
<li><a id="L1035">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pos_out</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> writing <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> for the given channel.&nbsp; Does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; not work on channels opened with the [Open_append] flag (returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; unspecified results).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For files opened in text mode under Windows, the returned <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is approximate (owing to end-of-line conversion); in particular,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; saving the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> with [<a href="#L1035" title="ocaml/stdlib/stdlib.mli:1035">pos_out</a>], then going back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; this <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> using [<a href="#L1029" title="ocaml/stdlib/stdlib.mli:1029">seek_out</a>] will not work.&nbsp; For this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; programming idiom to work reliably and portably, the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; opened in binary mode. *)<br/></li>
<li></span><br/></li>
<li><a id="L1046">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">out_channel_length</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> (number of characters) of the regular <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; on which the given channel is opened.&nbsp; If the channel is opened<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> that is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> regular <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is meaningless. *)<br/></li>
<li></span><br/></li>
<li><a id="L1051">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_out</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Close the given channel, flushing all buffered write operations.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Output functions raise <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [Sys_error] exception when they are<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; applied to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> closed <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel, except [<a href="stdlib.ml.html#L392" title="ocaml/stdlib/stdlib.ml:392">close_out</a>] and [<a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; which do nothing when applied to an already closed channel.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Note that [<a href="stdlib.ml.html#L392" title="ocaml/stdlib/stdlib.ml:392">close_out</a>] may raise [Sys_error] if the operating<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; system signals an <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> when flushing or <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L1059">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_out_noerr</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as [<a href="stdlib.ml.html#L392" title="ocaml/stdlib/stdlib.ml:392">close_out</a>], but ignore all <a href="printexc.ml.html#L299" title="ocaml/stdlib/printexc.ml:299">errors</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L1062">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_binary_mode_out</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1062" title="ocaml/stdlib/stdlib.mli:1062">set_binary_mode_out</a> oc true] sets the channel [oc] to binary<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mode: no translations <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place during <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L1062" title="ocaml/stdlib/stdlib.mli:1062">set_binary_mode_out</a> oc false] sets the channel [oc] to text<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mode: depending on the operating system, <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> translations<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; may <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place during <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.&nbsp; For instance, under Windows,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; end-of-lines will be translated from [\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] to [\<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This function has no effect under operating systems that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; do not distinguish between text mode and binary mode. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {2 General <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions} *)<br/></li>
<li></span><br/></li>
<li><a id="L1075">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_in</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** Open the named <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> for reading, and <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; on that <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, positioned at the beginning of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L1079">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_in_bin</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.<a href="stdlib.ml.html#L409" title="ocaml/stdlib/stdlib.ml:409">open_in</a>}, but the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is opened in binary mode,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; so that no translation takes place during reads. On operating<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; systems that do not distinguish between text mode and binary<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mode, this function behaves like {!Stdlib.<a href="stdlib.ml.html#L409" title="ocaml/stdlib/stdlib.ml:409">open_in</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L1085">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_in_gen</span></span> : <span class="ocamlLCIdentifier"><a href="in_channel.ml.html#L18" title="ocaml/stdlib/in_channel.ml:18">open_flag</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** [<a href="stdlib.ml.html#L404" title="ocaml/stdlib/stdlib.ml:404">open_in_gen</a> mode perm filename] opens the named <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> for reading,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as described above. The extra arguments<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [mode] and [perm] specify the opening mode and <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> permissions.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Stdlib.<a href="stdlib.ml.html#L409" title="ocaml/stdlib/stdlib.ml:409">open_in</a>} and {!Stdlib.<a href="stdlib.ml.html#L412" title="ocaml/stdlib/stdlib.ml:412">open_in_bin</a>} are special<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; cases of this function. *)<br/></li>
<li></span><br/></li>
<li><a id="L1092">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_char</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a><br/></li>
<li></span><span class="Comment">(** Read <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> character from the given <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise End_of_file if there are no more characters to read. *)<br/></li>
<li></span><br/></li>
<li><a id="L1096">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_line</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Read characters from the given <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel, until <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; newline character is encountered. Return the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; all characters read, without the newline character at the end.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise End_of_file if the end of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; at the beginning of line. *)<br/></li>
<li></span><br/></li>
<li><a id="L1103">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> ic <a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a> <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] reads up to [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters from<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the given channel [ic], storing them in byte sequence [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>], starting at<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; character number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; It returns the actual number of characters read, between 0 and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] (inclusive).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; A <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> value of 0 means that the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> was reached.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; A <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> value between 0 and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] exclusive means that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; not all requested [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters were read, either because<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; no more characters were available at that time, or because<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the implementation found it convenient to do <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> partial read;<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>] must be called again to read the remaining characters,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if desired.&nbsp; (See also {!Stdlib.<a href="in_channel.ml.html#L71" title="ocaml/stdlib/in_channel.ml:71">really_input</a>} for reading<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; exactly [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters.)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Exception [Invalid_argument &quot;<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>&quot;] is raised if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L1120">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">really_input</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L71" title="ocaml/stdlib/in_channel.ml:71">really_input</a> ic <a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a> <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] reads [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters from channel [ic],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; storing them in byte sequence [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>], starting at character number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise End_of_file if the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; characters have been read.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Invalid_argument if<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L1128">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">really_input_string</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L76" title="ocaml/stdlib/in_channel.ml:76">really_input_string</a> ic <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] reads [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters from channel [ic]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and returns them in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise End_of_file if the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; characters have been read.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><a id="L1135">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_byte</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Same as {!Stdlib.<a href="#L1092" title="ocaml/stdlib/stdlib.mli:1092">input_char</a>}, but <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the 8-bit integer representing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the character.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise End_of_file if the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> was reached. *)<br/></li>
<li></span><br/></li>
<li><a id="L1140">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_binary_int</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Read an integer encoded in binary <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> (4 <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>, big-endian)<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; from the given <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel. See {!Stdlib.<a href="#L1013" title="ocaml/stdlib/stdlib.mli:1013">output_binary_int</a>}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise End_of_file if the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> was reached while reading the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; integer. *)<br/></li>
<li></span><br/></li>
<li><a id="L1146">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_value</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Read the representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> structured value, as produced<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; by {!Stdlib.<a href="stdlib.ml.html#L386" title="ocaml/stdlib/stdlib.ml:386">output_value</a>}, and <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the corresponding value.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This function is identical to {!Marshal.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a>};<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; see the description of module {!Marshal} for more information,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in particular concerning the lack of type safety. *)<br/></li>
<li></span><br/></li>
<li><a id="L1153">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">seek_in</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1153" title="ocaml/stdlib/stdlib.mli:1153">seek_in</a> chan <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] sets the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> reading <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for channel [chan]. This works only for regular files. On<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; files of other kinds, the behavior is unspecified. *)<br/></li>
<li></span><br/></li>
<li><a id="L1158">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pos_in</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> reading <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> for the given channel.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; files opened in text mode under Windows, the returned <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; approximate (owing to end-of-line conversion); in particular,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; saving the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> with [<a href="#L1158" title="ocaml/stdlib/stdlib.mli:1158">pos_in</a>], then going back to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> using [<a href="#L1153" title="ocaml/stdlib/stdlib.mli:1153">seek_in</a>] will not work.&nbsp; For this programming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; idiom to work reliably and portably, the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> must be opened in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; binary mode. *)<br/></li>
<li></span><br/></li>
<li><a id="L1167">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">in_channel_length</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> (number of characters) of the regular <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; on which the given channel is opened.&nbsp; If the channel is opened<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> that is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> regular <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is meaningless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The returned <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> does not <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> into account the end-of-line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; translations that can be performed when reading from <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> channel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; opened in text mode. *)<br/></li>
<li></span><br/></li>
<li><a id="L1175">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_in</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Close the given channel.&nbsp; Input functions raise <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [Sys_error]<br/></li>
<li></span><span class="Comment">&nbsp; exception when they are applied to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> closed <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel,<br/></li>
<li></span><span class="Comment">&nbsp; except [<a href="#L1175" title="ocaml/stdlib/stdlib.mli:1175">close_in</a>], which does nothing when applied to an already<br/></li>
<li></span><span class="Comment">&nbsp; closed channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L1181">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_in_noerr</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as [<a href="#L1175" title="ocaml/stdlib/stdlib.mli:1175">close_in</a>], but ignore all <a href="printexc.ml.html#L299" title="ocaml/stdlib/printexc.ml:299">errors</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L1184">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_binary_mode_in</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1184" title="ocaml/stdlib/stdlib.mli:1184">set_binary_mode_in</a> ic true] sets the channel [ic] to binary<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mode: no translations <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place during <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L1062" title="ocaml/stdlib/stdlib.mli:1062">set_binary_mode_out</a> ic false] sets the channel [ic] to text<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mode: depending on the operating system, <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> translations<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; may <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place during <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>.&nbsp; For instance, under Windows,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; end-of-lines will be translated from [\<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] to [\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This function has no effect under operating systems that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; do not distinguish between text mode and binary mode. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">(** {2 Operations on large files} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> LargeFile</span><span class="ocamlPreDef"> :<br/></li>
<li></span><span class="ocamlPreDef">&nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="#L1029" title="ocaml/stdlib/stdlib.mli:1029">seek_out</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="#L1035" title="ocaml/stdlib/stdlib.mli:1035">pos_out</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="#L1046" title="ocaml/stdlib/stdlib.mli:1046">out_channel_length</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="#L1153" title="ocaml/stdlib/stdlib.mli:1153">seek_in</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="#L1158" title="ocaml/stdlib/stdlib.mli:1158">pos_in</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="#L1167" title="ocaml/stdlib/stdlib.mli:1167">in_channel_length</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="Comment">(** Operations on large files.<br/></li>
<li></span><span class="Comment">&nbsp; This <a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a>-module provides 64-bit variants of the channel functions<br/></li>
<li></span><span class="Comment">&nbsp; that manipulate <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> positions and <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> sizes.&nbsp; By representing<br/></li>
<li></span><span class="Comment">&nbsp; positions and sizes by 64-bit integers (type [<a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a>]) instead of<br/></li>
<li></span><span class="Comment">&nbsp; regular integers (type [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>]), these alternate functions allow<br/></li>
<li></span><span class="Comment">&nbsp; operating on files whose sizes are greater than [<a href="int32.ml.html#L52" title="ocaml/stdlib/int32.ml:52">max_int</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 References} *)<br/></li>
<li></span><br/></li>
<li><a id="L1215">&#x200c;</a><span class="Statement">type</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><span class="linkable">ref</span></span> <span class="Statement">=</span> <span class="Statement">{</span> <span class="Statement">mutable</span> <span class="ocamlLCIdentifier"><a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">}<br/></li>
<li></span><span class="Comment">(** The type of references (mutable indirection cells) containing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L237" title="ocaml/stdlib/stdlib.ml:237">ref</a></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L237" title="ocaml/stdlib/stdlib.ml:237">ref</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%makemutable&quot;<br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh reference containing the given value. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">!</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L237" title="ocaml/stdlib/stdlib.ml:237">ref</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%field0&quot;<br/></li>
<li></span><span class="Comment">(** [!<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a> of reference [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Equivalent to [fun <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> -&gt; <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>.<a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Unary operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="Statement">(</span> <span class="Statement">:=</span> <span class="Statement">)</span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L237" title="ocaml/stdlib/stdlib.ml:237">ref</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%setfield0&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> := <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] stores the value of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in reference [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Equivalent to [fun <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> -&gt; <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>.<a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a> &lt;- <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="atomic.ml.html#L25" title="ocaml/stdlib/atomic.ml:25">incr</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L237" title="ocaml/stdlib/stdlib.ml:237">ref</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%<a href="atomic.ml.html#L25" title="ocaml/stdlib/atomic.ml:25">incr</a>&quot;<br/></li>
<li></span><span class="Comment">(** Increment the integer contained in the given reference.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Equivalent to [fun <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> -&gt; <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> := <a href="int32.ml.html#L48" title="ocaml/stdlib/int32.ml:48">succ</a> !<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="atomic.ml.html#L26" title="ocaml/stdlib/atomic.ml:26">decr</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L237" title="ocaml/stdlib/stdlib.ml:237">ref</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;%<a href="atomic.ml.html#L26" title="ocaml/stdlib/atomic.ml:26">decr</a>&quot;<br/></li>
<li></span><span class="Comment">(** Decrement the integer contained in the given reference.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Equivalent to [fun <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> -&gt; <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> := <a href="int32.ml.html#L49" title="ocaml/stdlib/int32.ml:49">pred</a> !<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Result type} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** @since 4.03 *)<br/></li>
<li><a id="L1245">&#x200c;</a></span><span class="Statement">type</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>,'<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><span class="linkable">result</span></span> <span class="Statement">=</span> <span class="Constant">Ok</span> <span class="Statement">of</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">|</span> <span class="Constant">Error</span> <span class="Statement">of</span> '<span class="ocamlLCIdentifier">b<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Operations on <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Format strings are character strings with special lexical conventions<br/></li>
<li></span><span class="Comment">&nbsp; that defines the functionality of formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>/<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions. Format<br/></li>
<li></span><span class="Comment">&nbsp; strings are used to read <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> with formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions from module<br/></li>
<li></span><span class="Comment">&nbsp; {!Scanf} and to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> with formatted <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions from modules<br/></li>
<li></span><span class="Comment">&nbsp; {!Printf} and {!Format}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Format strings are made of three kinds of entities:<br/></li>
<li></span><span class="Comment">&nbsp; - {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> conversions specifications}, introduced by the special character ['%']<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; followed by <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> or more characters specifying what <a href="bigarray.mli.html#L106" title="ocaml/stdlib/bigarray.mli:106">kind</a> of argument to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; read or <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a>,<br/></li>
<li></span><span class="Comment">&nbsp; - {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> indications}, introduced by the special character ['@']<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; followed by <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> or more characters specifying how to read or <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument,<br/></li>
<li></span><span class="Comment">&nbsp; - {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> plain characters} that are regular characters with usual lexical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; conventions. Plain characters specify <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> literals to be read in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> or printed in the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; There is an additional lexical rule to escape the special characters ['%']<br/></li>
<li></span><span class="Comment">&nbsp; and ['@'] in <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings: if <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> special character follows <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ['%']<br/></li>
<li></span><span class="Comment">&nbsp; character, it is treated as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> plain character. In other words, [&quot;%%&quot;] is<br/></li>
<li></span><span class="Comment">&nbsp; considered as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> plain ['%'] and [&quot;%@&quot;] as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> plain ['@'].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; For more information about conversion specifications and <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a><br/></li>
<li></span><span class="Comment">&nbsp; indications available, read the documentation of modules {!Scanf},<br/></li>
<li></span><span class="Comment">&nbsp; {!Printf} and {!Format}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Format strings have <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> general and highly polymorphic type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [('<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>, 'b, '<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>, 'd, '<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>, 'f) <a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The two simplified types, [<a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a>] and [<a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a>] below are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; included for backward compatibility with earlier releases of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; OCaml.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The meaning of <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> type parameters is as follows:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is the type of the parameters of the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> for formatted <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; functions ([<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>]-style functions);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is the type of the values read by the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> for formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; functions ([<a href="scanf.mli.html#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a>]-style functions).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - ['b] is the type of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> source for formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> functions and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; type of <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> target for formatted <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; For [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>]-style functions from module {!Printf}, ['b] is typically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; for [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>]-style functions from module {!Format}, ['b] is typically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {!type:Format.<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>};<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; for [<a href="scanf.mli.html#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a>]-style functions from module {!Scanf}, ['b] is typically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {!Scanf.Scanning.<a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Type argument ['b] is also the type of the first argument given to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; user'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> defined printing functions for [%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] and [%<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] conversions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and user'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> defined reading functions for [%<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] conversion.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - ['<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] is the type of the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the [%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] and [%<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] printing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; functions, and also the type of the argument transmitted to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; first argument of [<a href="printf.mli.html#L193" title="ocaml/stdlib/printf.mli:193">kprintf</a>]-style functions or to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="scanf.ml.html#L1476" title="ocaml/stdlib/scanf.ml:1476">kscanf</a>]-style functions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - ['d] is the type of parameters for the [<a href="scanf.mli.html#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a>]-style functions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - ['<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] is the type of the receiver function for the [<a href="scanf.mli.html#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a>]-style functions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - ['f] is the final <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> type of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>/<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; invocation: for the [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>]-style functions, it is typically [unit];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; for the [<a href="scanf.mli.html#L495" title="ocaml/stdlib/scanf.mli:495">scanf</a>]-style functions, it is typically the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> type of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; receiver function.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1317">&#x200c;</a><span class="Statement">type</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><span class="linkable">format6</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="PreProc">CamlinternalFormatBasics</span>.<span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a><br/></li>
<li></span><br/></li>
<li><a id="L1320">&#x200c;</a><span class="Statement">type</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="Type"><span class="linkable">format4</span></span> <span class="Statement">=</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a><br/></li>
<li></span><br/></li>
<li><a id="L1322">&#x200c;</a><span class="Statement">type</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="Type"><span class="linkable">format</span></span> <span class="Statement">=</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="Type"><a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a><br/></li>
<li></span><br/></li>
<li><a id="L1324">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">string_of_format</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Converts <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> into <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">format_of_string</span> :<br/></li>
<li>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%identity&quot;<br/></li>
<li></span><span class="Comment">(** [format_of_string <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> read from the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; literal [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Note: [format_of_string] can not convert <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> argument that is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; literal. If you need this functionality, use the more general<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Scanf.<a href="scanf.ml.html#L1516" title="ocaml/stdlib/scanf.ml:1516">format_from_string</a>} function.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="Statement">(</span> <span class="Statement">^^</span> <span class="Statement">)</span> :<br/></li>
<li>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">f</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier">f</span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span>, '<span class="ocamlLCIdentifier">g</span>, '<span class="ocamlLCIdentifier">h</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span>, '<span class="ocamlLCIdentifier">d</span>, '<span class="ocamlLCIdentifier">g</span>, '<span class="ocamlLCIdentifier">h</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="camlinternalFormatBasics.mli.html#L309" title="ocaml/stdlib/camlinternalFormatBasics.mli:309">format6</a><br/></li>
<li></span><span class="Comment">(** [f1 ^^ f2] catenates <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings [f1] and [f2]. The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> that behaves as the concatenation of <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings [f1] and<br/></li>
<li></span><span class="Comment">&nbsp; [f2]: in case of formatted <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>, it accepts arguments from [f1], then<br/></li>
<li></span><span class="Comment">&nbsp; arguments from [f2]; in case of formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>, it returns results from<br/></li>
<li></span><span class="Comment">&nbsp; [f1], then results from [f2].<br/></li>
<li></span><span class="Comment">&nbsp; Right-associative operator, see {!Ocaml_operators} for more information.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Program termination} *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier">exit</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Terminate the process, returning the given status code to the operating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; system: usually 0 to indicate no <a href="printexc.ml.html#L299" title="ocaml/stdlib/printexc.ml:299">errors</a>, and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> small positive integer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; indicate <a href="seq.ml.html#L438" title="ocaml/stdlib/seq.ml:438">failure</a>. All open <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channels are flushed with [<a href="out_channel.mli.html#L123" title="ocaml/stdlib/out_channel.mli:123">flush_all</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The callbacks registered with {!Domain.<a href="domain.mli.html#L63" title="ocaml/stdlib/domain.mli:63">at_exit</a>} are called followed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; those registered with {!Stdlib.<a href="domain.mli.html#L63" title="ocaml/stdlib/domain.mli:63">at_exit</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; An implicit [exit 0] is performed each time <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> program terminates normally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; An implicit [exit 2] is performed if the program terminates early because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of an uncaught exception. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="domain.mli.html#L63" title="ocaml/stdlib/domain.mli:63">at_exit</a></span> : <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Register the given function to be called at program termination<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; time. The functions registered with [<a href="domain.mli.html#L63" title="ocaml/stdlib/domain.mli:63">at_exit</a>] will be called when<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the program does any of the following:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - executes {!Stdlib.exit}<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - terminates, either normally or because of an uncaught<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; exception<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - executes the C function [caml_shutdown].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The functions are called in '<a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> in, first out' order: the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function most recently added with [<a href="domain.mli.html#L63" title="ocaml/stdlib/domain.mli:63">at_exit</a>] is called first. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**/**)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* The following is for system use only. Do not call directly. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L277" title="ocaml/stdlib/stdlib.ml:277">valid_float_lexem</a></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L425" title="ocaml/stdlib/stdlib.ml:425">unsafe_really_input</a></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="domain.ml.html#L179" title="ocaml/stdlib/domain.ml:179">do_at_exit</a></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L572" title="ocaml/stdlib/stdlib.ml:572">do_domain_local_at_exit</a></span> : <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L237" title="ocaml/stdlib/stdlib.ml:237">ref</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">(**/**)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:modules Standard library modules } *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(*MODULE_ALIASES*)<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Arg</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Arg<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Array</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Array<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> ArrayLabels</span><span class="ocamlPreDef">&nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">ArrayLabels<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Atomic</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Atomic<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Bigarray</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Bigarray<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Bool</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Bool<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Buffer</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Buffer<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Bytes</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Bytes<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> BytesLabels</span><span class="ocamlPreDef">&nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">BytesLabels<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Callback</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Callback<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Char</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Char<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Complex</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Complex<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Condition</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Condition<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Digest</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Digest<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Domain</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Domain<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="Constant">&quot;-unstable&quot;</span><span class="Statement">]<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="ocamlLCIdentifier">unstable<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">&quot;The Domain interface may change in incompatible ways in the future.&quot;<br/></li>
<li></span><span class="Statement">]<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Effect</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Effect<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="Constant">&quot;-unstable&quot;</span><span class="Statement">]<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="ocamlLCIdentifier">unstable<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">&quot;The Effect interface may change in incompatible ways in the future.&quot;<br/></li>
<li></span><span class="Statement">]<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Either</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Either<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Ephemeron</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Ephemeron<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Filename</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Filename<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Float</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Float<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Format</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Format<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Fun</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Fun<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Gc</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Gc<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Hashtbl</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Hashtbl<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> In_channel</span><span class="ocamlPreDef">&nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">In_channel<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Int</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Int<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Int32</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Int32<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Int64</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Int64<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Lazy</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Lazy<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Lexing</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Lexing<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> List</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">List<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> ListLabels</span><span class="ocamlPreDef">&nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">ListLabels<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Map</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Map<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Marshal</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Marshal<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> MoreLabels</span><span class="ocamlPreDef">&nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">MoreLabels<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Mutex</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Mutex<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Nativeint</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Nativeint<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Obj</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Obj<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Oo</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Oo<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Option</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Option<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Out_channel</span><span class="ocamlPreDef">&nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Out_channel<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Parsing</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Parsing<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Printexc</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Printexc<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Printf</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Printf<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Queue</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Queue<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Random</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Random<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Result</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Result<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Scanf</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Scanf<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Semaphore</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Semaphore<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Seq</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Seq<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Set</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Set<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Stack</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Stack<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> StdLabels</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">StdLabels<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> String</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">String<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> StringLabels</span><span class="ocamlPreDef">&nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">StringLabels<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Sys</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Sys<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Type</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Type<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Uchar</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">=</span> <span class="PreProc">Uchar<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Unit</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Unit<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Weak</span><span class="ocamlPreDef">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement">=</span> <span class="PreProc">Weak<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
