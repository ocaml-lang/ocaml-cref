<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/format.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/format.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L1149">add_symbolic_output_item</a></li>
<li><a href="#L1372">asprintf</a></li>
<li><a href="#L499">check_geometry</a></li>
<li><a href="#L1125">clear_symbolic_output_buffer</a></li>
<li><a href="#L180">close_box</a></li>
<li><a href="#L757">close_stag</a></li>
<li><a href="#L612">close_tbox</a></li>
<li><a href="#L1381">dprintf</a></li>
<li><a href="#L1345">eprintf</a></li>
<li><a href="#L992">err_formatter</a></li>
<li><a href="#L1031">flush_str_formatter</a></li>
<li><a href="#L1138">flush_symbolic_output_buffer</a></li>
<li><a href="#L358">force_newline</a></li>
<li><a href="#L1004">formatter_of_buffer</a></li>
<li><a href="#L962">formatter_of_out_channel</a></li>
<li><a href="#L1063">formatter_of_out_functions</a></li>
<li><a href="#L1156">formatter_of_symbolic_output_buffer</a></li>
<li><a href="#L1262">fprintf</a></li>
<li><a href="#L653">get_ellipsis_text</a></li>
<li><a href="#L998">get_err_formatter</a></li>
<li><a href="#L887">get_formatter_out_functions</a></li>
<li><a href="#L821">get_formatter_output_functions</a></li>
<li><a href="#L936">get_formatter_stag_functions</a></li>
<li><a href="#L538">get_geometry</a></li>
<li><a href="#L440">get_margin</a></li>
<li><a href="#L786">get_mark_tags</a></li>
<li><a href="#L567">get_max_boxes</a></li>
<li><a href="#L486">get_max_indent</a></li>
<li><a href="#L782">get_print_tags</a></li>
<li><a href="#L986">get_std_formatter</a></li>
<li><a href="#L1014">get_stdbuf</a></li>
<li><a href="#L1025">get_str_formatter</a></li>
<li><a href="#L1131">get_symbolic_output_buffer</a></li>
<li><a href="#L1404">ifprintf</a></li>
<li><a href="#L1428">ikfprintf</a></li>
<li><a href="#L1441">kasprintf</a></li>
<li><a href="#L1419">kdprintf</a></li>
<li><a href="#L1413">kfprintf</a></li>
<li><a href="#L1437">ksprintf</a></li>
<li><a href="#L1036">make_formatter</a></li>
<li><a href="#L1118">make_symbolic_output_buffer</a></li>
<li><a href="#L1050">make_synchronized_formatter</a></li>
<li><a href="#L156">open_box</a></li>
<li><a href="#L184">open_hbox</a></li>
<li><a href="#L219">open_hovbox</a></li>
<li><a href="#L207">open_hvbox</a></li>
<li><a href="#L746">open_stag</a></li>
<li><a href="#L597">open_tbox</a></li>
<li><a href="#L194">open_vbox</a></li>
<li><a href="#L573">over_max_boxes</a></li>
<li><a href="#L179">pp_close_box</a></li>
<li><a href="#L756">pp_close_stag</a></li>
<li><a href="#L611">pp_close_tbox</a></li>
<li><a href="#L357">pp_force_newline</a></li>
<li><a href="#L652">pp_get_ellipsis_text</a></li>
<li><a href="#L885">pp_get_formatter_out_functions</a></li>
<li><a href="#L819">pp_get_formatter_output_functions</a></li>
<li><a href="#L934">pp_get_formatter_stag_functions</a></li>
<li><a href="#L537">pp_get_geometry</a></li>
<li><a href="#L439">pp_get_margin</a></li>
<li><a href="#L785">pp_get_mark_tags</a></li>
<li><a href="#L566">pp_get_max_boxes</a></li>
<li><a href="#L485">pp_get_max_indent</a></li>
<li><a href="#L781">pp_get_print_tags</a></li>
<li><a href="#L155">pp_open_box</a></li>
<li><a href="#L183">pp_open_hbox</a></li>
<li><a href="#L218">pp_open_hovbox</a></li>
<li><a href="#L206">pp_open_hvbox</a></li>
<li><a href="#L745">pp_open_stag</a></li>
<li><a href="#L596">pp_open_tbox</a></li>
<li><a href="#L193">pp_open_vbox</a></li>
<li><a href="#L572">pp_over_max_boxes</a></li>
<li><a href="#L1187">pp_print_array</a></li>
<li><a href="#L244">pp_print_as</a></li>
<li><a href="#L262">pp_print_bool</a></li>
<li><a href="#L305">pp_print_break</a></li>
<li><a href="#L238">pp_print_bytes</a></li>
<li><a href="#L258">pp_print_char</a></li>
<li><a href="#L315">pp_print_custom_break</a></li>
<li><a href="#L296">pp_print_cut</a></li>
<li><a href="#L1239">pp_print_either</a></li>
<li><a href="#L254">pp_print_float</a></li>
<li><a href="#L378">pp_print_flush</a></li>
<li><a href="#L369">pp_print_if_newline</a></li>
<li><a href="#L250">pp_print_int</a></li>
<li><a href="#L1165">pp_print_iter</a></li>
<li><a href="#L1176">pp_print_list</a></li>
<li><a href="#L404">pp_print_newline</a></li>
<li><a href="#L1222">pp_print_option</a></li>
<li><a href="#L1231">pp_print_result</a></li>
<li><a href="#L1202">pp_print_seq</a></li>
<li><a href="#L287">pp_print_space</a></li>
<li><a href="#L234">pp_print_string</a></li>
<li><a href="#L619">pp_print_tab</a></li>
<li><a href="#L628">pp_print_tbreak</a></li>
<li><a href="#L1215">pp_print_text</a></li>
<li><a href="#L505">pp_safe_set_geometry</a></li>
<li><a href="#L646">pp_set_ellipsis_text</a></li>
<li><a href="#L790">pp_set_formatter_out_channel</a></li>
<li><a href="#L867">pp_set_formatter_out_functions</a></li>
<li><a href="#L801">pp_set_formatter_output_functions</a></li>
<li><a href="#L912">pp_set_formatter_stag_functions</a></li>
<li><a href="#L503">pp_set_geometry</a></li>
<li><a href="#L421">pp_set_margin</a></li>
<li><a href="#L777">pp_set_mark_tags</a></li>
<li><a href="#L555">pp_set_max_boxes</a></li>
<li><a href="#L445">pp_set_max_indent</a></li>
<li><a href="#L773">pp_set_print_tags</a></li>
<li><a href="#L615">pp_set_tab</a></li>
<li><a href="#L767">pp_set_tags</a></li>
<li><a href="#L534">pp_update_geometry</a></li>
<li><a href="#L245">print_as</a></li>
<li><a href="#L263">print_bool</a></li>
<li><a href="#L306">print_break</a></li>
<li><a href="#L239">print_bytes</a></li>
<li><a href="#L259">print_char</a></li>
<li><a href="#L297">print_cut</a></li>
<li><a href="#L255">print_float</a></li>
<li><a href="#L379">print_flush</a></li>
<li><a href="#L370">print_if_newline</a></li>
<li><a href="#L251">print_int</a></li>
<li><a href="#L405">print_newline</a></li>
<li><a href="#L288">print_space</a></li>
<li><a href="#L235">print_string</a></li>
<li><a href="#L620">print_tab</a></li>
<li><a href="#L629">print_tbreak</a></li>
<li><a href="#L1335">printf</a></li>
<li><a href="#L506">safe_set_geometry</a></li>
<li><a href="#L647">set_ellipsis_text</a></li>
<li><a href="#L792">set_formatter_out_channel</a></li>
<li><a href="#L869">set_formatter_out_functions</a></li>
<li><a href="#L803">set_formatter_output_functions</a></li>
<li><a href="#L914">set_formatter_stag_functions</a></li>
<li><a href="#L504">set_geometry</a></li>
<li><a href="#L422">set_margin</a></li>
<li><a href="#L778">set_mark_tags</a></li>
<li><a href="#L556">set_max_boxes</a></li>
<li><a href="#L446">set_max_indent</a></li>
<li><a href="#L774">set_print_tags</a></li>
<li><a href="#L616">set_tab</a></li>
<li><a href="#L768">set_tags</a></li>
<li><a href="#L1355">sprintf</a></li>
<li><a href="#L980">std_formatter</a></li>
<li><a href="#L1011">stdbuf</a></li>
<li><a href="#L1019">str_formatter</a></li>
<li><a href="#L967">synchronized_formatter_of_out_channel</a></li>
<li><a href="#L535">update_geometry</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L123">formatter</a></li>
<li><a href="#L835">formatter_out_functions</a></li>
<li><a href="#L896">formatter_stag_functions</a></li>
<li><a href="#L496">geometry</a></li>
<li><a href="#L658">stag</a></li>
<li><a href="#L737">stag</a></li>
<li><a href="#L1111">symbolic_output_buffer</a></li>
<li><a href="#L1098">symbolic_output_item</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Pierre Weis, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1996 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Pretty-printing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If you are new to this module, see the {{!examples} examples} below.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This module implements <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-printing facility to <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> values<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; within {{!boxes}'pretty-printing boxes'} and {{!tags}'semantic tags'}<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; combined with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of {{!fpp}<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>-like functions}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits lines at specified {{!breaks}break hints},<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and indents lines according to the box structure.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Similarly, {{!tags}semantic tags} can be used to decouple text<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; presentation from its <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This pretty-printing facility is implemented as an overlay on <a href="stack.ml.html#L43" title="ocaml/stdlib/stack.ml:43">top</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; abstract {{!section:<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>}formatters} which provide basic <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; functions.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Some formatters are predefined, notably:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - {!<a href="#L980" title="ocaml/stdlib/format.mli:980">std_formatter</a>} outputs to {{!Stdlib.<a href="out_channel.mli.html#L41" title="ocaml/stdlib/out_channel.mli:41">stdout</a>}<a href="out_channel.mli.html#L41" title="ocaml/stdlib/out_channel.mli:41">stdout</a>}<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - {!<a href="#L992" title="ocaml/stdlib/format.mli:992">err_formatter</a>} outputs to {{!Stdlib.<a href="out_channel.mli.html#L44" title="ocaml/stdlib/out_channel.mli:44">stderr</a>}<a href="out_channel.mli.html#L44" title="ocaml/stdlib/out_channel.mli:44">stderr</a>}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Most functions in the {!Format} module come in two variants: <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> short version<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that operates on the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> standard <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> as obtained using<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!<a href="#L986" title="ocaml/stdlib/format.mli:986">get_std_formatter</a>} and the generic version prefixed by [pp_] that takes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> as its first argument. For the version that operates on the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> standard <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>, the call to {!<a href="#L986" title="ocaml/stdlib/format.mli:986">get_std_formatter</a>} is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; delayed until the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> argument is received.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; More formatters can be created with {!<a href="#L962" title="ocaml/stdlib/format.mli:962">formatter_of_out_channel</a>},<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!<a href="#L1004" title="ocaml/stdlib/format.mli:1004">formatter_of_buffer</a>}, {!<a href="#L1156" title="ocaml/stdlib/format.mli:1156">formatter_of_symbolic_output_buffer</a>} or using<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {{!section:<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>}custom formatters}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; {b Warning}: Since {{!section:<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>}formatters} contain<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; mutable <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>, it is not thread-safe to use the same <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> on multiple<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; domains in parallel without synchronization.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If multiple domains write to the same <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel using the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; predefined formatters (as obtained by {!<a href="#L986" title="ocaml/stdlib/format.mli:986">get_std_formatter</a>} or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!<a href="#L998" title="ocaml/stdlib/format.mli:998">get_err_formatter</a>}), the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> from the domains will be interleaved with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; each other at points where the formatters are flushed, such as with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>}. This synchronization is not performed by formatters obtained<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; from {!<a href="#L962" title="ocaml/stdlib/format.mli:962">formatter_of_out_channel</a>} (on the standard out channels or others).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Introduction}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; You may consider this module as providing an <a href="filename.mli.html#L74" title="ocaml/stdlib/filename.mli:74">extension</a> to the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>] facility to provide automatic line splitting. The addition of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; pretty-printing annotations to your regular [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>] <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings gives<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; you fancy indentation and line breaks.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Pretty-printing annotations are described below in the documentation of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the function {!Format.<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; You may also use the explicit pretty-printing box management and printing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; functions provided by this module. This style is more basic but more<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; verbose than the concise [<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>] <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; For instance, the sequence<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L156" title="ocaml/stdlib/format.mli:156">open_box</a> 0; <a href="stdlib.ml.html#L487" title="ocaml/stdlib/stdlib.ml:487">print_string</a> &quot;<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> =&quot;; <a href="#L288" title="ocaml/stdlib/format.mli:288">print_space</a> ();<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="stdlib.ml.html#L489" title="ocaml/stdlib/stdlib.ml:489">print_int</a> 1; <a href="#L180" title="ocaml/stdlib/format.mli:180">close_box</a> (); <a href="stdlib.ml.html#L493" title="ocaml/stdlib/stdlib.ml:493">print_newline</a> ()]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that prints [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 1] within <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-printing box, can be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; abbreviated as [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@[%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>@ %<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>@]@.&quot; &quot;<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> =&quot; 1], or even shorter<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@[<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> =@ %<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>@]@.&quot; 1].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Rule of thumb for casual users of this library:<br/></li>
<li></span><span class="Comment"> - use simple pretty-printing boxes (as obtained by [<a href="#L156" title="ocaml/stdlib/format.mli:156">open_box</a> 0]);<br/></li>
<li></span><span class="Comment"> - use simple break hints as obtained by [<a href="#L297" title="ocaml/stdlib/format.mli:297">print_cut</a> ()] that outputs <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; simple break hint, or by [<a href="#L288" title="ocaml/stdlib/format.mli:288">print_space</a> ()] that outputs <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> space<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; indicating <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> break hint;<br/></li>
<li></span><span class="Comment"> - <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-printing box is open, display its material with basic<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; printing functions (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. g. [<a href="stdlib.ml.html#L489" title="ocaml/stdlib/stdlib.ml:489">print_int</a>] and [<a href="stdlib.ml.html#L487" title="ocaml/stdlib/stdlib.ml:487">print_string</a>]);<br/></li>
<li></span><span class="Comment"> - when the material for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-printing box has been printed, call<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L180" title="ocaml/stdlib/format.mli:180">close_box</a> ()] to <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> the box;<br/></li>
<li></span><span class="Comment"> - at the end of pretty-printing, <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> to display all<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the remaining material, <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. evaluate [<a href="stdlib.ml.html#L493" title="ocaml/stdlib/stdlib.ml:493">print_newline</a> ()].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The behavior of pretty-printing commands is unspecified<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if there is no open pretty-printing box. Each box opened by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the [open_] functions below must be closed using [<a href="#L180" title="ocaml/stdlib/format.mli:180">close_box</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for proper <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a>. Otherwise, <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> of the material printed in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; boxes may not be <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>, or may be formatted incorrectly.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; In case of interactive use, each phrase is executed in the initial <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of the standard pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>: after each phrase execution, the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; interactive system closes all open pretty-printing boxes, flushes all<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; pending text, and resets the standard pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Warning: mixing calls to pretty-printing functions of this module with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; calls to {!Stdlib} low level <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions is <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> prone.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The pretty-printing functions <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> material that is delayed in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> queue and stacks in order to compute proper line<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; splitting. In contrast, basic I/O <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions write directly in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; their <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device. As <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> consequence, the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> basic I/O function<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; may appear <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-printing function that has been<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; called <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a>. For instance,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Stdlib.<a href="stdlib.ml.html#L487" title="ocaml/stdlib/stdlib.ml:487">print_string</a> &quot;&lt;&quot;;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Format.<a href="stdlib.ml.html#L487" title="ocaml/stdlib/stdlib.ml:487">print_string</a> &quot;PRETTY&quot;;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Stdlib.<a href="stdlib.ml.html#L487" title="ocaml/stdlib/stdlib.ml:487">print_string</a> &quot;&gt;&quot;;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Format.<a href="stdlib.ml.html#L487" title="ocaml/stdlib/stdlib.ml:487">print_string</a> &quot;TEXT&quot;;<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; leads to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> [&lt;&gt;PRETTYTEXT].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* A tutorial to the Format module is provided at {!Format_tutorial}. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Formatters} *)<br/></li>
<li></span><br/></li>
<li><a id="L123">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">formatter</span><br/></li>
<li></span><span class="Comment">(** Abstract <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> corresponding to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> (also called <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>) and all its machinery. See also {!section:<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>}. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:boxes Pretty-printing boxes} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The pretty-printing <a href="lexing.mli.html#L211" title="ocaml/stdlib/lexing.mli:211">engine</a> uses the concepts of pretty-printing box and<br/></li>
<li></span><span class="Comment">&nbsp; break hint to drive indentation and line splitting behavior of the<br/></li>
<li></span><span class="Comment">&nbsp; pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Each different pretty-printing box <a href="bigarray.mli.html#L106" title="ocaml/stdlib/bigarray.mli:106">kind</a> introduces <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> specific line splitting<br/></li>
<li></span><span class="Comment">&nbsp; policy:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; - within an {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> horizontal} box, break hints never <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line (but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; line may be <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> box nested deeper),<br/></li>
<li></span><span class="Comment">&nbsp; - within <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> vertical} box, break hints always <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line,<br/></li>
<li></span><span class="Comment">&nbsp; - within an {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> horizontal/vertical} box, if the box fits on the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then break hints never <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line, otherwise break hint always <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the line,<br/></li>
<li></span><span class="Comment">&nbsp; - within <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> compacting} box, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> break hint never splits the line,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; unless there is no more room on the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Note that line splitting policy is box specific: the policy of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> box does<br/></li>
<li></span><span class="Comment">&nbsp; not rule the policy of inner boxes. For instance, if <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> vertical box is<br/></li>
<li></span><span class="Comment">&nbsp; nested in an horizontal box, all break hints within the vertical box will<br/></li>
<li></span><span class="Comment">&nbsp; <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Moreover, opening <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> box after the {{!maxindent}maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a>}<br/></li>
<li></span><span class="Comment">&nbsp; splits the line whether or not the box would end up fitting on the line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L155">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_open_box</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L156">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_box</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L155" title="ocaml/stdlib/format.mli:155">pp_open_box</a> ppf d] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new compacting pretty-printing box with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> [d] in the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> [ppf].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Within this box, the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> prints as much as possible material on<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; every line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; A break hint splits the line if there is no more room on the line to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> the remainder of the box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Within this box, the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> emphasizes the box structure:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> structural box does not fit fully on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> simple line, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> break<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; hint also splits the line if the splitting ``moves to the <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a>''<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. the new line gets an indentation smaller than the <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; line).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This box is the general purpose pretty-printing box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits the line in the box, <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> [d] is added to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> indentation.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L179">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_close_box</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L180">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_box</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Closes the most recently open pretty-printing box. *)<br/></li>
<li></span><br/></li>
<li><a id="L183">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_open_hbox</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L184">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_hbox</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L183" title="ocaml/stdlib/format.mli:183">pp_open_hbox</a> ppf ()] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new 'horizontal' pretty-printing box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This box prints material on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Break hints in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> horizontal box never <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line.<br/></li>
<li></span><span class="Comment">&nbsp; (Line splitting may still occur inside boxes nested deeper).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L193">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_open_vbox</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_vbox</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L193" title="ocaml/stdlib/format.mli:193">pp_open_vbox</a> ppf d] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new 'vertical' pretty-printing box<br/></li>
<li></span><span class="Comment">&nbsp; with <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> [d].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This box prints material on as many lines as break hints in the box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Every break hint in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> vertical box splits the line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits the line in the box, [d] is added to the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> indentation.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L206">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_open_hvbox</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L207">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_hvbox</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L206" title="ocaml/stdlib/format.mli:206">pp_open_hvbox</a> ppf d] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new 'horizontal/vertical' pretty-printing box<br/></li>
<li></span><span class="Comment">&nbsp; with <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> [d].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This box behaves as an horizontal box if it fits on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single line,<br/></li>
<li></span><span class="Comment">&nbsp; otherwise it behaves as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> vertical box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits the line in the box, [d] is added to the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> indentation.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L218">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_open_hovbox</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L219">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_hovbox</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L218" title="ocaml/stdlib/format.mli:218">pp_open_hovbox</a> ppf d] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new 'horizontal-or-vertical'<br/></li>
<li></span><span class="Comment">&nbsp; pretty-printing box with <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> [d].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This box prints material as much as possible on every line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; A break hint splits the line if there is no more room on the line to<br/></li>
<li></span><span class="Comment">&nbsp; <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> the remainder of the box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits the line in the box, [d] is added to the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> indentation.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Formatting functions} *)<br/></li>
<li></span><br/></li>
<li><a id="L234">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_string</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L235">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_string</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L234" title="ocaml/stdlib/format.mli:234">pp_print_string</a> ppf <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] prints [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] in the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box. *)<br/></li>
<li></span><br/></li>
<li><a id="L238">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_bytes</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L239">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_bytes</span></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L238" title="ocaml/stdlib/format.mli:238">pp_print_bytes</a> ppf b] prints [b] in the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L244">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_as</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L245">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_as</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L244" title="ocaml/stdlib/format.mli:244">pp_print_as</a> ppf <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] prints [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] in the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box.<br/></li>
<li></span><span class="Comment">&nbsp; The pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> formats [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] as if it were of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L250">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_int</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L251">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_int</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print an integer in the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box. *)<br/></li>
<li></span><br/></li>
<li><a id="L254">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_float</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L255">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_float</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating point number in the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box. *)<br/></li>
<li></span><br/></li>
<li><a id="L258">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_char</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L259">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_char</span></span> : <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> character in the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box. *)<br/></li>
<li></span><br/></li>
<li><a id="L262">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_bool</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L263">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_bool</span></span> : <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> boolean in the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:breaks Break hints} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** A 'break hint' tells the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> space or <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the<br/></li>
<li></span><span class="Comment">&nbsp; line whichever way is more appropriate to the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box<br/></li>
<li></span><span class="Comment">&nbsp; splitting rules.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Break hints are used to separate printing items and are mandatory to let<br/></li>
<li></span><span class="Comment">&nbsp; the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> correctly <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> lines and <a href="camlinternalFormat.ml.html#L1992" title="ocaml/stdlib/camlinternalFormat.ml:1992">indent</a> items.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Simple break hints are:<br/></li>
<li></span><span class="Comment">&nbsp; - the 'space': <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> space or <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line if appropriate,<br/></li>
<li></span><span class="Comment">&nbsp; - the 'cut': <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line if appropriate.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Note: the notions of space and line splitting are abstract for the<br/></li>
<li></span><span class="Comment">&nbsp; pretty-printing <a href="lexing.mli.html#L211" title="ocaml/stdlib/lexing.mli:211">engine</a>, since those notions can be completely redefined<br/></li>
<li></span><span class="Comment">&nbsp; by the programmer.<br/></li>
<li></span><span class="Comment">&nbsp; However, in the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> default setting, ``<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> space'' simply<br/></li>
<li></span><span class="Comment">&nbsp; means printing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> space character (ASCII code 32) and ``<a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line''<br/></li>
<li></span><span class="Comment">&nbsp; means printing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline character (ASCII code 10).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L287">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_space</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L288">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_space</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L287" title="ocaml/stdlib/format.mli:287">pp_print_space</a> ppf ()] emits <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'space' break hint:<br/></li>
<li></span><span class="Comment">&nbsp; the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> may <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line at this point,<br/></li>
<li></span><span class="Comment">&nbsp; otherwise it prints <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; [<a href="#L287" title="ocaml/stdlib/format.mli:287">pp_print_space</a> ppf ()] is equivalent to [<a href="#L305" title="ocaml/stdlib/format.mli:305">pp_print_break</a> ppf 1 0].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L296">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_cut</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_cut</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L296" title="ocaml/stdlib/format.mli:296">pp_print_cut</a> ppf ()] emits <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'cut' break hint:<br/></li>
<li></span><span class="Comment">&nbsp; the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> may <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line at this point,<br/></li>
<li></span><span class="Comment">&nbsp; otherwise it prints nothing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; [<a href="#L296" title="ocaml/stdlib/format.mli:296">pp_print_cut</a> ppf ()] is equivalent to [<a href="#L305" title="ocaml/stdlib/format.mli:305">pp_print_break</a> ppf 0 0].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L305">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_break</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L306">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_break</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L305" title="ocaml/stdlib/format.mli:305">pp_print_break</a> ppf nspaces <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a>] emits <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'full' break hint:<br/></li>
<li></span><span class="Comment">&nbsp; the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> may <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line at this point,<br/></li>
<li></span><span class="Comment">&nbsp; otherwise it prints [nspaces] spaces.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits the line, [<a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a>] is added to<br/></li>
<li></span><span class="Comment">&nbsp; the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> indentation.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L315">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_custom_break</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">fits</span>:<span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">breaks</span>:<span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">*</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L315" title="ocaml/stdlib/format.mli:315">pp_print_custom_break</a> ppf ~fits:(<a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>, <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>, <a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>) ~breaks:(s3, m, s4)] emits <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; custom break hint: the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> may <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line at this point.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If it does not <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line, then the [<a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>] is emitted, then [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] spaces,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; then [<a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If it splits the line, then it emits the [s3] <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>, then an <a href="camlinternalFormat.ml.html#L1992" title="ocaml/stdlib/camlinternalFormat.ml:1992">indent</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (according to the box rules), then an <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> of [m] spaces, then the [s4]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; While [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] and [m] are handled by [<a href="format.ml.html#L202" title="ocaml/stdlib/format.ml:202">formatter_out_functions</a>.out_indent], the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; strings will be handled by [<a href="format.ml.html#L202" title="ocaml/stdlib/format.ml:202">formatter_out_functions</a>.out_string]. This allows<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> custom <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> that handles indentation distinctly, for example,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; outputs [&lt;br/&gt;] tags or [&amp;nbsp;] entities.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The custom break is useful if you want to change which visible<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (non-whitespace) characters are printed in case of break or no break. For<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; example, when printing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list [ [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>; b; <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] ], you might want to <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; trailing semicolon when it is printed vertically:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment">[<br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>;<br/></li>
<li></span><span class="Comment">&nbsp; b;<br/></li>
<li></span><span class="Comment">&nbsp; <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>;<br/></li>
<li></span><span class="Comment">]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; You can do this as follows:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment"><a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@[&lt;<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> 0&gt;[@;&lt;0 2&gt;@[&lt;<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> 0&gt;<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>;@,b;@,<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>@]%<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>]@]@\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>&quot;<br/></li>
<li></span><span class="Comment">&nbsp; (<a href="#L315" title="ocaml/stdlib/format.mli:315">pp_print_custom_break</a> ~fits:(&quot;&quot;, 0, &quot;&quot;) ~breaks:(&quot;;&quot;, 0, &quot;&quot;))<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L357">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_force_newline</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L358">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">force_newline</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Force <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new line in the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-printing box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> must <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line at this point,<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Not the normal way of pretty-printing, since imperative line splitting may<br/></li>
<li></span><span class="Comment">&nbsp; interfere with <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> line counters and box <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> calculation.<br/></li>
<li></span><span class="Comment">&nbsp; Using break hints within an enclosing vertical box is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> better<br/></li>
<li></span><span class="Comment">&nbsp; alternative.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L369">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_if_newline</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L370">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_if_newline</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Execute the next <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> command if the preceding line<br/></li>
<li></span><span class="Comment">&nbsp; has just been <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a>. Otherwise, ignore the next <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a><br/></li>
<li></span><span class="Comment">&nbsp; command.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Pretty-printing termination} *)<br/></li>
<li></span><br/></li>
<li><a id="L378">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_flush</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L379">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_flush</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** End of pretty-printing: resets the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> to initial <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; All open pretty-printing boxes are closed, all pending text is printed.<br/></li>
<li></span><span class="Comment">&nbsp; In addition, the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> low level <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device is flushed to<br/></li>
<li></span><span class="Comment">&nbsp; <a href="in_channel.ml.html#L108" title="ocaml/stdlib/in_channel.ml:108">ensure</a> that all pending text is really displayed.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Note: never use [<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>] in the normal course of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-printing<br/></li>
<li></span><span class="Comment">&nbsp; routine, since the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> uses <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> complex buffering machinery to<br/></li>
<li></span><span class="Comment">&nbsp; properly <a href="camlinternalFormat.ml.html#L1992" title="ocaml/stdlib/camlinternalFormat.ml:1992">indent</a> the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>; manually flushing those buffers at random<br/></li>
<li></span><span class="Comment">&nbsp; would conflict with the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> strategy and <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> to poor<br/></li>
<li></span><span class="Comment">&nbsp; rendering.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Only consider using [<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>] when displaying all pending material is<br/></li>
<li></span><span class="Comment">&nbsp; mandatory (for instance in case of interactive use when you want the user<br/></li>
<li></span><span class="Comment">&nbsp; to read <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> text) and when resetting the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a> will not<br/></li>
<li></span><span class="Comment">&nbsp; disturb further pretty-printing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Warning: If the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device of the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> is an <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel,<br/></li>
<li></span><span class="Comment">&nbsp; repeated calls to [<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>] means repeated calls to {!Stdlib.<a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>}<br/></li>
<li></span><span class="Comment">&nbsp; to <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> the out channel; these explicit <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> calls could foil the<br/></li>
<li></span><span class="Comment">&nbsp; buffering strategy of <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channels and could dramatically impact<br/></li>
<li></span><span class="Comment">&nbsp; efficiency.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L404">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_newline</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L405">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_newline</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** End of pretty-printing: resets the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> to initial <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; All open pretty-printing boxes are closed, all pending text is printed.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Equivalent to {!<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>} with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new line emitted on the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a><br/></li>
<li></span><span class="Comment">&nbsp; low-level <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device immediately <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> the device is flushed.<br/></li>
<li></span><span class="Comment">&nbsp; See corresponding words of caution for {!<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Note: this is not the normal way to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new line;<br/></li>
<li></span><span class="Comment">&nbsp; the preferred method is using break hints within <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> vertical pretty-printing<br/></li>
<li></span><span class="Comment">&nbsp; box.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Margin} *)<br/></li>
<li></span><br/></li>
<li><a id="L421">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_margin</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L422">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_margin</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L421" title="ocaml/stdlib/format.mli:421">pp_set_margin</a> ppf d] sets the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> margin to [d] (in characters):<br/></li>
<li></span><span class="Comment">&nbsp; the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits lines that overflow the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> margin according to<br/></li>
<li></span><span class="Comment">&nbsp; the break hints given.<br/></li>
<li></span><span class="Comment">&nbsp; Setting the margin to [d] means that the <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> <a href="lexing.mli.html#L211" title="ocaml/stdlib/lexing.mli:211">engine</a> aims at<br/></li>
<li></span><span class="Comment">&nbsp; printing at most [d-1] characters per line.<br/></li>
<li></span><span class="Comment">&nbsp; Nothing happens if [d] is smaller than 2.<br/></li>
<li></span><span class="Comment">&nbsp; If [d] is too large, the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> margin is <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to the maximum<br/></li>
<li></span><span class="Comment">&nbsp; admissible value (which is greater than [10 ^ 9]).<br/></li>
<li></span><span class="Comment">&nbsp; If [d] is less than the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a>, the<br/></li>
<li></span><span class="Comment">&nbsp; maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> is decreased while trying to preserve<br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> minimal ratio [max_indent/margin&gt;=50%] and if possible<br/></li>
<li></span><span class="Comment">&nbsp; the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> difference [margin - max_indent].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; See also {!<a href="#L503" title="ocaml/stdlib/format.mli:503">pp_set_geometry</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L439">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_margin</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li><a id="L440">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_margin</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Returns the <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> of the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> margin. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:maxindent Maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a>} *)<br/></li>
<li></span><br/></li>
<li><a id="L445">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_max_indent</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L446">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_max_indent</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L445" title="ocaml/stdlib/format.mli:445">pp_set_max_indent</a> ppf d] sets the maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> of lines<br/></li>
<li></span><span class="Comment">&nbsp; to [d] (in characters):<br/></li>
<li></span><span class="Comment">&nbsp; <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> this <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> is reached, new pretty-printing boxes are rejected to the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a>, unless the enclosing box fully fits on the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> line.<br/></li>
<li></span><span class="Comment">&nbsp; As an illustration,<br/></li>
<li></span><span class="Comment">&nbsp; {[ <a href="#L422" title="ocaml/stdlib/format.mli:422">set_margin</a> 10; <a href="#L446" title="ocaml/stdlib/format.mli:446">set_max_indent</a> 5; <a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@[123456@[7@]89A@]@.&quot; ]}<br/></li>
<li></span><span class="Comment">&nbsp; yields<br/></li>
<li></span><span class="Comment">&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; 123456<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; 789A<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><span class="Comment">&nbsp; because the nested box [&quot;@[7@]&quot;] is opened after the maximum indentation<br/></li>
<li></span><span class="Comment">&nbsp; <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> ([7&gt;5]) and its parent box does not fit on the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> line.<br/></li>
<li></span><span class="Comment">&nbsp; Either decreasing the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the parent box to <a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> it fit on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> line:<br/></li>
<li></span><span class="Comment">&nbsp; {[ <a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@[123456@[7@]89@]@.&quot; ]}<br/></li>
<li></span><span class="Comment">&nbsp; or opening an intermediary box <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> the maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> which<br/></li>
<li></span><span class="Comment">&nbsp; fits on the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> line<br/></li>
<li></span><span class="Comment">&nbsp; {[ <a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@[123@[456@[7@]89@]A@]@.&quot; ]}<br/></li>
<li></span><span class="Comment">&nbsp; avoids the rejection to the <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> of the inner boxes and <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> respectively<br/></li>
<li></span><span class="Comment">&nbsp; [&quot;123456789&quot;] and [&quot;123456789A&quot;] .<br/></li>
<li></span><span class="Comment">&nbsp; Note also that vertical boxes never fit on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> line whereas horizontal boxes<br/></li>
<li></span><span class="Comment">&nbsp; always fully fit on the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> line.<br/></li>
<li></span><span class="Comment">&nbsp; Opening <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> box may <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> line whereas the <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a> may have fit.<br/></li>
<li></span><span class="Comment">&nbsp; If this behavior is problematic, it can be curtailed by setting the maximum<br/></li>
<li></span><span class="Comment">&nbsp; indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> to [margin - 1]. Note that setting the maximum indentation<br/></li>
<li></span><span class="Comment">&nbsp; <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> to [margin] is invalid.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Nothing happens if [d] is smaller than 2.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If [d] is too large, the <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> is <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to the maximum<br/></li>
<li></span><span class="Comment">&nbsp; admissible value (which is greater than [10 ^ 9]).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If [d] is greater or <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> than the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> margin, it is <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>,<br/></li>
<li></span><span class="Comment">&nbsp; and the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> is kept.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; See also {!<a href="#L503" title="ocaml/stdlib/format.mli:503">pp_set_geometry</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L485">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_max_indent</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li><a id="L486">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_max_indent</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Return the maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> (in characters). *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Geometry }<br/></li>
<li></span><br/></li>
<li><span class="Comment">Geometric functions can be used to manipulate simultaneously the<br/></li>
<li></span><span class="Comment">coupled variables, margin and maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L496">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">geometry</span></span> <span class="Statement">=</span> <span class="Statement">{</span> <span class="ocamlLCIdentifier">max_indent</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;</span> <span class="ocamlLCIdentifier">margin</span>: <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">}<br/></li>
<li></span><span class="Comment">(** @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L499">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">check_geometry</span></span>: <span class="ocamlLCIdentifier"><a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Check if the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> <a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a> is valid: [1 &lt; max_indent &lt; margin]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L503">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_geometry</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">max_indent</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">margin</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L504">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_geometry</span></span> : <span class="ocamlLCIdentifier">max_indent</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">margin</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L505">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_safe_set_geometry</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">max_indent</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">margin</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L506">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">safe_set_geometry</span></span> : <span class="ocamlLCIdentifier">max_indent</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier">margin</span>:<span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(**<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L503" title="ocaml/stdlib/format.mli:503">pp_set_geometry</a> ppf ~max_indent ~margin] sets both the margin<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a> for [ppf].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When [1 &lt; max_indent &lt; margin],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L503" title="ocaml/stdlib/format.mli:503">pp_set_geometry</a> ppf ~max_indent ~margin]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L421" title="ocaml/stdlib/format.mli:421">pp_set_margin</a> ppf margin; <a href="#L445" title="ocaml/stdlib/format.mli:445">pp_set_max_indent</a> ppf max_indent];<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and avoids the subtly incorrect<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L445" title="ocaml/stdlib/format.mli:445">pp_set_max_indent</a> ppf max_indent; <a href="#L421" title="ocaml/stdlib/format.mli:421">pp_set_margin</a> ppf margin];<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Outside of this domain, [<a href="#L503" title="ocaml/stdlib/format.mli:503">pp_set_geometry</a>] raises an invalid argument<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; exception whereas [<a href="#L505" title="ocaml/stdlib/format.mli:505">pp_safe_set_geometry</a>] does nothing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L534" title="ocaml/stdlib/format.mli:534">pp_update_geometry</a> ppf (fun geo -&gt; { geo with ... })] lets you<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a> in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> way that is robust to <a href="filename.mli.html#L74" title="ocaml/stdlib/filename.mli:74">extension</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of the [<a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a>] record with new <a href="printexc.ml.html#L39" title="ocaml/stdlib/printexc.ml:39">fields</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Raises an invalid argument exception if the returned <a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; does not satisfy {!<a href="#L499" title="ocaml/stdlib/format.mli:499">check_geometry</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.11<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li><a id="L534">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_update_geometry</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L535">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">update_geometry</span></span> : <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><br/></li>
<li><a id="L537">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_geometry</span></span>: <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a><br/></li>
<li><a id="L538">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_geometry</span></span>: <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a> of the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">(** {1 Maximum <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> depth} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The maximum <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> depth is the maximum number of pretty-printing<br/></li>
<li></span><span class="Comment">&nbsp; boxes simultaneously open.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Material inside boxes nested deeper is printed as an ellipsis (more<br/></li>
<li></span><span class="Comment">&nbsp; precisely as the text returned by {!<a href="#L653" title="ocaml/stdlib/format.mli:653">get_ellipsis_text</a>} [()]).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L555">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_max_boxes</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L556">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_max_boxes</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L555" title="ocaml/stdlib/format.mli:555">pp_set_max_boxes</a> ppf <a href="int32.ml.html#L90" title="ocaml/stdlib/int32.ml:90">max</a>] sets the maximum number of pretty-printing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; boxes simultaneously open.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Material inside boxes nested deeper is printed as an ellipsis (more<br/></li>
<li></span><span class="Comment">&nbsp; precisely as the text returned by {!<a href="#L653" title="ocaml/stdlib/format.mli:653">get_ellipsis_text</a>} [()]).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Nothing happens if [<a href="int32.ml.html#L90" title="ocaml/stdlib/int32.ml:90">max</a>] is smaller than 2.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L566">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_max_boxes</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li><a id="L567">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_max_boxes</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Returns the maximum number of pretty-printing boxes allowed <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a><br/></li>
<li></span><span class="Comment">&nbsp; ellipsis.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L572">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_over_max_boxes</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li><a id="L573">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">over_max_boxes</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Tests if the maximum number of pretty-printing boxes allowed have already<br/></li>
<li></span><span class="Comment">&nbsp; been opened.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Tabulation boxes} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; A {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> tabulation box} prints material on lines divided into cells of fixed<br/></li>
<li></span><span class="Comment">&nbsp; <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>. A tabulation box provides <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> simple way to display vertical columns<br/></li>
<li></span><span class="Comment">&nbsp; of <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> adjusted text.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This box features command [<a href="#L616" title="ocaml/stdlib/format.mli:616">set_tab</a>] to define <a href="queue.ml.html#L19" title="ocaml/stdlib/queue.ml:19">cell</a> boundaries, and command<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="#L620" title="ocaml/stdlib/format.mli:620">print_tab</a>] to move from <a href="queue.ml.html#L19" title="ocaml/stdlib/queue.ml:19">cell</a> to <a href="queue.ml.html#L19" title="ocaml/stdlib/queue.ml:19">cell</a> and <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line when there is no<br/></li>
<li></span><span class="Comment">&nbsp; more cells to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> on the line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Note: printing within tabulation box is line directed, so arbitrary line<br/></li>
<li></span><span class="Comment">&nbsp; splitting inside <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> tabulation box leads to poor rendering. Yet, controlled<br/></li>
<li></span><span class="Comment">&nbsp; use of tabulation boxes allows simple printing of columns within<br/></li>
<li></span><span class="Comment">&nbsp; module {!Format}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L596">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_open_tbox</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L597">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_tbox</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L597" title="ocaml/stdlib/format.mli:597">open_tbox</a> ()] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new tabulation box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This box prints lines separated into cells of fixed <a href="scanf.ml.html#L834" title="ocaml/stdlib/scanf.ml:834">width</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Inside <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> tabulation box, special {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> tabulation markers} defines points of<br/></li>
<li></span><span class="Comment">&nbsp; interest on the line (for instance to delimit <a href="queue.ml.html#L19" title="ocaml/stdlib/queue.ml:19">cell</a> boundaries).<br/></li>
<li></span><span class="Comment">&nbsp; Function {!Format.<a href="#L616" title="ocaml/stdlib/format.mli:616">set_tab</a>} sets <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> at insertion point.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; A tabulation box features specific {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> tabulation breaks} to move to next<br/></li>
<li></span><span class="Comment">&nbsp; tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> or <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line. Function {!Format.<a href="#L629" title="ocaml/stdlib/format.mli:629">print_tbreak</a>} prints<br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> tabulation break.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L611">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_close_tbox</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L612">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_tbox</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Closes the most recently opened tabulation box. *)<br/></li>
<li></span><br/></li>
<li><a id="L615">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_tab</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L616">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_tab</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Sets <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> at <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> insertion point. *)<br/></li>
<li></span><br/></li>
<li><a id="L619">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_tab</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L620">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_tab</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L620" title="ocaml/stdlib/format.mli:620">print_tab</a> ()] emits <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'next' tabulation break hint: if not already <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> on<br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a>, the insertion point moves to the first tabulation<br/></li>
<li></span><span class="Comment">&nbsp; <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> on the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>, or the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits the line and insertion<br/></li>
<li></span><span class="Comment">&nbsp; point moves to the leftmost tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; It is equivalent to [<a href="#L629" title="ocaml/stdlib/format.mli:629">print_tbreak</a> 0 0]. *)<br/></li>
<li></span><br/></li>
<li><a id="L628">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_tbreak</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L629">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_tbreak</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L629" title="ocaml/stdlib/format.mli:629">print_tbreak</a> nspaces <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a>] emits <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'full' tabulation break hint.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If not already <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a>, the insertion point moves to the<br/></li>
<li></span><span class="Comment">&nbsp; first tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> on the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> and the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> prints<br/></li>
<li></span><span class="Comment">&nbsp; [nspaces] spaces.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If there is no next tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> on the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>, the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a><br/></li>
<li></span><span class="Comment">&nbsp; splits the line at this point, then insertion point moves to the leftmost<br/></li>
<li></span><span class="Comment">&nbsp; tabulation <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> of the box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits the line, [<a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a>] is added to<br/></li>
<li></span><span class="Comment">&nbsp; the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> indentation.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Ellipsis} *)<br/></li>
<li></span><br/></li>
<li><a id="L646">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_ellipsis_text</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L647">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_ellipsis_text</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Set the text of the ellipsis printed when too many pretty-printing boxes<br/></li>
<li></span><span class="Comment">&nbsp; are open (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single dot, [.], by default).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L652">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_ellipsis_text</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li><a id="L653">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_ellipsis_text</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Return the text of the ellipsis. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:tags Semantic tags} *)<br/></li>
<li></span><br/></li>
<li><a id="L658">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">stag</span></span> <span class="Statement">=</span> ..<br/></li>
<li><span class="Comment">(** {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> Semantic tags} (or simply {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> tags}) are user'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> defined annotations<br/></li>
<li></span><span class="Comment">&nbsp; to associate user'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> specific operations to printed entities.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Common <a href="arg.ml.html#L117" title="ocaml/stdlib/arg.ml:117">usage</a> of semantic tags is text decoration to <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> specific font or<br/></li>
<li></span><span class="Comment">&nbsp; text <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> rendering for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> display device, or marking delimitation of<br/></li>
<li></span><span class="Comment">&nbsp; entities (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. HTML or TeX <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> or terminal escape sequences).<br/></li>
<li></span><span class="Comment">&nbsp; More sophisticated <a href="arg.ml.html#L117" title="ocaml/stdlib/arg.ml:117">usage</a> of semantic tags could handle dynamic<br/></li>
<li></span><span class="Comment">&nbsp; modification of the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> behavior to properly <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> the material<br/></li>
<li></span><span class="Comment">&nbsp; within <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> specific tags.<br/></li>
<li></span><span class="Comment">&nbsp; For instance, we can define an RGB <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> like so:<br/></li>
<li></span><span class="Comment">{[<br/></li>
<li></span><span class="Comment">type <a href="format.ml.html#L86" title="ocaml/stdlib/format.ml:86">stag</a> += RGB of {<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>:<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>;g:<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>;b:<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>}<br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; In order to properly delimit printed entities, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> must be<br/></li>
<li></span><span class="Comment">&nbsp; opened <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> and closed after the entity. Semantic tags must be properly<br/></li>
<li></span><span class="Comment">&nbsp; nested like parentheses using {!<a href="format.ml.html#L539" title="ocaml/stdlib/format.ml:539">pp_open_stag</a>} and {!<a href="#L756" title="ocaml/stdlib/format.mli:756">pp_close_stag</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Tag specific operations occur any time <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> is opened or closed, At each<br/></li>
<li></span><span class="Comment">&nbsp; occurrence, two kinds of operations are performed {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking} and<br/></li>
<li></span><span class="Comment">&nbsp; {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing}:<br/></li>
<li></span><span class="Comment">- The <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking operation is the simpler <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> specific operation: it simply<br/></li>
<li></span><span class="Comment">&nbsp; writes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> specific <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> into the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device of the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>. Tag-marking does not interfere with line-splitting computation.<br/></li>
<li></span><span class="Comment">- The <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing operation is the more involved <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> specific operation: it<br/></li>
<li></span><span class="Comment">&nbsp; can <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> arbitrary material to the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>. Tag-printing is tightly<br/></li>
<li></span><span class="Comment">&nbsp; linked to the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> operations.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Roughly speaking, <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking is commonly used to <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> better rendering of<br/></li>
<li></span><span class="Comment">&nbsp; texts in the rendering device, while <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing allows fine tuning of<br/></li>
<li></span><span class="Comment">&nbsp; printing routines to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> the same entity differently according to the<br/></li>
<li></span><span class="Comment">&nbsp; semantic tags (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> additional material or even omit parts of the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; More precisely: when <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> is opened or closed then both and<br/></li>
<li></span><span class="Comment">&nbsp; successive '<a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing' and '<a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking' operations occur:<br/></li>
<li></span><span class="Comment">&nbsp; - Tag-printing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> means calling the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> specific function<br/></li>
<li></span><span class="Comment">&nbsp; [print_open_stag] (resp. [print_close_stag]) with the <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> of the <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> as<br/></li>
<li></span><span class="Comment">&nbsp; argument: that <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing function can then <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> any regular material<br/></li>
<li></span><span class="Comment">&nbsp; to the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> (so that this material is enqueued as usual in the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> queue for further line splitting computation).<br/></li>
<li></span><span class="Comment">&nbsp; - Tag-marking <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> means calling the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> specific function<br/></li>
<li></span><span class="Comment">&nbsp; [mark_open_stag] (resp. [mark_close_stag]) with the <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> of the <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> as<br/></li>
<li></span><span class="Comment">&nbsp; argument: that <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking function can then <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the '<a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-opening<br/></li>
<li></span><span class="Comment">&nbsp; <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a>' (resp. `<a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-<a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a>') for direct <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> into the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a><br/></li>
<li></span><span class="Comment">&nbsp; device of the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Being written directly into the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device of the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>, semantic<br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> strings are not considered as part of the printing material that<br/></li>
<li></span><span class="Comment">&nbsp; drives line splitting (in other words, the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the strings<br/></li>
<li></span><span class="Comment">&nbsp; corresponding to <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> markers is considered as <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> for line splitting).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Thus, semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> handling is in <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sense transparent to pretty-printing<br/></li>
<li></span><span class="Comment">&nbsp; and does not interfere with usual indentation. Hence, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single<br/></li>
<li></span><span class="Comment">&nbsp; pretty-printing routine can <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> both simple 'verbatim' material or<br/></li>
<li></span><span class="Comment">&nbsp; richer decorated <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> depending on the treatment of tags. By default,<br/></li>
<li></span><span class="Comment">&nbsp; tags are not active, hence the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> is not decorated with <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a><br/></li>
<li></span><span class="Comment">&nbsp; information. Once [<a href="#L768" title="ocaml/stdlib/format.mli:768">set_tags</a>] is <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to [true], the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> <a href="lexing.mli.html#L211" title="ocaml/stdlib/lexing.mli:211">engine</a><br/></li>
<li></span><span class="Comment">&nbsp; honors tags and decorates the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> accordingly.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Default <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking functions behave the HTML way: {{!<a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>}<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> tags} are<br/></li>
<li></span><span class="Comment">&nbsp; enclosed in &quot;&lt;&quot; and &quot;&gt;&quot; while other tags are <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>;<br/></li>
<li></span><span class="Comment">&nbsp; hence, opening <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> for <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [&quot;<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>&quot;] is [&quot;&lt;<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>&gt;&quot;] and <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a><br/></li>
<li></span><span class="Comment">&nbsp; is [&quot;&lt;/<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>&gt;&quot;].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Default <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing functions just do nothing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Tag-marking and <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing functions are user definable and can<br/></li>
<li></span><span class="Comment">&nbsp; be <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> by calling {!<a href="#L914" title="ocaml/stdlib/format.mli:914">set_formatter_stag_functions</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> operations may be <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> on or off with {!<a href="#L768" title="ocaml/stdlib/format.mli:768">set_tags</a>}.<br/></li>
<li></span><span class="Comment">&nbsp; Tag-marking operations may be <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> on or off with {!<a href="#L778" title="ocaml/stdlib/format.mli:778">set_mark_tags</a>}.<br/></li>
<li></span><span class="Comment">&nbsp; Tag-printing operations may be <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> on or off with {!<a href="#L774" title="ocaml/stdlib/format.mli:774">set_print_tags</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">type</span> <span class="ocamlLCIdentifier"><a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a></span> <span class="Statement">=</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li><a id="L737">&#x200c;</a></span><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">stag</span></span> +<span class="Statement">=</span> <span class="Constant">String_tag</span> <span class="Statement">of</span> <span class="ocamlLCIdentifier"><a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a><br/></li>
<li></span><span class="Comment">(** [String_tag <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. String tags can be inserted either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; by explicitly using the constructor [String_tag] or by using the dedicated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> syntax [&quot;@{&lt;<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>&gt; ... @}&quot;].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L745">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_open_stag</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L86" title="ocaml/stdlib/format.ml:86">stag</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L746">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_stag</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L86" title="ocaml/stdlib/format.ml:86">stag</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="format.ml.html#L539" title="ocaml/stdlib/format.ml:539">pp_open_stag</a> ppf <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] opens the semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> named [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The [print_open_stag] <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing function of the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> is called with<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] as argument; then the opening <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> for [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>], as given by<br/></li>
<li></span><span class="Comment">&nbsp; [mark_open_stag <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>], is written into the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device of the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L756">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_close_stag</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L757">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_stag</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L756" title="ocaml/stdlib/format.mli:756">pp_close_stag</a> ppf ()] closes the most recently opened semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a>, as given by [mark_close_stag <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>], is written into the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device of the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>; then the [print_close_stag] <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing<br/></li>
<li></span><span class="Comment">&nbsp; function of the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> is called with [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] as argument.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L767">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_tags</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L768">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_tags</span></span> : <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L767" title="ocaml/stdlib/format.mli:767">pp_set_tags</a> ppf b] turns on or off the treatment of semantic tags<br/></li>
<li></span><span class="Comment">&nbsp; (default is off).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L773">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_print_tags</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L774">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_print_tags</span></span> : <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L773" title="ocaml/stdlib/format.mli:773">pp_set_print_tags</a> ppf b] turns on or off the <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing operations. *)<br/></li>
<li></span><br/></li>
<li><a id="L777">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_mark_tags</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L778">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_mark_tags</span></span> : <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L777" title="ocaml/stdlib/format.mli:777">pp_set_mark_tags</a> ppf b] turns on or off the <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking operations. *)<br/></li>
<li></span><br/></li>
<li><a id="L781">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_print_tags</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li><a id="L782">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_print_tags</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> status of <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing operations. *)<br/></li>
<li></span><br/></li>
<li><a id="L785">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_mark_tags</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li><a id="L786">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_mark_tags</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> status of <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking operations. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Redirecting the standard <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>} *)<br/></li>
<li><a id="L790">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_formatter_out_channel</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="PreProc">Stdlib</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L792">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_formatter_out_channel</span></span> : <span class="PreProc">Stdlib</span>.<span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Redirect the standard pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> to the given channel.<br/></li>
<li></span><span class="Comment">&nbsp; (All the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions of the standard <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> are <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; default <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions printing to the given channel.)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; [<a href="#L792" title="ocaml/stdlib/format.mli:792">set_formatter_out_channel</a>] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; {!<a href="format.ml.html#L909" title="ocaml/stdlib/format.ml:909">pp_set_formatter_out_channel</a>} [<a href="#L980" title="ocaml/stdlib/format.mli:980">std_formatter</a>].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L801">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_formatter_output_functions</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L803">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_formatter_output_functions</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L801" title="ocaml/stdlib/format.mli:801">pp_set_formatter_output_functions</a> ppf out <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>] redirects the<br/></li>
<li></span><span class="Comment">&nbsp; standard pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions to the functions [out] and<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The [out] function performs all the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><span class="Comment">&nbsp; It is called with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>], and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number of<br/></li>
<li></span><span class="Comment">&nbsp; characters [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]; it is supposed to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> characters [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>] to [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> + <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> - 1] of<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The [<a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>] function is called whenever the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> is flushed<br/></li>
<li></span><span class="Comment">&nbsp; (via conversion [%!], or pretty-printing indications [@?] or [@.], or<br/></li>
<li></span><span class="Comment">&nbsp; using low level functions [<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>] or [<a href="stdlib.ml.html#L493" title="ocaml/stdlib/stdlib.ml:493">print_newline</a>]).<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L819">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_formatter_output_functions</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">*</span> <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)<br/></li>
<li><a id="L821">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_formatter_output_functions</span></span> :<br/></li>
<li>&nbsp; <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">*</span> <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)<br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions of the standard pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:meaning Redefining <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The [Format] module is versatile enough to let you completely redefine<br/></li>
<li></span><span class="Comment">&nbsp; the meaning of pretty-printing <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>: you may provide your own functions<br/></li>
<li></span><span class="Comment">&nbsp; to define how to handle indentation, line splitting, and even printing of<br/></li>
<li></span><span class="Comment">&nbsp; all the characters that have to be printed!<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {2 Redefining <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions} *)<br/></li>
<li></span><br/></li>
<li><a id="L835">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">formatter_out_functions</span></span> <span class="Statement">=</span> <span class="Statement">{<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">out_string</span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">out_flush</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">out_newline</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">out_spaces</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">out_indent</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">;</span><span class="Comment">(** @since 4.06 *)<br/></li>
<li></span><span class="Statement">}<br/></li>
<li></span><span class="Comment">(** The <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions specific to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>:<br/></li>
<li></span><span class="Comment">- the [out_string] function performs all the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><span class="Comment">&nbsp; It is called with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="gc.mli.html#L498" title="ocaml/stdlib/gc.mli:498">start</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>], and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number of<br/></li>
<li></span><span class="Comment">&nbsp; characters [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]; it is supposed to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> characters [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>] to [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> + <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> - 1] of<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">- the [out_flush] function flushes the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device.<br/></li>
<li></span><span class="Comment">- [out_newline] is called to open <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new line when the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits<br/></li>
<li></span><span class="Comment">&nbsp; the line.<br/></li>
<li></span><span class="Comment">- the [out_spaces] function outputs spaces when <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> break hint leads to spaces<br/></li>
<li></span><span class="Comment">&nbsp; instead of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> line <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a>. It is called with the number of spaces to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><span class="Comment">- the [out_indent] function performs new line indentation when the<br/></li>
<li></span><span class="Comment">&nbsp; pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> splits the line. It is called with the indentation value of<br/></li>
<li></span><span class="Comment">&nbsp; the new line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; By default:<br/></li>
<li></span><span class="Comment">- <a href="printexc.ml.html#L39" title="ocaml/stdlib/printexc.ml:39">fields</a> [out_string] and [out_flush] are <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device specific;<br/></li>
<li></span><span class="Comment">&nbsp; (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. {!Stdlib.<a href="out_channel.mli.html#L97" title="ocaml/stdlib/out_channel.mli:97">output_string</a>} and {!Stdlib.<a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>} for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Stdlib.<a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a>} device, or [Buffer.<a href="buffer.ml.html#L149" title="ocaml/stdlib/buffer.ml:149">add_substring</a>] and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Stdlib.ignore} for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [Buffer.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device),<br/></li>
<li></span><span class="Comment">- <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> [out_newline] is equivalent to [out_string &quot;\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>&quot; 0 1];<br/></li>
<li></span><span class="Comment">- <a href="printexc.ml.html#L39" title="ocaml/stdlib/printexc.ml:39">fields</a> [out_spaces] and [out_indent] are equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; [out_string (String.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> ' ') 0 <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><span class="Comment">&nbsp; @since 4.01<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L867">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_formatter_out_functions</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L202" title="ocaml/stdlib/format.ml:202">formatter_out_functions</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L869">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_formatter_out_functions</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L202" title="ocaml/stdlib/format.ml:202">formatter_out_functions</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L867" title="ocaml/stdlib/format.mli:867">pp_set_formatter_out_functions</a> ppf out_funs]<br/></li>
<li></span><span class="Comment">&nbsp; Set all the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions of [ppf] to those of<br/></li>
<li></span><span class="Comment">&nbsp; argument [out_funs],<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This way, you can change the meaning of indentation (which can be<br/></li>
<li></span><span class="Comment">&nbsp; something else than just printing space characters) and the meaning of new<br/></li>
<li></span><span class="Comment">&nbsp; lines opening (which can be connected to any other <a href="arg.ml.html#L169" title="ocaml/stdlib/arg.ml:169">action</a> needed by the<br/></li>
<li></span><span class="Comment">&nbsp; application at hand).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Reasonable defaults for functions [out_spaces] and [out_newline] are<br/></li>
<li></span><span class="Comment">&nbsp; respectively [out_funs.out_string (String.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> ' ') 0 <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] and<br/></li>
<li></span><span class="Comment">&nbsp; [out_funs.out_string &quot;\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>&quot; 0 1].<br/></li>
<li></span><span class="Comment">&nbsp; @since 4.01<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L885">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_formatter_out_functions</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L202" title="ocaml/stdlib/format.ml:202">formatter_out_functions</a><br/></li>
<li><a id="L887">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_formatter_out_functions</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L202" title="ocaml/stdlib/format.ml:202">formatter_out_functions</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions of the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>,<br/></li>
<li></span><span class="Comment">&nbsp; including line splitting and indentation functions. Useful to record the<br/></li>
<li></span><span class="Comment">&nbsp; <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> setting and restore it afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; @since 4.01<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:tagsmeaning Redefining semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> operations} *)<br/></li>
<li></span><br/></li>
<li><a id="L896">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">formatter_stag_functions</span></span> <span class="Statement">=</span> <span class="Statement">{<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">mark_open_stag</span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L86" title="ocaml/stdlib/format.ml:86">stag</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">mark_close_stag</span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L86" title="ocaml/stdlib/format.ml:86">stag</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">print_open_stag</span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L86" title="ocaml/stdlib/format.ml:86">stag</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier">print_close_stag</span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L86" title="ocaml/stdlib/format.ml:86">stag</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">;<br/></li>
<li></span><span class="Statement">}<br/></li>
<li></span><span class="Comment">(** The semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> handling functions specific to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>:<br/></li>
<li></span><span class="Comment">&nbsp; [mark] versions are the '<a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking' functions that associate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> in order for the pretty-printing <a href="lexing.mli.html#L211" title="ocaml/stdlib/lexing.mli:211">engine</a> to write<br/></li>
<li></span><span class="Comment">&nbsp; those markers as 0 <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> tokens in the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device of the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>.<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a>] versions are the '<a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing' functions that can perform<br/></li>
<li></span><span class="Comment">&nbsp; regular printing when <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> is closed or opened.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L912">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_set_formatter_stag_functions</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L193" title="ocaml/stdlib/format.ml:193">formatter_stag_functions</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li><a id="L914">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_formatter_stag_functions</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L193" title="ocaml/stdlib/format.ml:193">formatter_stag_functions</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L912" title="ocaml/stdlib/format.mli:912">pp_set_formatter_stag_functions</a> ppf tag_funs] changes the meaning of<br/></li>
<li></span><span class="Comment">&nbsp; opening and <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> operations to use the functions in<br/></li>
<li></span><span class="Comment">&nbsp; [tag_funs] when printing on [ppf].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; When opening <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> with <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>], the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] is passed to the<br/></li>
<li></span><span class="Comment">&nbsp; opening <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking function (the [mark_open_stag] <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; record [tag_funs]), that must <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the opening <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> for<br/></li>
<li></span><span class="Comment">&nbsp; that <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a>. When the next call to [<a href="#L757" title="ocaml/stdlib/format.mli:757">close_stag</a> ()] happens, the semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a><br/></li>
<li></span><span class="Comment">&nbsp; <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> [<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] is sent back to the <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-marking function (the<br/></li>
<li></span><span class="Comment">&nbsp; [mark_close_stag] <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> of record [tag_funs]), that must <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> <a href="format.ml.html#L414" title="ocaml/stdlib/format.ml:414">marker</a> for that <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The [print_] <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> of the record <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>-printing functions that<br/></li>
<li></span><span class="Comment">&nbsp; are called at <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> opening and <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> time, to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> regular material<br/></li>
<li></span><span class="Comment">&nbsp; in the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> queue.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L934">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_get_formatter_stag_functions</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L193" title="ocaml/stdlib/format.ml:193">formatter_stag_functions</a><br/></li>
<li><a id="L936">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_formatter_stag_functions</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L193" title="ocaml/stdlib/format.ml:193">formatter_stag_functions</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> operation functions of the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> Defining formatters}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Defining new formatters permits unrelated <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> of material in<br/></li>
<li></span><span class="Comment">&nbsp; parallel on several <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> devices.<br/></li>
<li></span><span class="Comment">&nbsp; All the parameters of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> are local to the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>:<br/></li>
<li></span><span class="Comment">&nbsp; <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> margin, maximum indentation <a href="weak.ml.html#L119" title="ocaml/stdlib/weak.ml:119">limit</a>, maximum number of pretty-printing<br/></li>
<li></span><span class="Comment">&nbsp; boxes simultaneously open, ellipsis, and so on, are specific to<br/></li>
<li></span><span class="Comment">&nbsp; each <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> and may be fixed independently.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; For instance, given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Buffer.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>} <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [b], {!<a href="#L1004" title="ocaml/stdlib/format.mli:1004">formatter_of_buffer</a>} [b]<br/></li>
<li></span><span class="Comment">&nbsp; returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> using <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [b] as its <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device.<br/></li>
<li></span><span class="Comment">&nbsp; Similarly, given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Stdlib.<a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a>} <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel [oc],<br/></li>
<li></span><span class="Comment">&nbsp; {!<a href="#L962" title="ocaml/stdlib/format.mli:962">formatter_of_out_channel</a>} [oc] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> using<br/></li>
<li></span><span class="Comment">&nbsp; channel [oc] as its <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Alternatively, given [out_funs], <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> complete <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>, then {!<a href="#L1063" title="ocaml/stdlib/format.mli:1063">formatter_of_out_functions</a>} [out_funs] computes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new<br/></li>
<li></span><span class="Comment">&nbsp; <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> using those functions for <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L962">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">formatter_of_out_channel</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L962" title="ocaml/stdlib/format.mli:962">formatter_of_out_channel</a> oc] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> writing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to the corresponding <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel [oc].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L967">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">synchronized_formatter_of_out_channel</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="PreProc">Domain</span>.<span class="PreProc">DLS</span>.<span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="ocamlLCIdentifier">unstable</span><span class="Statement">][</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="Constant">&quot;-unstable&quot;</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [<a href="#L967" title="ocaml/stdlib/format.mli:967">synchronized_formatter_of_out_channel</a> oc] returns the <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; domain-local <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a> that holds the domain-local <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> for writing to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; corresponding <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel [oc].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; When the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> is used with multiple domains, the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; domains will be interleaved with each other at points where the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is flushed, such as with {!<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L980">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">std_formatter</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** The initial domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> standard <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> to write to standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; It is defined as {!<a href="#L962" title="ocaml/stdlib/format.mli:962">formatter_of_out_channel</a>} {!Stdlib.<a href="out_channel.mli.html#L41" title="ocaml/stdlib/out_channel.mli:41">stdout</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L986">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_std_formatter</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L986" title="ocaml/stdlib/format.mli:986">get_std_formatter</a> ()] returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> standard <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to write to standard <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.0<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L992">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">err_formatter</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** The initial domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> to write to standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; It is defined as {!<a href="#L962" title="ocaml/stdlib/format.mli:962">formatter_of_out_channel</a>} {!Stdlib.<a href="out_channel.mli.html#L44" title="ocaml/stdlib/out_channel.mli:44">stderr</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L998">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_err_formatter</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L998" title="ocaml/stdlib/format.mli:998">get_err_formatter</a> ()] returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> used to write<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 5.0<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1004">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">formatter_of_buffer</span></span> : <span class="PreProc">Buffer</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L1004" title="ocaml/stdlib/format.mli:1004">formatter_of_buffer</a> b] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> writing to<br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [b]. At the end of pretty-printing, the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> must be flushed<br/></li>
<li></span><span class="Comment">&nbsp; using {!<a href="#L378" title="ocaml/stdlib/format.mli:378">pp_print_flush</a>} or {!<a href="#L404" title="ocaml/stdlib/format.mli:404">pp_print_newline</a>}, to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> all the<br/></li>
<li></span><span class="Comment">&nbsp; pending material into the <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a>.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1011">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stdbuf</span></span> : <span class="PreProc">Buffer</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** The initial domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> in which [<a href="#L1019" title="ocaml/stdlib/format.mli:1019">str_formatter</a>] writes. *)<br/></li>
<li></span><br/></li>
<li><a id="L1014">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_stdbuf</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="PreProc">Buffer</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L1014" title="ocaml/stdlib/format.mli:1014">get_stdbuf</a> ()] returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> in which the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> writes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.0 *)<br/></li>
<li></span><br/></li>
<li><a id="L1019">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">str_formatter</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** The initial domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> to the {!<a href="#L1011" title="ocaml/stdlib/format.mli:1011">stdbuf</a>} <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; [<a href="#L1019" title="ocaml/stdlib/format.mli:1019">str_formatter</a>] is defined as {!<a href="#L1004" title="ocaml/stdlib/format.mli:1004">formatter_of_buffer</a>} {!<a href="#L1011" title="ocaml/stdlib/format.mli:1011">stdbuf</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1025">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_str_formatter</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domain'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> to the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domains <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.0<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1031">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">flush_str_formatter</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Returns the material printed with [<a href="#L1019" title="ocaml/stdlib/format.mli:1019">str_formatter</a>] of the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> domain,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; flushes the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> and resets the corresponding <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a>.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1036">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">make_formatter</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L1036" title="ocaml/stdlib/format.mli:1036">make_formatter</a> out <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> that outputs with<br/></li>
<li></span><span class="Comment">&nbsp; function [out], and flushes with function [<a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; For instance,<br/></li>
<li></span><span class="Comment">&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="#L1036" title="ocaml/stdlib/format.mli:1036">make_formatter</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (Stdlib.<a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> oc)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (fun () -&gt; Stdlib.<a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> oc)<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><span class="Comment">&nbsp; returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> to the {!Stdlib.<a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a>} [oc].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1050">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">make_synchronized_formatter</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="PreProc">Domain</span>.<span class="PreProc">DLS</span>.<span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="ocamlLCIdentifier">unstable</span><span class="Statement">][</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="Constant">&quot;-unstable&quot;</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [<a href="#L1050" title="ocaml/stdlib/format.mli:1050">make_synchronized_formatter</a> out <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>] returns the <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> to the domain-local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a> that holds the domain-local <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> that outputs with function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [out], and flushes with function [<a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; When the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> is used with multiple domains, the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; domains will be interleaved with each other at points where the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is flushed, such as with {!<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 5.0<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1063">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">formatter_of_out_functions</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L202" title="ocaml/stdlib/format.ml:202">formatter_out_functions</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L1063" title="ocaml/stdlib/format.mli:1063">formatter_of_out_functions</a> out_funs] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> that writes<br/></li>
<li></span><span class="Comment">&nbsp; with the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> functions [out_funs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; See definition of type {!<a href="format.ml.html#L202" title="ocaml/stdlib/format.ml:202">formatter_out_functions</a>} for the meaning of argument<br/></li>
<li></span><span class="Comment">&nbsp; [out_funs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">(** {2:symbolic Symbolic pretty-printing} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**<br/></li>
<li></span><span class="Comment">&nbsp; Symbolic pretty-printing is pretty-printing using <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> symbolic <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>,<br/></li>
<li></span><span class="Comment">&nbsp; <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> that outputs symbolic pretty-printing items.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; When using <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> symbolic <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>, all regular pretty-printing activities<br/></li>
<li></span><span class="Comment">&nbsp; occur but <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> material is symbolic and stored in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> of <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> items.<br/></li>
<li></span><span class="Comment">&nbsp; At the end of pretty-printing, flushing the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> allows<br/></li>
<li></span><span class="Comment">&nbsp; post-processing of symbolic <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> performing low level <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a><br/></li>
<li></span><span class="Comment">&nbsp; operations.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; In practice, first define <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> symbolic <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [b] using:<br/></li>
<li></span><span class="Comment">&nbsp; - [let sob = <a href="#L1118" title="ocaml/stdlib/format.mli:1118">make_symbolic_output_buffer</a> ()].<br/></li>
<li></span><span class="Comment">&nbsp; Then define <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> symbolic <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> with:<br/></li>
<li></span><span class="Comment">&nbsp; - [let ppf = <a href="#L1156" title="ocaml/stdlib/format.mli:1156">formatter_of_symbolic_output_buffer</a> sob]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Use symbolic <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> [ppf] as usual, and retrieve symbolic items at end<br/></li>
<li></span><span class="Comment">&nbsp; of pretty-printing by flushing symbolic <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [sob] with:<br/></li>
<li></span><span class="Comment">&nbsp; - [<a href="#L1138" title="ocaml/stdlib/format.mli:1138">flush_symbolic_output_buffer</a> sob].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1098">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">symbolic_output_item</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Output_flush</span> <span class="Comment">(** symbolic <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> command *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Output_newline</span> <span class="Comment">(** symbolic newline command *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Output_string</span> <span class="Statement">of</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span>&nbsp; <span class="Comment">(** [Output_string <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]: symbolic <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> for <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]*)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Output_spaces</span> <span class="Statement">of</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span>&nbsp; <span class="Comment">(** [Output_spaces <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]: symbolic command to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] spaces *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Output_indent</span> <span class="Statement">of</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span>&nbsp; <span class="Comment">(** [Output_indent <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>]: symbolic indentation of <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] *)<br/></li>
<li></span><span class="Comment">(** Items produced by symbolic pretty-<a href="printexc.ml.html#L20" title="ocaml/stdlib/printexc.ml:20">printers</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1111">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">symbolic_output_buffer</span><br/></li>
<li></span><span class="Comment">(**<br/></li>
<li></span><span class="Comment">&nbsp; The <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> symbolic pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1118">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">make_symbolic_output_buffer</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L1111" title="ocaml/stdlib/format.mli:1111">symbolic_output_buffer</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L1118" title="ocaml/stdlib/format.mli:1118">make_symbolic_output_buffer</a> ()] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> for<br/></li>
<li></span><span class="Comment">&nbsp; symbolic <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1125">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">clear_symbolic_output_buffer</span></span> : <span class="ocamlLCIdentifier"><a href="#L1111" title="ocaml/stdlib/format.mli:1111">symbolic_output_buffer</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1125" title="ocaml/stdlib/format.mli:1125">clear_symbolic_output_buffer</a> sob] resets <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [sob].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1131">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get_symbolic_output_buffer</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="#L1111" title="ocaml/stdlib/format.mli:1111">symbolic_output_buffer</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L1098" title="ocaml/stdlib/format.mli:1098">symbolic_output_item</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="#L1131" title="ocaml/stdlib/format.mli:1131">get_symbolic_output_buffer</a> sob] returns the <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a> of <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [sob].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1138">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">flush_symbolic_output_buffer</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="#L1111" title="ocaml/stdlib/format.mli:1111">symbolic_output_buffer</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L1098" title="ocaml/stdlib/format.mli:1098">symbolic_output_item</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="#L1138" title="ocaml/stdlib/format.mli:1138">flush_symbolic_output_buffer</a> sob] returns the <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a> of <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a><br/></li>
<li></span><span class="Comment">&nbsp; [sob] and resets <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [sob].<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="#L1138" title="ocaml/stdlib/format.mli:1138">flush_symbolic_output_buffer</a> sob] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; [let items = <a href="#L1131" title="ocaml/stdlib/format.mli:1131">get_symbolic_output_buffer</a> sob in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="#L1125" title="ocaml/stdlib/format.mli:1125">clear_symbolic_output_buffer</a> sob; items]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1149">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">add_symbolic_output_item</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="#L1111" title="ocaml/stdlib/format.mli:1111">symbolic_output_buffer</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L1098" title="ocaml/stdlib/format.mli:1098">symbolic_output_item</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1149" title="ocaml/stdlib/format.mli:1149">add_symbolic_output_item</a> sob itm] adds <a href="camlinternalOO.ml.html#L50" title="ocaml/stdlib/camlinternalOO.ml:50">item</a> [itm] to <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> [sob].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1156">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">formatter_of_symbolic_output_buffer</span></span> : <span class="ocamlLCIdentifier"><a href="#L1111" title="ocaml/stdlib/format.mli:1111">symbolic_output_buffer</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L1156" title="ocaml/stdlib/format.mli:1156">formatter_of_symbolic_output_buffer</a> sob] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> symbolic <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a><br/></li>
<li></span><span class="Comment">&nbsp; that outputs to [<a href="#L1111" title="ocaml/stdlib/format.mli:1111">symbolic_output_buffer</a>] [sob].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.06<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Convenience <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> functions.} *)<br/></li>
<li></span><br/></li>
<li><a id="L1165">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_iter</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">?</span><span class="Identifier">pp_sep</span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">((</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1165" title="ocaml/stdlib/format.mli:1165">pp_print_iter</a> ~pp_sep <a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> pp_v ppf <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] formats on [ppf] the iterations of<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>] over <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> collection [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] of values using [pp_v]. Iterations are<br/></li>
<li></span><span class="Comment">&nbsp; separated by [pp_sep] (defaults to {!<a href="#L296" title="ocaml/stdlib/format.mli:296">pp_print_cut</a>}).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 5.1<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1176">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_list</span></span>:<br/></li>
<li>&nbsp; <span class="Statement">?</span><span class="Identifier">pp_sep</span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)<br/></li>
<li></span><span class="Comment">(** [<a href="#L1176" title="ocaml/stdlib/format.mli:1176">pp_print_list</a> ?pp_sep pp_v ppf <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] prints items of list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>],<br/></li>
<li></span><span class="Comment">&nbsp; using [pp_v] to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> each <a href="camlinternalOO.ml.html#L50" title="ocaml/stdlib/camlinternalOO.ml:50">item</a>, and calling [pp_sep]<br/></li>
<li></span><span class="Comment">&nbsp; between items ([pp_sep] defaults to {!<a href="#L296" title="ocaml/stdlib/format.mli:296">pp_print_cut</a>}).<br/></li>
<li></span><span class="Comment">&nbsp; Does nothing on <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> lists.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.02<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1187">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_array</span></span>:<br/></li>
<li>&nbsp; <span class="Statement">?</span><span class="Identifier">pp_sep</span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">array</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)<br/></li>
<li></span><span class="Comment">(** [<a href="#L1187" title="ocaml/stdlib/format.mli:1187">pp_print_array</a> ?pp_sep pp_v ppf <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] prints items of array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; using [pp_v] to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> each <a href="camlinternalOO.ml.html#L50" title="ocaml/stdlib/camlinternalOO.ml:50">item</a>, and calling [pp_sep]<br/></li>
<li></span><span class="Comment">&nbsp; between items ([pp_sep] defaults to {!<a href="#L296" title="ocaml/stdlib/format.mli:296">pp_print_cut</a>}).<br/></li>
<li></span><span class="Comment">&nbsp; Does nothing on <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> arrays.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is mutated after [<a href="#L1187" title="ocaml/stdlib/format.mli:1187">pp_print_array</a>] is called, the printed values<br/></li>
<li></span><span class="Comment">&nbsp; may not be what is expected because [Format] can delay the printing.<br/></li>
<li></span><span class="Comment">&nbsp; This can be avoided by flushing [ppf].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 5.1<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1202">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_seq</span></span>:<br/></li>
<li>&nbsp; <span class="Statement">?</span><span class="Identifier">pp_sep</span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="PreProc">Seq</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)<br/></li>
<li></span><span class="Comment">(** [<a href="#L1202" title="ocaml/stdlib/format.mli:1202">pp_print_seq</a> ?pp_sep pp_v ppf <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] prints items of sequence [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>],<br/></li>
<li></span><span class="Comment">&nbsp; using [pp_v] to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> each <a href="camlinternalOO.ml.html#L50" title="ocaml/stdlib/camlinternalOO.ml:50">item</a>, and calling [pp_sep]<br/></li>
<li></span><span class="Comment">&nbsp; between items ([pp_sep] defaults to {!<a href="#L296" title="ocaml/stdlib/format.mli:296">pp_print_cut</a>}.<br/></li>
<li></span><span class="Comment">&nbsp; Does nothing on <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> sequences.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This function does not terminate on infinite sequences.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1215">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_text</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1215" title="ocaml/stdlib/format.mli:1215">pp_print_text</a> ppf <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] prints [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] with spaces and newlines respectively<br/></li>
<li></span><span class="Comment">&nbsp; printed using {!<a href="#L287" title="ocaml/stdlib/format.mli:287">pp_print_space</a>} and {!<a href="#L357" title="ocaml/stdlib/format.mli:357">pp_force_newline</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.02<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1222">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_option</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">?</span><span class="Identifier"><a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a></span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)<br/></li>
<li></span><span class="Comment">(** [<a href="#L1222" title="ocaml/stdlib/format.mli:1222">pp_print_option</a> ?<a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> pp_v ppf o] prints [o] on [ppf]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; using [pp_v] if [o] is [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] and [<a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a>] if it is [None]. [<a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; prints nothing by default.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L1231">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_result</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="result.ml.html#L18" title="ocaml/stdlib/result.ml:18">ok</a></span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a></span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a></span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1231" title="ocaml/stdlib/format.mli:1231">pp_print_result</a> ~<a href="result.ml.html#L18" title="ocaml/stdlib/result.ml:18">ok</a> ~<a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> ppf <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] prints [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] on [ppf] using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="result.ml.html#L18" title="ocaml/stdlib/result.ml:18">ok</a>] if [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] is [Ok _] and [<a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>] if [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] is [Error _].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L1239">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pp_print_either</span></span> :<br/></li>
<li>&nbsp; <span class="ocamlLCIdentifier"><a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a></span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="ocamlLCIdentifier"><a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a></span>:<span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="PreProc">Either</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L1239" title="ocaml/stdlib/format.mli:1239">pp_print_either</a> ~<a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> ~<a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> ppf <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] prints [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] on [ppf] using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a>] if [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] is [Either.Left _] and [<a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>] if [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] is [Either.Right _].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:fpp Formatted pretty-printing} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**<br/></li>
<li></span><span class="Comment">&nbsp; Module [Format] provides <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> complete <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>] like functions for<br/></li>
<li></span><span class="Comment">&nbsp; pretty-printing using <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> specifications.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Specific annotations may be added in the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings to give<br/></li>
<li></span><span class="Comment">&nbsp; pretty-printing commands to the pretty-printing <a href="lexing.mli.html#L211" title="ocaml/stdlib/lexing.mli:211">engine</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Those annotations are introduced in the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> strings using the [@]<br/></li>
<li></span><span class="Comment">&nbsp; character. For instance, [@ ] means <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> space break, [@,] means <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> cut,<br/></li>
<li></span><span class="Comment">&nbsp; [@\[] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new box, and [@\]] closes the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> open box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1262">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fprintf</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span><span class="Statement">)</span> <span class="Type"><a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">(** [<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> ff <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> arg1 ... argN] formats the arguments [arg1] to [argN]<br/></li>
<li></span><span class="Comment">&nbsp; according to the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>], and outputs the resulting <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> on<br/></li>
<li></span><span class="Comment">&nbsp; the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> [ff].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> [<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> character <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> which <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> three types of<br/></li>
<li></span><span class="Comment">&nbsp; objects: plain characters and conversion specifications as specified in<br/></li>
<li></span><span class="Comment">&nbsp; the {!Printf} module, and pretty-printing indications specific to the<br/></li>
<li></span><span class="Comment">&nbsp; [Format] module.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; The pretty-printing indication characters are introduced by<br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [@] character, and their meanings are:<br/></li>
<li></span><span class="Comment">&nbsp; - [@\[]: open <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-printing box. The type and <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; box may be optionally specified with the following syntax:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the [&lt;] character, followed by an optional box type indication,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then an optional integer <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a>, and the <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> [&gt;] character.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Pretty-printing box type is <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of [h], [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], [hv], [b], or [hov].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; '[h]' stands for an 'horizontal' pretty-printing box,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; '[<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]' stands for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'vertical' pretty-printing box,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; '[hv]' stands for an 'horizontal/vertical' pretty-printing box,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; '[b]' stands for an 'horizontal-or-vertical' pretty-printing box<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; demonstrating indentation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; '[hov]' stands <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> simple 'horizontal-or-vertical' pretty-printing box.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For instance, [@\[&lt;hov 2&gt;] opens an 'horizontal-or-vertical'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; pretty-printing box with indentation 2 as obtained with [<a href="#L219" title="ocaml/stdlib/format.mli:219">open_hovbox</a> 2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For more details about pretty-printing boxes, see the various box opening<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; functions [open_*box].<br/></li>
<li></span><span class="Comment">&nbsp; - [@\]]: <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> the most recently opened pretty-printing box.<br/></li>
<li></span><span class="Comment">&nbsp; - [@,]: <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'cut' break hint, as with [<a href="#L297" title="ocaml/stdlib/format.mli:297">print_cut</a> ()].<br/></li>
<li></span><span class="Comment">&nbsp; - [@ ]: <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'space' break hint, as with [<a href="#L288" title="ocaml/stdlib/format.mli:288">print_space</a> ()].<br/></li>
<li></span><span class="Comment">&nbsp; - [@;]: <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 'full' break hint as with [<a href="#L306" title="ocaml/stdlib/format.mli:306">print_break</a>]. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [nspaces] and [<a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a>] parameters of the break hint may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; optionally specified with the following syntax:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the [&lt;] character, followed by an integer [nspaces] value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then an integer [<a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a>], and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> [&gt;] character.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If no parameters are provided, the full break defaults to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; 'space' break hint.<br/></li>
<li></span><span class="Comment">&nbsp; - [@.]: <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> and <a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> the line, as with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="stdlib.ml.html#L493" title="ocaml/stdlib/stdlib.ml:493">print_newline</a> ()].<br/></li>
<li></span><span class="Comment">&nbsp; - [@&lt;<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>&gt;]: <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> the following <a href="camlinternalOO.ml.html#L50" title="ocaml/stdlib/camlinternalOO.ml:50">item</a> as if it were of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Hence, [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@&lt;0&gt;%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>&quot; <a href="complex.ml.html#L53" title="ocaml/stdlib/complex.ml:53">arg</a>] prints [<a href="complex.ml.html#L53" title="ocaml/stdlib/complex.ml:53">arg</a>] as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If [@&lt;<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>&gt;] is not followed by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> conversion specification,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then the following character of the <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> is printed as if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; it were of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><span class="Comment">&nbsp; - [@\{]: open <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>. The <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> of the <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> may be optionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; specified with the following syntax:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the [&lt;] character, followed by an optional <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; specification, and the <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> [&gt;] character. The <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; specification is any character <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> that does not contain the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a> character ['&gt;']. If omitted, the <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a> <a href="obj.ml.html#L107" title="ocaml/stdlib/obj.ml:107">name</a> defaults to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For more details about semantic tags, see the functions {!<a href="#L746" title="ocaml/stdlib/format.mli:746">open_stag</a>} and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="#L757" title="ocaml/stdlib/format.mli:757">close_stag</a>}.<br/></li>
<li></span><span class="Comment">&nbsp; - [@\}]: <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> the most recently opened semantic <a href="camlinternalOO.ml.html#L57" title="ocaml/stdlib/camlinternalOO.ml:57">tag</a>.<br/></li>
<li></span><span class="Comment">&nbsp; - [@?]: <a href="out_channel.mli.html#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a> the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> as with [<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a> ()].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; This is equivalent to the conversion [%!].<br/></li>
<li></span><span class="Comment">&nbsp; - [@\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]: force <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline, as with [<a href="#L358" title="ocaml/stdlib/format.mli:358">force_newline</a> ()], not the normal way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of pretty-printing, you should prefer using break hints inside <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> vertical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; pretty-printing box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Note: To prevent the interpretation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [@] character as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; pretty-printing indication, escape it with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [%] character.<br/></li>
<li></span><span class="Comment">&nbsp; Old quotation mode [@@] is deprecated since it is not compatible with<br/></li>
<li></span><span class="Comment">&nbsp; formatted <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> interpretation of character ['@'].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Example: [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@[%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>@ %d@]@.&quot; &quot;<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> =&quot; 1] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="#L156" title="ocaml/stdlib/format.mli:156">open_box</a> (); <a href="stdlib.ml.html#L487" title="ocaml/stdlib/stdlib.ml:487">print_string</a> &quot;<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> =&quot;; <a href="#L288" title="ocaml/stdlib/format.mli:288">print_space</a> ();<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="stdlib.ml.html#L489" title="ocaml/stdlib/stdlib.ml:489">print_int</a> 1; <a href="#L180" title="ocaml/stdlib/format.mli:180">close_box</a> (); <a href="stdlib.ml.html#L493" title="ocaml/stdlib/stdlib.ml:493">print_newline</a> ()].<br/></li>
<li></span><span class="Comment">&nbsp; It prints [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 1] within <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pretty-printing 'horizontal-or-vertical' box.<br/></li>
<li></span><br/></li>
<li><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1335">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">printf</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span><span class="Statement">)</span> <span class="Type"><a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Same as [<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>] above, but <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> on [<a href="#L986" title="ocaml/stdlib/format.mli:986">get_std_formatter</a> ()].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It is defined similarly to [fun <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> -&gt; <a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> (<a href="#L986" title="ocaml/stdlib/format.mli:986">get_std_formatter</a> ()) <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; but delays calling [<a href="#L986" title="ocaml/stdlib/format.mli:986">get_std_formatter</a>] until after the final argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; required by the [<a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a>] is received. When used with multiple domains, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> from the domains will be interleaved with each other at points where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> is flushed, such as with {!<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1345">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">eprintf</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span><span class="Statement">)</span> <span class="Type"><a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Same as [<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>] above, but <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> on [<a href="#L998" title="ocaml/stdlib/format.mli:998">get_err_formatter</a> ()].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It is defined similarly to [fun <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a> -&gt; <a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> (<a href="#L998" title="ocaml/stdlib/format.mli:998">get_err_formatter</a> ()) <a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; but delays calling [<a href="#L998" title="ocaml/stdlib/format.mli:998">get_err_formatter</a>] until after the final argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; required by the [<a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a>] is received. When used with multiple domains, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> from the domains will be interleaved with each other at points where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> is flushed, such as with {!<a href="#L379" title="ocaml/stdlib/format.mli:379">print_flush</a>}.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1355">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sprintf</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="Type">unit</span>, <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span><span class="Statement">)</span> <span class="Type"><a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Same as [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>] above, but instead of printing on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>,<br/></li>
<li></span><span class="Comment">&nbsp; returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> containing the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> the arguments.<br/></li>
<li></span><span class="Comment">&nbsp; Note that the pretty-<a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> queue is flushed at the end of {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> each<br/></li>
<li></span><span class="Comment">&nbsp; call} to [<a href="printf.mli.html#L135" title="ocaml/stdlib/printf.mli:135">sprintf</a>]. Note that if your <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; you should use [<a href="#L1372" title="ocaml/stdlib/format.mli:1372">asprintf</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; In case of multiple and related calls to [<a href="printf.mli.html#L135" title="ocaml/stdlib/printf.mli:135">sprintf</a>] to <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a><br/></li>
<li></span><span class="Comment">&nbsp; material on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>, you should consider using [<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>]<br/></li>
<li></span><span class="Comment">&nbsp; with the predefined <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> [<a href="#L1019" title="ocaml/stdlib/format.mli:1019">str_formatter</a>] and call<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="#L1031" title="ocaml/stdlib/format.mli:1031">flush_str_formatter</a> ()] to <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> the final <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Alternatively, you can use [Format.<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>] with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> writing to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> of your own: flushing the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> and the <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> at the end of<br/></li>
<li></span><span class="Comment">&nbsp; pretty-printing returns the desired <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1372">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">asprintf</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span>, <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span><span class="Statement">)</span> <span class="Type"><a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Same as [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>] above, but instead of printing on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>,<br/></li>
<li></span><span class="Comment">&nbsp; returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> containing the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> the arguments.<br/></li>
<li></span><span class="Comment">&nbsp; The type of [<a href="#L1372" title="ocaml/stdlib/format.mli:1372">asprintf</a>] is general enough to interact nicely with [%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp; conversions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.01<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1381">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">dprintf</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Type"><a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>}, except the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> is the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> argument.<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="#L1381" title="ocaml/stdlib/format.mli:1381">dprintf</a> &quot;...&quot; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> function of type<br/></li>
<li></span><span class="Comment">&nbsp; [<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> -&gt; unit] which can be given to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> specifier [%<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; This can be used as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> replacement for {!<a href="#L1372" title="ocaml/stdlib/format.mli:1372">asprintf</a>} to delay<br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> decisions. Using the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> returned by {!<a href="#L1372" title="ocaml/stdlib/format.mli:1372">asprintf</a>} in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> context forces <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> decisions to be taken in<br/></li>
<li></span><span class="Comment">&nbsp; isolation, and the final <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> may be created<br/></li>
<li></span><span class="Comment">&nbsp; prematurely. {!<a href="#L1381" title="ocaml/stdlib/format.mli:1381">dprintf</a>} allows delay of <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> decisions until<br/></li>
<li></span><span class="Comment">&nbsp; the final <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> context is known.<br/></li>
<li></span><span class="Comment">&nbsp; For example:<br/></li>
<li></span><span class="Comment">{[<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = Format.<a href="#L1381" title="ocaml/stdlib/format.mli:1381">dprintf</a> &quot;%<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>@ %<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>@ %<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>&quot; 1 2 3 in<br/></li>
<li></span><span class="Comment">&nbsp; ...<br/></li>
<li></span><span class="Comment">&nbsp; Format.<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;@[&lt;<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>&gt;%<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>@]&quot; <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L1404">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">ifprintf</span></span> : <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span><span class="Statement">)</span> <span class="Type"><a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Same as [<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>] above, but does not <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> anything.<br/></li>
<li></span><span class="Comment">&nbsp; Useful to ignore <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> material when conditionally printing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 3.10<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Formatted Pretty-Printing with continuations. *)<br/></li>
<li></span><br/></li>
<li><a id="L1413">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">kfprintf</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Type"><a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b<br/></li>
<li></span><span class="Comment">(** Same as [<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a>] above, but instead of returning immediately,<br/></li>
<li></span><span class="Comment">&nbsp; passes the <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> to its first argument at the end of printing. *)<br/></li>
<li></span><br/></li>
<li><a id="L1419">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">kdprintf</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">((</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Type"><a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="#L1381" title="ocaml/stdlib/format.mli:1381">dprintf</a>} above, but instead of returning immediately,<br/></li>
<li></span><span class="Comment">&nbsp; passes the suspended <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> to its first argument at the end of printing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1428">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">ikfprintf</span></span> :<br/></li>
<li>&nbsp; <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span> <span class="Statement">-&gt;<br/></li>
<li></span>&nbsp; <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Type"><a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b<br/></li>
<li></span><span class="Comment">(** Same as [<a href="printf.mli.html#L158" title="ocaml/stdlib/printf.mli:158">kfprintf</a>] above, but does not <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> anything.<br/></li>
<li></span><span class="Comment">&nbsp; Useful to ignore <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> material when conditionally printing.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L1437">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">ksprintf</span></span> : <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span>, <span class="Type">unit</span>, <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Type"><a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b<br/></li>
<li></span><span class="Comment">(** Same as [<a href="printf.mli.html#L135" title="ocaml/stdlib/printf.mli:135">sprintf</a>] above, but instead of returning the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>,<br/></li>
<li></span><span class="Comment">&nbsp; passes it to the first argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L1441">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">kasprintf</span></span> : <span class="Statement">(</span><span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span>, <span class="ocamlLCIdentifier"><a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a></span>, <span class="Type">unit</span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Type"><a href="stdlib.ml.html#L534" title="ocaml/stdlib/stdlib.ml:534">format4</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b<br/></li>
<li></span><span class="Comment">(** Same as [<a href="#L1372" title="ocaml/stdlib/format.mli:1372">asprintf</a>] above, but instead of returning the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>,<br/></li>
<li></span><span class="Comment">&nbsp; passes it to the first argument.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; @since 4.03<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:examples Examples}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; A few warmup examples to <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> an idea of how Format is used.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; We have <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] of pairs [(<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a>)], which the toplevel prints for us:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; {[# let <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a> = List.<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> 20 (fun <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> -&gt; <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>, <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> mod 2 = 0)<br/></li>
<li></span><span class="Comment">&nbsp; val <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a> : (<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a>) list =<br/></li>
<li></span><span class="Comment">&nbsp; [(0, true); (1, false); (2, true); (3, false); (4, true); (5, false);<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (6, true); (7, false); (8, true); (9, false); (10, true); (11, false);<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (12, true); (13, false); (14, true); (15, false); (16, true); (17, false);<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (18, true); (19, false)]<br/></li>
<li></span><span class="Comment"> ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If we want to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> it ourself without the toplevel magic, we can try this:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; # let pp_pair out (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>,y) = Format.<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> out &quot;(%d, %b)&quot; <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y<br/></li>
<li></span><span class="Comment">&nbsp; val pp_pair : Format.<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> -&gt; <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a> -&gt; unit = &lt;fun&gt;<br/></li>
<li></span><span class="Comment">&nbsp; # Format.<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>: [@[&lt;hov&gt;%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>@]]@.&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Format.(<a href="#L1176" title="ocaml/stdlib/format.mli:1176">pp_print_list</a> ~pp_sep:(fun out () -&gt; <a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> out &quot;;@ &quot;) pp_pair) <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>: [(0, true); (1, false); (2, true); (3, false); (4, true); (5, false);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (6, true); (7, false); (8, true); (9, false); (10, true); (11, false);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (12, true); (13, false); (14, true); (15, false); (16, true);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (17, false); (18, true); (19, false)]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp; What this does, briefly, is:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [pp_pair] prints <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair [<a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a>*<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] surrounded in &quot;(&quot; &quot;)&quot;. It takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> (into which <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> happens), and the pair itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; When printing is done it returns [()].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [Format.<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a> = [@[&lt;hov&gt;%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>@]]@.&quot; ... <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is like [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>], but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; with additional <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> instructions (denoted with &quot;@&quot;). The pair<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &quot;@[&lt;hov&gt;&quot; and &quot;@]&quot; is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> &quot;horizontal-or-vertical box&quot;.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - &quot;@.&quot; ends <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline. It is similar to &quot;\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>&quot; but is also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; aware of the [Format.<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a>]'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>. Do not use &quot;\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>&quot; with [Format].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - &quot;%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>&quot; is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> instruction, like &quot;%d&quot; or &quot;%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>&quot; for [<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; However, where &quot;%d&quot; prints an integer and &quot;%<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>&quot; prints <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &quot;%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>&quot; takes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> (of type [Format.<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> -&gt; unit])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value (of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]) and applies the <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> to the value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; This is <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> to compositionality of <a href="printexc.ml.html#L20" title="ocaml/stdlib/printexc.ml:20">printers</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - We build <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [Format.<a href="#L1176" title="ocaml/stdlib/format.mli:1176">pp_print_list</a> ~pp_sep:(...) pp_pair].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="#L1176" title="ocaml/stdlib/format.mli:1176">pp_print_list</a>] takes an element <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> and returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; The [?pp_sep] optional argument, if provided, is called in between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; each element to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> separator.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - Here, for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> separator, we use [(fun out () -&gt; Format.<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> out &quot;;@ &quot;)].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; It prints &quot;;&quot;, and then &quot;@ &quot; which is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> breaking space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (either it prints &quot; &quot;, or it prints <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline if the box is about to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; overflow).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; This &quot;@ &quot; is responsible for the list printing splitting into several<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; lines.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; If we omit &quot;@ &quot;, we <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> an ugly single-line <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a>:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; {[# Format.<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>: [@[&lt;hov&gt;%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>@]]@.&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Format.(<a href="#L1176" title="ocaml/stdlib/format.mli:1176">pp_print_list</a> ~pp_sep:(fun out () -&gt; <a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> out &quot;; &quot;) pp_pair) <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a><br/></li>
<li></span><span class="Comment">&nbsp; <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>: [(0, true); (1, false); (2, true); (* ... *); (18, true); (19, false)]<br/></li>
<li></span><span class="Comment">- : unit = ()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Generally, it is good practice to define custom <a href="printexc.ml.html#L20" title="ocaml/stdlib/printexc.ml:20">printers</a> for important types<br/></li>
<li></span><span class="Comment">&nbsp; in your program. If, for example, you were to define basic <a href="#L496" title="ocaml/stdlib/format.mli:496">geometry</a><br/></li>
<li></span><span class="Comment">&nbsp; types like so:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; type point = {<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>: <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; y: <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>;<br/></li>
<li></span><span class="Comment">&nbsp; }<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; type rectangle = {<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ll: point; (* lower <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ur: point; (* upper <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> *)<br/></li>
<li></span><span class="Comment">&nbsp; }<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; For debugging purpose, or to display information in logs, or on the console,<br/></li>
<li></span><span class="Comment">&nbsp; it would be convenient to define <a href="printexc.ml.html#L20" title="ocaml/stdlib/printexc.ml:20">printers</a> for these types.<br/></li>
<li></span><span class="Comment">&nbsp; Here is an example of to do it.<br/></li>
<li></span><span class="Comment">&nbsp; Note that &quot;%.3f&quot; is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>] <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a> up to 3 digits of <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a><br/></li>
<li></span><span class="Comment">&nbsp; after the dot; &quot;%f&quot; would <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> as many digits as required, which is<br/></li>
<li></span><span class="Comment">&nbsp; somewhat verbose; &quot;%h&quot; is an hexadecimal <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; let pp_point out (<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>:point) =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Format.<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> out &quot;{ @[<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>=%.3f;@ y=%.3f@] }&quot; <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>.<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>.y<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; let pp_rectangle out (<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>:rectangle) =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Format.<a href="printf.mli.html#L18" title="ocaml/stdlib/printf.mli:18">fprintf</a> out &quot;{ @[ll=%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>;@ ur=%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>@] }&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; pp_point <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>.ll pp_point <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>.ur<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; In the [.mli] <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, we could have:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; val pp_point : Format.<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> -&gt; point -&gt; unit<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; val pp_rectangle : Format.<a href="format.ml.html#L136" title="ocaml/stdlib/format.ml:136">formatter</a> -&gt; rectangle -&gt; unit<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; These <a href="printexc.ml.html#L20" title="ocaml/stdlib/printexc.ml:20">printers</a> can now be used with &quot;%<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>&quot; inside other <a href="printexc.ml.html#L20" title="ocaml/stdlib/printexc.ml:20">printers</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; {[ # Format.<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;<a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> rectangle: %<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>@.&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (Format.<a href="#L1222" title="ocaml/stdlib/format.mli:1222">pp_print_option</a> pp_rectangle)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (Some {ll={<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>=1.; y=2.}; ur={<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>=42.; y=500.12345}})<br/></li>
<li></span><span class="Comment">&nbsp; <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> rectangle: { <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>={ <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>=1.000; y=2.000 }; ur={ <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>=42.000; y=500.123 } }<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; # Format.<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;no rectangle: %<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>@.&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (Format.pp_option pp_rectangle)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; None<br/></li>
<li></span><span class="Comment">&nbsp; no rectangle:<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; See how we <a href="array.mli.html#L284" title="ocaml/stdlib/array.mli:284">combine</a> [<a href="#L1222" title="ocaml/stdlib/format.mli:1222">pp_print_option</a>] (option <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>) and our newly defined<br/></li>
<li></span><span class="Comment">&nbsp; rectangle <a href="effect.ml.html#L22" title="ocaml/stdlib/effect.ml:22">printer</a>, like we did with [<a href="#L1176" title="ocaml/stdlib/format.mli:1176">pp_print_list</a>] earlier.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; For <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> more extensive tutorial, see<br/></li>
<li></span><span class="Comment">&nbsp; {{: https://caml.inria.fr/resources/<a href="arg.ml.html#L17" title="ocaml/stdlib/arg.ml:17">doc</a>/guides/<a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a>.en.html}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &quot;Using the Format module&quot;}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; A final note: the [Format] module is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> starting point.<br/></li>
<li></span><span class="Comment">&nbsp; The OCaml ecosystem has libraries that makes <a href="camlinternalFormat.ml.html#L2649" title="ocaml/stdlib/camlinternalFormat.ml:2649">formatting</a> easier<br/></li>
<li></span><span class="Comment">&nbsp; and more expressive, with more combinators, more concise names, etc.<br/></li>
<li></span><span class="Comment">&nbsp; An example of such <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> library is {{: https://erratique.ch/software/<a href="camlinternalFormatBasics.mli.html#L172" title="ocaml/stdlib/camlinternalFormatBasics.mli:172">fmt</a>} Fmt}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; Automatic deriving of pretty-<a href="printexc.ml.html#L20" title="ocaml/stdlib/printexc.ml:20">printers</a> from type definitions is also possible,<br/></li>
<li></span><span class="Comment">&nbsp; using {{: ppx_deriving.show} https://github.com/ocaml-ppx/ppx_deriving}<br/></li>
<li></span><span class="Comment">&nbsp; or similar ppx derivers.<br/></li>
<li></span><span class="Comment">*)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
