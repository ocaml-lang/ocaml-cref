<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/out_channel.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/out_channel.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L78">close</a></li>
<li><a href="#L85">close_noerr</a></li>
<li><a href="#L118">flush</a></li>
<li><a href="#L123">flush_all</a></li>
<li><a href="#L175">is_buffered</a></li>
<li><a href="#L179">isatty</a></li>
<li><a href="#L145">length</a></li>
<li><a href="#L47">open_bin</a></li>
<li><a href="#L58">open_gen</a></li>
<li><a href="#L52">open_text</a></li>
<li><a href="#L105">output</a></li>
<li><a href="#L93">output_byte</a></li>
<li><a href="#L100">output_bytes</a></li>
<li><a href="#L90">output_char</a></li>
<li><a href="#L97">output_string</a></li>
<li><a href="#L112">output_substring</a></li>
<li><a href="#L133">pos</a></li>
<li><a href="#L128">seek</a></li>
<li><a href="#L151">set_binary_mode</a></li>
<li><a href="#L163">set_buffered</a></li>
<li><a href="#L44">stderr</a></li>
<li><a href="#L41">stdout</a></li>
<li><a href="#L65">with_open_bin</a></li>
<li><a href="#L74">with_open_gen</a></li>
<li><a href="#L70">with_open_text</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L29">open_flag</a></li>
<li><a href="#L26">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2021 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Output channels.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This module provides functions for working with <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channels.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; See {{!examples} the example section} below.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:channels Channels}&nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L26">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">t</span></span> <span class="Statement">=</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a><br/></li>
<li></span><span class="Comment">(** The type of <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L29">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">open_flag</span></span> <span class="Statement">=</span> <span class="PreProc">Stdlib</span>.<span class="ocamlLCIdentifier"><span class="linkable">open_flag</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_rdonly</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for reading. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_wronly</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for writing. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_append</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for appending: always write at end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_creat</span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> if it does not exist. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_trunc</span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> if it already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_excl</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** fail if Open_creat and the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_binary</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open in binary mode (no conversion). *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_text</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** open in text mode (may perform conversions). *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_nonblock</span>&nbsp; &nbsp; <span class="Comment">(** open in non-blocking mode. *)<br/></li>
<li></span><span class="Comment">(** Opening modes for {!<a href="in_channel.ml.html#L32" title="ocaml/stdlib/in_channel.ml:32">open_gen</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L41">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stdout</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** The standard <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> for the process. *)<br/></li>
<li></span><br/></li>
<li><a id="L44">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stderr</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** The standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> for the process. *)<br/></li>
<li></span><br/></li>
<li><a id="L47">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_bin</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Open the named <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> for writing, and <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel on that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, positioned at the beginning of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>. The <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is truncated to <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> if it already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. It is created if it does not already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L52">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_text</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="in_channel.ml.html#L30" title="ocaml/stdlib/in_channel.ml:30">open_bin</a>}, but the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is opened in text mode, so that newline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; translation takes place during writes. On operating systems that do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; distinguish between text mode and binary mode, this function behaves like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="in_channel.ml.html#L30" title="ocaml/stdlib/in_channel.ml:30">open_bin</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L58">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_gen</span></span> : <span class="ocamlLCIdentifier"><a href="in_channel.ml.html#L18" title="ocaml/stdlib/in_channel.ml:18">open_flag</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L32" title="ocaml/stdlib/in_channel.ml:32">open_gen</a> mode perm filename] opens the named <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> for writing, as described<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; above. The extra argument [mode] specifies the opening mode. The extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument [perm] specifies the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> permissions, in case the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; created.&nbsp; {!<a href="in_channel.ml.html#L31" title="ocaml/stdlib/in_channel.ml:31">open_text</a>} and {!<a href="in_channel.ml.html#L30" title="ocaml/stdlib/in_channel.ml:30">open_bin</a>} are special cases of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; function. *)<br/></li>
<li></span><br/></li>
<li><a id="L65">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">with_open_bin</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L65" title="ocaml/stdlib/out_channel.mli:65">with_open_bin</a> fn f] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> channel [oc] on <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> [fn] and returns [f<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; oc]. After [f] returns, either with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value or by raising an exception, [oc]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is guaranteed to be closed. *)<br/></li>
<li></span><br/></li>
<li><a id="L70">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">with_open_text</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Like {!<a href="#L65" title="ocaml/stdlib/out_channel.mli:65">with_open_bin</a>}, but the channel is opened in text mode (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="in_channel.ml.html#L31" title="ocaml/stdlib/in_channel.ml:31">open_text</a>}). *)<br/></li>
<li></span><br/></li>
<li><a id="L74">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">with_open_gen</span></span> : <span class="ocamlLCIdentifier"><a href="in_channel.ml.html#L18" title="ocaml/stdlib/in_channel.ml:18">open_flag</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Like {!<a href="#L65" title="ocaml/stdlib/out_channel.mli:65">with_open_bin</a>}, but can specify the opening mode and <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> permission,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in case the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> must be created (see {!<a href="in_channel.ml.html#L32" title="ocaml/stdlib/in_channel.ml:32">open_gen</a>}). *)<br/></li>
<li></span><br/></li>
<li><a id="L78">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Close the given channel, flushing all buffered write operations.&nbsp; Output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; functions raise <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [Sys_error] exception when they are applied to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> closed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel, except {!<a href="#L78" title="ocaml/stdlib/out_channel.mli:78">close</a>} and {!<a href="#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>}, which do nothing when applied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to an already closed channel.&nbsp; Note that {!<a href="#L78" title="ocaml/stdlib/out_channel.mli:78">close</a>} may raise [Sys_error] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the operating system signals an <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> when flushing or <a href="buffer.ml.html#L217" title="ocaml/stdlib/buffer.ml:217">closing</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L85">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_noerr</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="#L78" title="ocaml/stdlib/out_channel.mli:78">close</a>}, but ignore all <a href="printexc.ml.html#L299" title="ocaml/stdlib/printexc.ml:299">errors</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:<a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> Output} *)<br/></li>
<li></span><br/></li>
<li><a id="L90">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_char</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write the character on the given <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L93">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_byte</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> 8-bit integer (as the single character with that code) on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; given <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. The given integer is taken modulo 256. *)<br/></li>
<li></span><br/></li>
<li><a id="L97">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_string</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> on the given <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L100">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_bytes</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Write the byte sequence on the given <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:advanced_output Advanced <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>} *)<br/></li>
<li></span><br/></li>
<li><a id="L105">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> oc <a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a> <a href="#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] writes [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters from byte sequence [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at <a href="format.ml.html#L371" title="ocaml/stdlib/format.ml:371">offset</a> [<a href="#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>], to the given <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel [oc].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L112">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">output_substring</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>} but <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> as argument instead of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:flushing Flushing} *)<br/></li>
<li></span><br/></li>
<li><a id="L118">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">flush</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Flush the <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a> associated with the given <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channel, performing all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; pending writes on that channel.&nbsp; Interactive programs must be careful about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; flushing standard <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> and standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> at the <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> time. *)<br/></li>
<li></span><br/></li>
<li><a id="L123">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">flush_all</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Flush all open <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channels; ignore <a href="printexc.ml.html#L299" title="ocaml/stdlib/printexc.ml:299">errors</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:seeking Seeking} *)<br/></li>
<li></span><br/></li>
<li><a id="L128">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">seek</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L128" title="ocaml/stdlib/out_channel.mli:128">seek</a> chan <a href="#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] sets the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> writing <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> to [<a href="#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] for channel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [chan]. This works only for regular files. On files of other kinds (such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; terminals, pipes and sockets), the behavior is unspecified. *)<br/></li>
<li></span><br/></li>
<li><a id="L133">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pos</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> writing <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> for the given channel.&nbsp; Does not work on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; channels opened with the [Open_append] flag (returns unspecified results).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For files opened in text mode under Windows, the returned <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; approximate (owing to end-of-line conversion); in particular, saving the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> with {!<a href="#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>}, then going back to this <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> using {!<a href="#L128" title="ocaml/stdlib/out_channel.mli:128">seek</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; will not work.&nbsp; For this programming idiom to work reliably and portably,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> must be opened in binary mode. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:attributes Attributes}&nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L145">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">length</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> (number of characters) of the regular <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> on which the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; given channel is opened.&nbsp; If the channel is opened on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> that is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; regular <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is meaningless. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L151">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_binary_mode</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L183" title="ocaml/stdlib/in_channel.ml:183">set_binary_mode</a> oc true] sets the channel [oc] to binary mode: no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; translations <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place during <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="in_channel.ml.html#L183" title="ocaml/stdlib/in_channel.ml:183">set_binary_mode</a> oc false] sets the channel [oc] to text mode: depending on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the operating system, <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> translations may <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place during <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; instance, under Windows, end-of-lines will be translated from [\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [\<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This function has no effect under operating systems that do not distinguish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; between text mode and binary mode. *)<br/></li>
<li></span><br/></li>
<li><a id="L163">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_buffered</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L163" title="ocaml/stdlib/out_channel.mli:163">set_buffered</a> oc true] sets the channel [oc] to {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> buffered} mode. In this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; mode, <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> on [oc] will be buffered until either the internal <a href="camlinternalFormat.ml.html#L250" title="ocaml/stdlib/camlinternalFormat.ml:250">buffer</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is full or the function {!<a href="#L118" title="ocaml/stdlib/out_channel.mli:118">flush</a>} or {!<a href="#L123" title="ocaml/stdlib/out_channel.mli:123">flush_all</a>} is called, at which point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; it will be sent to the <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="#L163" title="ocaml/stdlib/out_channel.mli:163">set_buffered</a> oc false] sets the channel [oc] to {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> unbuffered} mode. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; this mode, <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> on [oc] will be sent to the <a href="#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> device<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; immediately.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; All channels are open in {<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> buffered} mode by default. *)<br/></li>
<li></span><br/></li>
<li><a id="L175">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">is_buffered</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L175" title="ocaml/stdlib/out_channel.mli:175">is_buffered</a> oc] returns whether the channel [oc] is buffered (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="#L163" title="ocaml/stdlib/out_channel.mli:163">set_buffered</a>}). *)<br/></li>
<li></span><br/></li>
<li><a id="L179">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">isatty</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L179" title="ocaml/stdlib/out_channel.mli:179">isatty</a> oc] is [true] if [oc] refers to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> terminal or console window,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [false] otherwise.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:examples Examples}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Writing the <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let write_file <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Out_channel.<a href="#L65" title="ocaml/stdlib/out_channel.mli:65">with_open_bin</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fun oc -&gt; Out_channel.<a href="#L97" title="ocaml/stdlib/out_channel.mli:97">output_string</a> oc <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ]}<br/></li>
<li></span><span class="Comment">*)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
