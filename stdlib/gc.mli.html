<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/gc.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/gc.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L318">allocated_bytes</a></li>
<li><a href="#L420">create_alarm</a></li>
<li><a href="#L427">delete_alarm</a></li>
<li><a href="#L431">eventlog_pause</a></li>
<li><a href="#L434">eventlog_resume</a></li>
<li><a href="#L495">null_tracker</a></li>
<li><a href="#L314">print_stat</a></li>
<li><a href="#L498">start</a></li>
<li><a href="#L527">stop</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L415">alarm</a></li>
<li><a href="#L457">allocation</a></li>
<li><a href="#L113">control</a></li>
<li><a href="#L19">stat</a></li>
<li><a href="#L474">tracker</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Damien Doligez, projet Para, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jacques-Henri Jourdan, projet Gallium, INRIA Paris&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1996-2016 Institut National de Recherche en Informatique&nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; et en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Memory management <a href="#L113" title="ocaml/stdlib/gc.mli:113">control</a> and <a href="hashtbl.ml.html#L228" title="ocaml/stdlib/hashtbl.ml:228">statistics</a>; finalised values. *)<br/></li>
<li></span><br/></li>
<li><a id="L19">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">stat</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Statement">{</span> <span class="ocamlLCIdentifier">minor_words</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of words allocated in the minor heap since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; the program was started. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">promoted_words</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of words allocated in the minor heap that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; survived <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> minor collection and were moved to the major heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; since the program was started. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">major_words</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of words allocated in the major heap, including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; the promoted words, since the program was started. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">minor_collections</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of minor collections since the program was started. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">major_collections</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of major collection cycles completed since the program<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; was started. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">heap_words</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Total <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the major heap, in words. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">heap_chunks</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of contiguous pieces of memory that <a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> up the major heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; This metrics is currently not available in OCaml 5: the <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; always [0]. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">live_words</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of words of live <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> in the major heap, including the header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; words.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Note that &quot;live&quot; words refers to every word in the major heap that isn'<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; currently known to be collectable, which includes words that have become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; unreachable by the program after the <a href="#L498" title="ocaml/stdlib/gc.mli:498">start</a> of the previous gc <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; It is typically much simpler and more predictable to call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; {!Gc.full_major} (or {!Gc.compact}) then computing gc <a href="camlinternalOO.ml.html#L607" title="ocaml/stdlib/camlinternalOO.ml:607">stats</a>, as then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; &quot;live&quot; words has the simple meaning of &quot;reachable by the program&quot;. One<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; caveat is that <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single call to {!Gc.full_major} will not reclaim values<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; that have <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> finaliser from {!Gc.finalise} (this does not apply to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; {!Gc.finalise_last}). If this caveat matters, simply call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; {!Gc.full_major} twice instead of <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">live_blocks</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of live blocks in the major heap.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; See [live_words] for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> caveat about what &quot;live&quot; means. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">free_words</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of words in the free list. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">free_blocks</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of blocks in the free list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; This metrics is currently not available in OCaml 5: the <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; always [0]. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">largest_free</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Size (in words) of the largest block in the free list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; This metrics is currently not available in OCaml 5: the <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; is always [0]. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">fragments</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of wasted words due to fragmentation.&nbsp; These are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; 1-words free blocks placed between two live blocks.&nbsp; They<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; are not available for <a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a>. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">compactions</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of heap compactions since the program was started. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">top_heap_words</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Maximum <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> reached by the major heap, in words. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">stack_size</span>: <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Current <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a>, in words.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; This metrics is currently not available in OCaml 5: the <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; always [0].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">forced_major_collections</span>: <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Number of forced full major collections completed since the program<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; was started.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.12 *)<br/></li>
<li></span><span class="Statement">}<br/></li>
<li></span><span class="Comment">(** The memory management counters are returned in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="#L19" title="ocaml/stdlib/gc.mli:19">stat</a>] record. These<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; counters give values for the whole program.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The total amount of memory allocated by the program since it was started<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is (in words) [minor_words + major_words - promoted_words].&nbsp; Multiply by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the word <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> (4 on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 32-bit machine, 8 on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 64-bit machine) to <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the number of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L113">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">control</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Statement">{</span> <span class="ocamlLCIdentifier">minor_heap_size</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** The <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> (in words) of the minor heap.&nbsp; Changing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; this parameter will trigger <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> minor collection. The total <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; minor heap used by this program is the sum of the heap sizes of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; active domains. Default: 256k. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">major_heap_increment</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** How much to <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> to the major heap when increasing it. If this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; number is less than or <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to 1000, it is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> percentage of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> heap <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. setting it to 100 will double the heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> at each increase). If it is more than 1000, it is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fixed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; number of words that will be added to the heap. Default: 15. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">space_overhead</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** The major GC speed is computed from this parameter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; This is the memory that will be &quot;wasted&quot; because the GC does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; immediately collect unreachable blocks.&nbsp; It is expressed as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; percentage of the memory used for live <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; The GC will work more (use more CPU time and collect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; blocks more eagerly) if [space_overhead] is smaller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Default: 120. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">verbose</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** This value controls the GC messages on standard <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; It is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sum of <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> of the following flags, to <a href="printexc.ml.html#L86" title="ocaml/stdlib/printexc.ml:86">print</a> messages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; on the corresponding events:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x001] Start and end of major GC <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x002] Minor collection and major GC <a href="bigarray.ml.html#L198" title="ocaml/stdlib/bigarray.ml:198">slice</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x004] Growing and shrinking of the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x008] Resizing of stacks and memory manager <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x010] Heap compaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x020] Change of GC parameters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x040] Computation of major GC <a href="bigarray.ml.html#L198" title="ocaml/stdlib/bigarray.ml:198">slice</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x080] Calling of finalisation functions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x100] Bytecode executable and shared library search at <a href="#L498" title="ocaml/stdlib/gc.mli:498">start</a>-up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x200] Computation of compaction-triggering condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; - [0x400] Output GC <a href="hashtbl.ml.html#L228" title="ocaml/stdlib/hashtbl.ml:228">statistics</a> at program exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Default: 0. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">max_overhead</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Heap compaction is triggered when the estimated amount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; of &quot;wasted&quot; memory is more than [max_overhead] percent of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; amount of live <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.&nbsp; If [max_overhead] is <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to 0, heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; compaction is triggered at the end of each major GC <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; (this setting is intended for testing purposes only).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; If [max_overhead &gt;= 1000000], compaction is never triggered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; If compaction is permanently disabled, it is strongly suggested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; to <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> [allocation_policy] to 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Default: 500. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">stack_limit</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** The maximum <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the fiber stacks (in words).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Default: 1024k. *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">allocation_policy</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** The policy used for allocating in the major heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Possible values are 0, 1 and 2.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - 0 is the next-fit policy, which is usually fast but can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> in fragmentation, increasing memory consumption.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - 1 is the first-fit policy, which avoids fragmentation but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has corner cases (in certain realistic workloads) where it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is sensibly slower.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; - 2 is the best-fit policy, which is fast and avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentation. In our experiments it is faster and uses less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memory than both next-fit and first-fit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (since OCaml 4.10)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; The default is best-fit.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; On <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> example that was known to be bad for next-fit and first-fit,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; next-fit takes 28s using 855Mio of memory,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; first-fit takes 47s using 566Mio of memory,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; best-fit takes 27s using 545Mio of memory.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Note: If you change to next-fit, you may need to reduce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; the [space_overhead] setting, for example using [80] instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; of the default [120] which is tuned for best-fit. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; your program will need more memory.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Note: changing the <a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a> policy at run-time forces<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> heap compaction, which is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> lengthy operation unless the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; heap is small (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. at the <a href="#L498" title="ocaml/stdlib/gc.mli:498">start</a> of the program).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Default: 2.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 3.11 *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">window_size</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** The <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the window used by the major GC for smoothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; out variations in its workload. This is an integer between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; 1 and 50.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Default: 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">custom_major_ratio</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Target ratio of floating garbage to major heap <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; out-of-heap memory held by custom values located in the major<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; heap. The GC speed is adjusted to try to use this much memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; for dead values that are not yet collected. Expressed as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; percentage of major heap <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. The default value keeps the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; out-of-heap floating garbage about the same <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; in-heap overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Note: this only applies to values allocated with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [caml_alloc_custom_mem] (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. bigarrays).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Default: 44.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">custom_minor_ratio</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Bound on floating garbage for out-of-heap memory held by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; custom values in the minor heap. A minor GC is triggered when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; this much memory is held by custom values located in the minor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; heap. Expressed as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> percentage of minor heap <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Note: this only applies to values allocated with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [caml_alloc_custom_mem] (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. bigarrays).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Default: 100.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="ocamlLCIdentifier">custom_minor_max_size</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">(** Maximum amount of out-of-heap memory for each custom value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; allocated in the minor heap. When <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> custom value is allocated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; on the minor heap and holds more than this many <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>, only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; this value is counted against [custom_minor_ratio] and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; rest is directly counted against [custom_major_ratio].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Note: this only applies to values allocated with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; [caml_alloc_custom_mem] (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. bigarrays).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Default: 8192 <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span>&nbsp; <span class="Statement">}<br/></li>
<li></span><span class="Comment">(** The GC parameters are given as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="#L113" title="ocaml/stdlib/gc.mli:113">control</a>] record.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; these parameters can also be initialised by setting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; OCAMLRUNPARAM environment variable.&nbsp; See the documentation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [ocamlrun]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="#L19" title="ocaml/stdlib/gc.mli:19">stat</a></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L19" title="ocaml/stdlib/gc.mli:19">stat</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_stat&quot;<br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> values of the memory management counters in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L19" title="ocaml/stdlib/gc.mli:19">stat</a>] record that represent the program'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> total memory <a href="camlinternalOO.ml.html#L607" title="ocaml/stdlib/camlinternalOO.ml:607">stats</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This function causes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> full major collection. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">quick_stat</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L19" title="ocaml/stdlib/gc.mli:19">stat</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_quick_stat&quot;<br/></li>
<li></span><span class="Comment">(** Same as [<a href="#L19" title="ocaml/stdlib/gc.mli:19">stat</a>] except that [live_words], [live_blocks], [free_words],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [free_blocks], [largest_free], and [fragments] are <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to 0. Due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; per-domain buffers it may only represent the <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a> of the program'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; total memory <a href="arg.ml.html#L117" title="ocaml/stdlib/arg.ml:117">usage</a> since the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> minor collection. This function is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; much faster than [<a href="#L19" title="ocaml/stdlib/gc.mli:19">stat</a>] because it does not need to trigger <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; major collection. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">counters</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">*</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">*</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_counters&quot;<br/></li>
<li></span><span class="Comment">(** Return [(minor_words, promoted_words, major_words)] for the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; domain or potentially previous domains.&nbsp; This function is as fast as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [quick_stat]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">minor_words</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">])<br/></li>
<li></span>&nbsp; <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_minor_words&quot;</span> <span class="Constant">&quot;caml_gc_minor_words_unboxed&quot;<br/></li>
<li></span><span class="Comment">(** Number of words allocated in the minor heap by this domain or potentially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; previous domains. This number is accurate in byte-code programs, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; only an approximation in programs compiled to native code.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; In native code this function does not allocate.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.04 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L113" title="ocaml/stdlib/gc.mli:113">control</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_get&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="ocamlLCIdentifier">unsynchronized_access<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">&quot;GC parameters are <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> mutable global <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>.&quot;<br/></li>
<li></span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> values of the GC parameters in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="#L113" title="ocaml/stdlib/gc.mli:113">control</a>] record. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span> : <span class="ocamlLCIdentifier"><a href="#L113" title="ocaml/stdlib/gc.mli:113">control</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_set&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">alert</span> <span class="ocamlLCIdentifier">unsynchronized_access<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">&quot;GC parameters are <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> mutable global <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>.&quot;<br/></li>
<li></span><span class="Statement">]<br/></li>
<li></span> <span class="Comment">(** [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] changes the GC parameters according to the [<a href="#L113" title="ocaml/stdlib/gc.mli:113">control</a>] record [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The normal <a href="arg.ml.html#L117" title="ocaml/stdlib/arg.ml:117">usage</a> is: [Gc.<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> { (Gc.<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a>()) with Gc.verbose = 0x00d }] *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">minor</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_minor&quot;<br/></li>
<li></span><span class="Comment">(** Trigger <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> minor collection. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">major_slice</span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_major_slice&quot;<br/></li>
<li></span><span class="Comment">(** [major_slice <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Do <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> minor collection and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.ml.html#L198" title="ocaml/stdlib/bigarray.ml:198">slice</a> of major collection. [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="bigarray.ml.html#L198" title="ocaml/stdlib/bigarray.ml:198">slice</a>: the GC will do enough work to free (on average)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] words of memory. If [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] = 0, the GC will try to do enough work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to <a href="in_channel.ml.html#L108" title="ocaml/stdlib/in_channel.ml:108">ensure</a> that the next automatic <a href="bigarray.ml.html#L198" title="ocaml/stdlib/bigarray.ml:198">slice</a> has no work to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; This function returns an unspecified integer (currently: 0). *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">major</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_major&quot;<br/></li>
<li></span><span class="Comment">(** Do <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> minor collection and finish the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> major collection <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">full_major</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_full_major&quot;<br/></li>
<li></span><span class="Comment">(** Do <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> minor collection, finish the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> major collection <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and perform <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> complete new <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a>.&nbsp; This will collect all currently<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; unreachable blocks. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">compact</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Statement">=</span> <span class="Constant">&quot;caml_gc_compaction&quot;<br/></li>
<li></span><span class="Comment">(** Perform <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> full major collection and compact the heap.&nbsp; Note that heap<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; compaction is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> lengthy operation. *)<br/></li>
<li></span><br/></li>
<li><a id="L314">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">print_stat</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Print the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> values of the memory management counters (in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; human-readable form) of the total program into the channel argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L318">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">allocated_bytes</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** Return the number of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> allocated by this domain and potentially<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> previous domain. It is returned as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>] to avoid overflow problems<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; with [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] on 32-bit machines. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">get_minor_free</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_get_minor_free&quot;<br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the free space inside the minor heap of this<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; domain.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier">finalise</span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [finalise f <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] registers [f] as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> finalisation function for [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] must be heap-allocated.&nbsp; [f] will be called with [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; argument at <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> point between the first time [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] becomes unreachable<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (including through weak pointers) and the time [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] is collected by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the GC. Several functions can<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; be registered for the same value, or even several instances of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; same function.&nbsp; Each instance will be called <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> (or never,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if the program terminates <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] becomes unreachable).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The GC will call the finalisation functions in the order of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; deallocation.&nbsp; When several values become unreachable at the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; same time (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. during the same GC <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a>), the finalisation<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; functions will be called in the reverse order of the corresponding<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; calls to [finalise].&nbsp; If [finalise] is called in the same order<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as the values are allocated, that means each value is finalised<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> the values it depends upon.&nbsp; Of course, this becomes<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; false if additional dependencies are introduced by assignments.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; In the presence of multiple OCaml threads it should be assumed that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; any particular finaliser may be executed in any of the threads.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Anything reachable from the <a href="camlinternalOO.ml.html#L59" title="ocaml/stdlib/camlinternalOO.ml:59">closure</a> of finalisation functions<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is considered reachable, so the following code will not work<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as expected:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - [ let <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> = ... in Gc.finalise (fun _ -&gt; ...<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>...) <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> ]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Instead you should <a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> sure that [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] is not in the <a href="camlinternalOO.ml.html#L59" title="ocaml/stdlib/camlinternalOO.ml:59">closure</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the finalisation function by writing:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - [ let f = fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; ...&nbsp; let <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> = ... in Gc.finalise f <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> ]<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The [f] function can use all features of OCaml, including<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; assignments that <a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> the value reachable again.&nbsp; It can also<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="in_channel.ml.html#L157" title="ocaml/stdlib/in_channel.ml:157">loop</a> <a href="seq.ml.html#L279" title="ocaml/stdlib/seq.ml:279">forever</a> (in this case, the other<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; finalisation functions will not be called during the execution of f,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; unless it calls [finalise_release]).<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; It can call [finalise] on [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] or other values to <a href="callback.ml.html#L21" title="ocaml/stdlib/callback.ml:21">register</a> other<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; functions or even itself.&nbsp; It can raise an exception; in this case<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the exception will interrupt whatever the program was doing when<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the function was called.<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp;&nbsp; [finalise] will raise [Invalid_argument] if [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] is not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; guaranteed to be heap-allocated.&nbsp; Some examples of values that are not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; heap-allocated are integers, constant constructors, booleans,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> array, the <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> list, the unit value.&nbsp; The exact list<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of what is heap-allocated or not is implementation-dependent.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Some constant values can be heap-allocated but never deallocated<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; during the lifetime of the program, for example <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of integer<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; constants; this is also implementation-dependent.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Note that values of types [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>] are sometimes allocated and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; sometimes not, so finalising them is unsafe, and [finalise] will<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; also raise [Invalid_argument] for them. Values of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> Lazy.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (for any ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]) are like [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>] in this respect, except that the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; compiler sometimes optimizes them in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> way that prevents [finalise]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; from detecting them. In this case, it will not raise<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [Invalid_argument], but you should still avoid calling [finalise]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; on lazy values.<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The results of calling {!String.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a>}, {!Bytes.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a>}, {!Bytes.<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a>},<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Array.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a>}, and {!val:Stdlib.<a href="stdlib.ml.html#L237" title="ocaml/stdlib/stdlib.ml:237">ref</a>} are guaranteed to be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; heap-allocated and non-constant except when the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> argument is [0].<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier">finalise_last</span> : <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** same as {!finalise} except the value is not given as argument. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; you can'<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> use the given value for the computation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; finalisation function. The benefit is that the function is called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; after the value is unreachable for the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> time instead of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; first time. So contrary to {!finalise} the value will never be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; reachable again or used again. In particular every weak pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and ephemeron that contained this value as <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> or <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> is unset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> running the finalisation function. Moreover the finalisation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; functions attached with {!finalise} are always called <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; finalisation functions attached with {!finalise_last}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.04<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier">finalise_release</span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** A finalisation function may call [finalise_release] to tell the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; GC that it can launch the next finalisation function without waiting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> to <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L415">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">alarm</span><br/></li>
<li></span><span class="Comment">(** An <a href="#L415" title="ocaml/stdlib/gc.mli:415">alarm</a> is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> piece of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> that calls <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> user function at the end of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; each major GC <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a>.&nbsp; The following functions are provided to <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and delete alarms. *)<br/></li>
<li></span><br/></li>
<li><a id="L420">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">create_alarm</span></span> : <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L415" title="ocaml/stdlib/gc.mli:415">alarm</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L420" title="ocaml/stdlib/gc.mli:420">create_alarm</a> f] will arrange for [f] to be called at the end of each<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; major GC <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a>, not caused by [f] itself, starting with the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a> or the next <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; A value of type [<a href="#L415" title="ocaml/stdlib/gc.mli:415">alarm</a>] is returned that you can<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; use to call [<a href="#L427" title="ocaml/stdlib/gc.mli:427">delete_alarm</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L427">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">delete_alarm</span></span> : <span class="ocamlLCIdentifier"><a href="#L415" title="ocaml/stdlib/gc.mli:415">alarm</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="#L427" title="ocaml/stdlib/gc.mli:427">delete_alarm</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] will <a href="#L527" title="ocaml/stdlib/gc.mli:527">stop</a> the calls to the function associated<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. Calling [<a href="#L427" title="ocaml/stdlib/gc.mli:427">delete_alarm</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] again has no effect. *)<br/></li>
<li></span><br/></li>
<li><a id="L431">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">eventlog_pause</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">ocaml</span>.<span class="ocamlLCIdentifier">deprecated</span> <span class="Constant">&quot;Use Runtime_events.pause instead.&quot;</span><span class="Statement">]<br/></li>
<li></span><br/></li>
<li><a id="L434">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">eventlog_resume</span></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">ocaml</span>.<span class="ocamlLCIdentifier">deprecated</span> <span class="Constant">&quot;Use Runtime_events.resume instead.&quot;</span><span class="Statement">]<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** [Memprof] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sampling <a href="lexing.mli.html#L211" title="ocaml/stdlib/lexing.mli:211">engine</a> for allocated memory words. Every<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; allocated word has <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> probability of being sampled <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; configurable sampling rate. Once <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> block is sampled, it becomes<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; tracked. A tracked block triggers <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> user-defined callback as soon<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as it is allocated, promoted or deallocated.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Since blocks are composed of several words, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> block can potentially<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; be sampled several times. If <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> block is sampled several times, then<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; each of the callback is called <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> for each event of this block:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the multiplicity is given in the [n_samples] <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a>] structure.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This <a href="lexing.mli.html#L211" title="ocaml/stdlib/lexing.mli:211">engine</a> makes it possible to implement <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> low-overhead memory<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; profiler as an OCaml library.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Note: this API is EXPERIMENTAL. It may change without prior<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; notice. *)<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Memprof</span><span class="ocamlPreDef"> :<br/></li>
<li></span><span class="ocamlPreDef">&nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="gc.ml.html#L126" title="ocaml/stdlib/gc.ml:126">allocation_source</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">Normal</span><span class="ocamlSig"> </span><span class="Statement">|</span><span class="ocamlSig"> </span><span class="Constant">Marshal</span><span class="ocamlSig"> </span><span class="Statement">|</span><span class="ocamlSig"> </span><span class="Constant">Custom<br/></li>
<li><a id="L457">&#x200c;</a></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">allocation</span></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Statement">private<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">{</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">n_samples</span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The number of samples in this block (&gt;= 1). *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier"><a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the block, in words, excluding the header. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">source</span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="gc.ml.html#L126" title="ocaml/stdlib/gc.ml:126">allocation_source</a></span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">callstack</span><span class="ocamlSig"> : </span><span class="PreProc">Printexc</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="printexc.ml.html#L104" title="ocaml/stdlib/printexc.ml:104">raw_backtrace</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The callstack for the <a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a>. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">}<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** The type of metadata associated with allocations. This is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; type of records passed to the callback triggered by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; sampling of an <a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L474">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier">minor</span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">major</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">tracker</span></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Statement">{<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">alloc_minor</span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">minor</span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">alloc_major</span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">major</span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">promote</span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier">minor</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">major</span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">dealloc_minor</span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier">minor</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">dealloc_major</span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier">major</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">}<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(**<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; A [('minor, 'major) <a href="#L474" title="ocaml/stdlib/gc.mli:474">tracker</a>] describes how memprof should track<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; sampled blocks over their lifetime, keeping <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> user-defined piece<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; of metadata for each of them: ['minor] is the type of metadata<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; to keep for minor blocks, and ['major] the type of metadata<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; for major blocks.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; When using threads, it is guaranteed that <a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a> callbacks are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; always run in the thread where the <a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a> takes place.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; If an <a href="#L457" title="ocaml/stdlib/gc.mli:457">allocation</a>-tracking or promotion-tracking function returns [None],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; memprof stops tracking the corresponding value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L495">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">null_tracker</span></span><span class="ocamlSig">: </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier">minor</span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">major</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="#L474" title="ocaml/stdlib/gc.mli:474">tracker</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Default callbacks simply <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> [None] or [()] *)<br/></li>
<li></span><br/></li>
<li><a id="L498">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">start</span></span><span class="ocamlSig"> :<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">sampling_rate</span><span class="ocamlSig">:</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">?</span><span class="Identifier">callstack_size</span><span class="ocamlSig">:</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier">minor</span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">major</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="#L474" title="ocaml/stdlib/gc.mli:474">tracker</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Start the sampling with the given parameters. Fails if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; sampling is already active.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; The parameter [sampling_rate] is the sampling rate in samples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; per word (including headers). Usually, with cheap callbacks, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; rate of 1e-4 has no visible effect on performance, and 1e-3<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; causes the program to run <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> few percent slower<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; The parameter [callstack_size] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the callstack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; recorded at every sample. Its default is [<a href="int32.ml.html#L52" title="ocaml/stdlib/int32.ml:52">max_int</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; The parameter [<a href="#L474" title="ocaml/stdlib/gc.mli:474">tracker</a>] determines how to track sampled blocks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; over their lifetime in the minor and major heap.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Sampling is temporarily disabled when calling <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; for the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> thread. So they do not need to be re-entrant if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; the program is single-threaded. However, if threads are used,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; it is possible that <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> context switch occurs during <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> callback,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; in this case the callback functions must be re-entrant.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; Note that the callback can be postponed slightly after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; actual event. The callstack passed to the callback is always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; accurate, but the program <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a> may have evolved. *)<br/></li>
<li></span><br/></li>
<li><a id="L527">&#x200c;</a><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">stop</span></span><span class="ocamlSig"> : </span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Comment">(** Stop the sampling. Fails if sampling is not active.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; This function does not allocate memory.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; All the already tracked blocks are discarded. If there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; pending postponed callbacks, they may be discarded.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Calling [<a href="#L527" title="ocaml/stdlib/gc.mli:527">stop</a>] when <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> callback is running can lead to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; callbacks not being called even though <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> events happened. *)<br/></li>
<li></span><span class="PreProc">end<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
