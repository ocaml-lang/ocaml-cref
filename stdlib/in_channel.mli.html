<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/in_channel.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/in_channel.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L73">close</a></li>
<li><a href="#L78">close_noerr</a></li>
<li><a href="#L150">fold_lines</a></li>
<li><a href="#L126">input</a></li>
<li><a href="#L109">input_all</a></li>
<li><a href="#L87">input_byte</a></li>
<li><a href="#L83">input_char</a></li>
<li><a href="#L91">input_line</a></li>
<li><a href="#L115">input_lines</a></li>
<li><a href="#L199">isatty</a></li>
<li><a href="#L180">length</a></li>
<li><a href="#L44">open_bin</a></li>
<li><a href="#L54">open_gen</a></li>
<li><a href="#L48">open_text</a></li>
<li><a href="#L170">pos</a></li>
<li><a href="#L137">really_input</a></li>
<li><a href="#L101">really_input_string</a></li>
<li><a href="#L165">seek</a></li>
<li><a href="#L187">set_binary_mode</a></li>
<li><a href="#L41">stdin</a></li>
<li><a href="#L60">with_open_bin</a></li>
<li><a href="#L69">with_open_gen</a></li>
<li><a href="#L65">with_open_text</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L29">open_flag</a></li>
<li><a href="#L26">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2021 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Input channels.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This module provides functions for working with <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channels.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; See {{!examples} the example section} below.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:channels Channels} *)<br/></li>
<li></span><br/></li>
<li><a id="L26">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">t</span></span> <span class="Statement">=</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a><br/></li>
<li></span><span class="Comment">(** The type of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L29">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">open_flag</span></span> <span class="Statement">=</span> <span class="PreProc">Stdlib</span>.<span class="ocamlLCIdentifier"><span class="linkable">open_flag</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_rdonly</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for reading. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_wronly</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for writing. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_append</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open for appending: always write at end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_creat</span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> if it does not exist. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_trunc</span>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> if it already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_excl</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** fail if Open_creat and the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> already <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_binary</span>&nbsp; &nbsp; &nbsp; <span class="Comment">(** open in binary mode (no conversion). *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_text</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** open in text mode (may perform conversions). *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Open_nonblock</span>&nbsp; &nbsp; <span class="Comment">(** open in non-blocking mode. *)<br/></li>
<li></span><span class="Comment">(** Opening modes for {!<a href="in_channel.ml.html#L32" title="ocaml/stdlib/in_channel.ml:32">open_gen</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L41">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">stdin</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** The standard <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> for the process. *)<br/></li>
<li></span><br/></li>
<li><a id="L44">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_bin</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Open the named <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> for reading, and <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel on that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, positioned at the beginning of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L48">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_text</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Same as {!<a href="in_channel.ml.html#L30" title="ocaml/stdlib/in_channel.ml:30">open_bin</a>}, but the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is opened in text mode, so that newline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; translation takes place during reads. On operating systems that do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; distinguish between text mode and binary mode, this function behaves like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="in_channel.ml.html#L30" title="ocaml/stdlib/in_channel.ml:30">open_bin</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L54">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">open_gen</span></span> : <span class="ocamlLCIdentifier"><a href="in_channel.ml.html#L18" title="ocaml/stdlib/in_channel.ml:18">open_flag</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L32" title="ocaml/stdlib/in_channel.ml:32">open_gen</a> mode perm filename] opens the named <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> for reading, as described<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; above. The extra arguments [mode] and [perm] specify the opening mode and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> permissions.&nbsp; {!<a href="in_channel.ml.html#L31" title="ocaml/stdlib/in_channel.ml:31">open_text</a>} and {!<a href="in_channel.ml.html#L30" title="ocaml/stdlib/in_channel.ml:30">open_bin</a>} are special cases of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; function. *)<br/></li>
<li></span><br/></li>
<li><a id="L60">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">with_open_bin</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** [<a href="out_channel.mli.html#L65" title="ocaml/stdlib/out_channel.mli:65">with_open_bin</a> fn f] opens <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> channel [ic] on <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> [fn] and returns [f<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ic]. After [f] returns, either with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value or by raising an exception, [ic]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is guaranteed to be closed. *)<br/></li>
<li></span><br/></li>
<li><a id="L65">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">with_open_text</span></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Like {!<a href="out_channel.mli.html#L65" title="ocaml/stdlib/out_channel.mli:65">with_open_bin</a>}, but the channel is opened in text mode (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="in_channel.ml.html#L31" title="ocaml/stdlib/in_channel.ml:31">open_text</a>}). *)<br/></li>
<li></span><br/></li>
<li><a id="L69">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">with_open_gen</span></span> : <span class="ocamlLCIdentifier"><a href="in_channel.ml.html#L18" title="ocaml/stdlib/in_channel.ml:18">open_flag</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Like {!<a href="out_channel.mli.html#L65" title="ocaml/stdlib/out_channel.mli:65">with_open_bin</a>}, but can specify the opening mode and <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> permission,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in case the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> must be created (see {!<a href="in_channel.ml.html#L32" title="ocaml/stdlib/in_channel.ml:32">open_gen</a>}). *)<br/></li>
<li></span><br/></li>
<li><a id="L73">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Close the given channel.&nbsp; Input functions raise <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [Sys_error] exception when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; they are applied to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> closed <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel, except {!<a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a>}, which does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; nothing when applied to an already closed channel. *)<br/></li>
<li></span><br/></li>
<li><a id="L78">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">close_noerr</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a>}, but ignore all <a href="printexc.ml.html#L299" title="ocaml/stdlib/printexc.ml:299">errors</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> Input} *)<br/></li>
<li></span><br/></li>
<li><a id="L83">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_char</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Read <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> character from the given <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> channel.&nbsp; Returns [None] if there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; are no more characters to read. *)<br/></li>
<li></span><br/></li>
<li><a id="L87">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_byte</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Same as {!<a href="stdlib.mli.html#L1092" title="ocaml/stdlib/stdlib.mli:1092">input_char</a>}, but <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the 8-bit integer representing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; character. Returns [None] if the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> was reached. *)<br/></li>
<li></span><br/></li>
<li><a id="L91">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_line</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L64" title="ocaml/stdlib/in_channel.ml:64">input_line</a> ic] reads characters from [ic] until <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> newline or the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached.&nbsp; Returns the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> of all characters read, without the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; newline (if any).&nbsp; Returns [None] if the end of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> has been reached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; In particular, this will be the case if the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> line of <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; A newline is the character [\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] unless the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is open in text mode and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Sys.<a href="sys.mli.html#L163" title="ocaml/stdlib/sys.mli:163">win32</a>} is [true] in which case it is the sequence of characters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [\<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L101">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">really_input_string</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L76" title="ocaml/stdlib/in_channel.ml:76">really_input_string</a> ic <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] reads [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters from channel [ic] and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; returns them in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>.&nbsp; Returns [None] if the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters have been read.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the same channel is read concurrently by multiple threads, the returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is not guaranteed to contain contiguous characters from the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L109">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_all</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L131" title="ocaml/stdlib/in_channel.ml:131">input_all</a> ic] reads all remaining <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> from [ic].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the same channel is read concurrently by multiple threads, the returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is not guaranteed to contain contiguous characters from the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L115">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input_lines</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Type">list<br/></li>
<li></span><span class="Comment">(** [<a href="#L115" title="ocaml/stdlib/in_channel.mli:115">input_lines</a> ic] reads lines using {!<a href="in_channel.ml.html#L64" title="ocaml/stdlib/in_channel.ml:64">input_line</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; until the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached.&nbsp; It returns the list of all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; lines read, in the order they were read.&nbsp; The newline characters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; that terminate lines are not included in the returned strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Empty lines produce <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> strings.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:advanced_input Advanced <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>}*)<br/></li>
<li></span><br/></li>
<li><a id="L126">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">input</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> ic <a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a> <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] reads up to [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters from the given channel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [ic], storing them in byte sequence [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>], starting at character number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>]. It returns the actual number of characters read, between 0 and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (inclusive). A <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> value of 0 means that the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> was reached.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Use {!<a href="in_channel.ml.html#L71" title="ocaml/stdlib/in_channel.ml:71">really_input</a>} to read exactly [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L137">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">really_input</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L71" title="ocaml/stdlib/in_channel.ml:71">really_input</a> ic <a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a> <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] reads [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters from channel [ic],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; storing them in byte sequence [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>], starting at character number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Returns [None] if the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; been read.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the same channel is read concurrently by multiple threads, the <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; read by [<a href="in_channel.ml.html#L71" title="ocaml/stdlib/in_channel.ml:71">really_input</a>] are not guaranteed to be contiguous.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid range of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="in_channel.ml.html#L146" title="ocaml/stdlib/in_channel.ml:146">buf</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L150">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_lines</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L178" title="ocaml/stdlib/in_channel.ml:178">fold_lines</a> f <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> ic] reads lines from [ic] using {!<a href="in_channel.ml.html#L64" title="ocaml/stdlib/in_channel.ml:64">input_line</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; until the end of <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached, and successively passes each line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to function [f] in the style of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; More precisely, if lines [<a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>, ..., lN] are read,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="in_channel.ml.html#L178" title="ocaml/stdlib/in_channel.ml:178">fold_lines</a> f <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> ic] computes [f (... (f (f <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="array.ml.html#L410" title="ocaml/stdlib/array.ml:410">l1</a>) <a href="array.ml.html#L411" title="ocaml/stdlib/array.ml:411">l2</a>) ...) lN].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If [f] has no side effects, this is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [List.<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> f <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> (In_channel.<a href="#L115" title="ocaml/stdlib/in_channel.mli:115">input_lines</a> ic)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; but is more efficient since it does not construct the list of all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; lines read.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:seeking Seeking} *)<br/></li>
<li></span><br/></li>
<li><a id="L165">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">seek</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="out_channel.mli.html#L128" title="ocaml/stdlib/out_channel.mli:128">seek</a> chan <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] sets the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> reading <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] for channel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [chan]. This works only for regular files. On files of other kinds, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; behavior is unspecified. *)<br/></li>
<li></span><br/></li>
<li><a id="L170">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">pos</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> reading <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> for the given channel.&nbsp; For files opened<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in text mode under Windows, the returned <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> is approximate (owing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; end-of-line conversion); in particular, saving the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>}, then going back to this <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> using {!<a href="out_channel.mli.html#L128" title="ocaml/stdlib/out_channel.mli:128">seek</a>} will not work.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; this programming idiom to work reliably and portably, the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; opened in binary mode. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:attributes Attributes} *)<br/></li>
<li></span><br/></li>
<li><a id="L180">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">length</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L182" title="ocaml/stdlib/bigarray.mli:182">int64</a><br/></li>
<li></span><span class="Comment">(** Return the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> (number of characters) of the regular <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> on which the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; given channel is opened.&nbsp; If the channel is opened on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> that is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; regular <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>, the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is meaningless.&nbsp; The returned <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> does not <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; into account the end-of-line translations that can be performed when reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; from <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> channel opened in text mode. *)<br/></li>
<li></span><br/></li>
<li><a id="L187">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set_binary_mode</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="in_channel.ml.html#L183" title="ocaml/stdlib/in_channel.ml:183">set_binary_mode</a> ic true] sets the channel [ic] to binary mode: no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; translations <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place during <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="in_channel.ml.html#L183" title="ocaml/stdlib/in_channel.ml:183">set_binary_mode</a> ic false] sets the channel [ic] to text mode: depending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; on the operating system, <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> translations may <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place during <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; instance, under Windows, end-of-lines will be translated from [\<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This function has no effect under operating systems that do not distinguish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; between text mode and binary mode. *)<br/></li>
<li></span><br/></li>
<li><a id="L199">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">isatty</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="out_channel.mli.html#L179" title="ocaml/stdlib/out_channel.mli:179">isatty</a> ic] is [true] if [ic] refers to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> terminal or console window,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [false] otherwise.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:examples Examples}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Reading the <a href="buffer.ml.html#L46" title="ocaml/stdlib/buffer.ml:46">contents</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let read_file <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> = In_channel.<a href="out_channel.mli.html#L65" title="ocaml/stdlib/out_channel.mli:65">with_open_bin</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> In_channel.<a href="in_channel.ml.html#L131" title="ocaml/stdlib/in_channel.ml:131">input_all</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Reading <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> line from <a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let user_input () = In_channel.<a href="in_channel.ml.html#L64" title="ocaml/stdlib/in_channel.ml:64">input_line</a> In_channel.<a href="in_channel.ml.html#L29" title="ocaml/stdlib/in_channel.ml:29">stdin</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ]} *)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
