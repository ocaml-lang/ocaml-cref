<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/seq.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/seq.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L589">append</a></li>
<li><a href="#L330">compare</a></li>
<li><a href="#L596">concat</a></li>
<li><a href="#L608">concat_map</a></li>
<li><a href="#L354">cons</a></li>
<li><a href="#L410">cycle</a></li>
<li><a href="#L497">drop</a></li>
<li><a href="#L520">drop_while</a></li>
<li><a href="#L346">empty</a></li>
<li><a href="#L321">equal</a></li>
<li><a href="#L205">exists</a></li>
<li><a href="#L307">exists2</a></li>
<li><a href="#L452">filter</a></li>
<li><a href="#L459">filter_map</a></li>
<li><a href="#L213">find</a></li>
<li><a href="#L223">find_index</a></li>
<li><a href="#L234">find_map</a></li>
<li><a href="#L245">find_mapi</a></li>
<li><a href="#L605">flat_map</a></li>
<li><a href="#L164">fold_left</a></li>
<li><a href="#L270">fold_left2</a></li>
<li><a href="#L184">fold_lefti</a></li>
<li><a href="#L197">for_all</a></li>
<li><a href="#L289">for_all2</a></li>
<li><a href="#L399">forever</a></li>
<li><a href="#L526">group</a></li>
<li><a href="#L365">init</a></li>
<li><a href="#L640">interleave</a></li>
<li><a href="#L778">ints</a></li>
<li><a href="#L132">is_empty</a></li>
<li><a href="#L157">iter</a></li>
<li><a href="#L254">iter2</a></li>
<li><a href="#L423">iterate</a></li>
<li><a href="#L173">iteri</a></li>
<li><a href="#L150">length</a></li>
<li><a href="#L437">map</a></li>
<li><a href="#L627">map2</a></li>
<li><a href="#L672">map_product</a></li>
<li><a href="#L444">mapi</a></li>
<li><a href="#L541">memoize</a></li>
<li><a href="#L759">of_dispenser</a></li>
<li><a href="#L561">once</a></li>
<li><a href="#L733">partition</a></li>
<li><a href="#L711">partition_map</a></li>
<li><a href="#L658">product</a></li>
<li><a href="#L391">repeat</a></li>
<li><a href="#L350">return</a></li>
<li><a href="#L466">scan</a></li>
<li><a href="#L649">sorted_merge</a></li>
<li><a href="#L706">split</a></li>
<li><a href="#L485">take</a></li>
<li><a href="#L514">take_while</a></li>
<li><a href="#L767">to_dispenser</a></li>
<li><a href="#L575">transpose</a></li>
<li><a href="#L142">uncons</a></li>
<li><a href="#L377">unfold</a></li>
<li><a href="#L692">unzip</a></li>
<li><a href="#L615">zip</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L97">node</a></li>
<li><a href="#L90">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Simon Cruanes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2017 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Sequences.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; A sequence of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] can be thought of as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {b delayed list},<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that is, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list whose <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are computed only when they are demanded<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> consumer. This allows sequences to be produced and transformed<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; lazily (<a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element at <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> time) rather than eagerly (all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> at<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>). This also allows constructing conceptually infinite sequences.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] is defined as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> synonym for [unit -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> Seq.<a href="seq.ml.html#L18" title="ocaml/stdlib/seq.ml:18">node</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> function type: therefore, it is opaque. The consumer can {b<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; query} <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence in order to request the next element (if there is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>), but cannot otherwise inspect the sequence in any way.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Because it is opaque, the type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] does {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> not} reveal whether<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence is:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - {b persistent},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; which means that the sequence can be used as many times as desired,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; producing the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> every time,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; just like an immutable list; or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - {b ephemeral},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; which means that the sequence is not persistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Querying an ephemeral sequence might have an observable side effect,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; such as incrementing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> mutable <a href="camlinternalFormat.ml.html#L2432" title="ocaml/stdlib/camlinternalFormat.ml:2432">counter</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; As <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> common special case, an ephemeral sequence can be {b affine},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; which means that it must be queried at most <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; It also does {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> not} reveal whether the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the sequence are:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; - {b pre-computed and stored} in memory,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; which means that querying the sequence is cheap;<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - {b computed when first demanded and then stored} in memory,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; which means that querying the sequence <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> can be expensive,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; but querying the same sequence again is cheap; or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - {b re-computed every time they are demanded},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; which may or may not be cheap.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; It is up to the programmer to keep these distinctions in mind<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; so as to understand the time and space requirements of sequences.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; For the sake of simplicity, most of the documentation that follows<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is written under the implicit assumption that the sequences at hand<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are persistent.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; We normally do not point out {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> when} or {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> how many times}<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; each function is invoked, because that would be too verbose.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; For instance, in the description of [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>], we write:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; &quot;if [xs] is the sequence [x0; x1; ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs] is the sequence [f x0; f x1; ...]&quot;.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If we wished to be more explicit,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; we could point out that the transformation takes place on demand:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; that is, the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs] are computed only when they<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are demanded. In other words,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the definition [let ys = <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs] terminates immediately and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; does not invoke [f]. The function call [f x0] takes place only when the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; first element of [ys] is demanded, via the function call [ys()].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Furthermore, calling [ys()] twice causes [f x0] to be called twice<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as well. If <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> wishes for [f] to be applied at most <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> to each<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; element of [xs], even in scenarios where [ys] is queried more than <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; then <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> should use [let ys = <a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> (<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; As <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> general rule, the functions that build sequences, such as [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a>], [<a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a>], [<a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a>], etc., produce sequences whose <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; computed only on demand. The functions that eagerly consume sequences,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; such as [<a href="stack.ml.html#L53" title="ocaml/stdlib/stack.ml:53">is_empty</a>], [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a>], [<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>], [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>], [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; etc., are the functions that force computation to <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; When possible, we recommend using sequences rather than dispensers<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (functions of type [unit -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> option] that produce <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> upon<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; demand). Whereas sequences can be persistent or ephemeral, dispensers<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are always ephemeral, and are typically more difficult to work with<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; than sequences. Two conversion functions, {!<a href="seq.ml.html#L689" title="ocaml/stdlib/seq.ml:689">to_dispenser</a>} and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!<a href="#L759" title="ocaml/stdlib/seq.mli:759">of_dispenser</a>}, are provided.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><a id="L90">&#x200c;</a><span class="Statement">type</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><span class="linkable">t</span></span> <span class="Statement">=</span> <span class="Type">unit</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="seq.ml.html#L18" title="ocaml/stdlib/seq.ml:18">node</a><br/></li>
<li></span><span class="Comment">(** A sequence [xs] of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> delayed list of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. Such <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence is queried by performing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; application [xs()]. This function application returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="seq.ml.html#L18" title="ocaml/stdlib/seq.ml:18">node</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; allowing the caller to determine whether the sequence is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; or nonempty, and in the latter case, to obtain its head and tail. *)<br/></li>
<li></span><br/></li>
<li><a id="L97">&#x200c;</a><span class="Statement">and</span> +'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><span class="linkable">node</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Nil<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Cons</span> <span class="Statement">of</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Comment">(**)<br/></li>
<li></span><span class="Comment">(** A <a href="seq.ml.html#L18" title="ocaml/stdlib/seq.ml:18">node</a> is either [Nil], which means that the sequence is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; or [Cons (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, xs)], which means that [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the first element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of the sequence and that [xs] is the remainder of the sequence. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Consuming sequences} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(**<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The functions in this section consume their argument, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence, either<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; partially or completely:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - [<a href="stack.ml.html#L53" title="ocaml/stdlib/stack.ml:53">is_empty</a>] and [<a href="seq.ml.html#L91" title="ocaml/stdlib/seq.ml:91">uncons</a>] consume the sequence down to depth 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; That is, they demand the first argument of the sequence, if there is <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>], [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a>], [<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>], etc., consume the sequence all the way to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; its end. They terminate only if the sequence is finite.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a>], [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>], [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a>], etc. consume the sequence down to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> certain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; depth, which is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> priori unpredictable.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Similarly, among the functions that consume two sequences,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> can distinguish two groups:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - [<a href="seq.ml.html#L191" title="ocaml/stdlib/seq.ml:191">iter2</a>] and [<a href="seq.ml.html#L203" title="ocaml/stdlib/seq.ml:203">fold_left2</a>] consume both sequences all the way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; to the end, provided the sequences have the same <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - [<a href="seq.ml.html#L215" title="ocaml/stdlib/seq.ml:215">for_all2</a>], [<a href="seq.ml.html#L226" title="ocaml/stdlib/seq.ml:226">exists2</a>], [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>], [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] consume the sequences down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> certain depth, which is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> priori unpredictable.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The functions that consume two sequences can be applied to two sequences<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of distinct lengths: in that case, the excess <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in the longer<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; sequence are <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>. (It may be the case that <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> excess element is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; demanded, even though this element is not used.)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; None of the functions in this section is lazy. These functions<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; are consumers: they force <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> computation to <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place. *)<br/></li>
<li></span><br/></li>
<li><a id="L132">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">is_empty</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="stack.ml.html#L53" title="ocaml/stdlib/stack.ml:53">is_empty</a> xs] determines whether the sequence [xs] is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It is recommended that the sequence [xs] be persistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Indeed, [<a href="stack.ml.html#L53" title="ocaml/stdlib/stack.ml:53">is_empty</a> xs] demands the head of the sequence [xs],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; so, if [xs] is ephemeral, it may be the case that [xs] cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; be used any more after this call has taken place.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L142">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">uncons</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="Statement">)</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** If [xs] is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>, then [<a href="seq.ml.html#L91" title="ocaml/stdlib/seq.ml:91">uncons</a> xs] is [None].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [xs] is nonempty, then [<a href="seq.ml.html#L91" title="ocaml/stdlib/seq.ml:91">uncons</a> xs] is [Some (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, ys)] where [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; head of the sequence and [ys] its tail.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L150">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">length</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> xs] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequence [xs] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L157">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> f xs] invokes [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] successively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for every element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of the sequence [xs],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; from <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> to <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It terminates only if the sequence [xs] is finite. *)<br/></li>
<li></span><br/></li>
<li><a id="L164">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> f _ xs] invokes [f _ <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] successively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for every element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of the sequence [xs],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; from <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a> to <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; An accumulator of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is threaded through the calls to [f].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It terminates only if the sequence [xs] is finite. *)<br/></li>
<li></span><br/></li>
<li><a id="L173">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iteri</span></span> : <span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L170" title="ocaml/stdlib/bytesLabels.mli:170">iteri</a> f xs] invokes [f <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] successively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for every element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] located at <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] in the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It terminates only if the sequence [xs] is finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="bytesLabels.mli.html#L170" title="ocaml/stdlib/bytesLabels.mli:170">iteri</a> f xs] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> (fun (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>, <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>) -&gt; f <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>) (<a href="#L615" title="ocaml/stdlib/seq.mli:615">zip</a> (<a href="seq.ml.html#L701" title="ocaml/stdlib/seq.ml:701">ints</a> 0) xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L184">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_lefti</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L184" title="ocaml/stdlib/seq.mli:184">fold_lefti</a> f _ xs] invokes [f _ <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] successively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for every element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] located at <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] of the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; An accumulator of type ['b] is threaded through the calls to [f].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It terminates only if the sequence [xs] is finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="#L184" title="ocaml/stdlib/seq.mli:184">fold_lefti</a> f accu xs] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> (fun accu (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>, <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>) -&gt; f accu <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>) accu (<a href="#L615" title="ocaml/stdlib/seq.mli:615">zip</a> (<a href="seq.ml.html#L701" title="ocaml/stdlib/seq.ml:701">ints</a> 0) xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L197">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">for_all</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] determines whether all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of the sequence [xs]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; satisfy [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequence [xs] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L205">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exists</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> xs <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>] determines whether at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of the sequence [xs] satisfies [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequence [xs] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L213">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] returns [Some <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], where [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the first element of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence [xs] that satisfies [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], if there is such an element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It returns [None] if there is no such element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequence [xs] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L223">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_index</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L153" title="ocaml/stdlib/seq.ml:153">find_index</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] returns [Some <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>], where [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element of the sequence [xs] that satisfies [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], if there is such an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It returns [None] if there is no such element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequence [xs] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L234">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_map</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a> f xs] returns [Some y], where [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the first element of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence [xs] such that [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Some _], if there is such an element,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and where [y] is defined by [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Some y].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; It returns [None] if there is no such element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequence [xs] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L245">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">find_mapi</span></span> : <span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Same as [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a>], but the predicate is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The sequence [xs] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L254">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iter2</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type">unit</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L191" title="ocaml/stdlib/seq.ml:191">iter2</a> f xs ys] invokes [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] successively for every pair [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y)] of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> drawn synchronously from the sequences [xs] and [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the sequences [xs] and [ys] have different lengths, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; iteration stops as soon as <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> sequence is exhausted;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the excess <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in the other sequence are <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Iteration terminates only if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the sequences<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [xs] and [ys] is finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L191" title="ocaml/stdlib/seq.ml:191">iter2</a> f xs ys] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> (fun (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y) -&gt; f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y) (<a href="#L615" title="ocaml/stdlib/seq.mli:615">zip</a> xs ys)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L270">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fold_left2</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L203" title="ocaml/stdlib/seq.ml:203">fold_left2</a> f _ xs ys] invokes [f _ <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] successively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for every pair [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y)] of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> drawn synchronously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; from the sequences [xs] and [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; An accumulator of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is threaded through the calls to [f].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the sequences [xs] and [ys] have different lengths, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; iteration stops as soon as <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> sequence is exhausted;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the excess <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in the other sequence are <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Iteration terminates only if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the sequences<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [xs] and [ys] is finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L203" title="ocaml/stdlib/seq.ml:203">fold_left2</a> f accu xs ys] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> (fun accu (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y) -&gt; f accu <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y) (<a href="#L615" title="ocaml/stdlib/seq.mli:615">zip</a> xs ys)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L289">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">for_all2</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L215" title="ocaml/stdlib/seq.ml:215">for_all2</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs ys] determines whether all pairs [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y)] of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; drawn synchronously from the sequences [xs] and [ys] satisfy [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the sequences [xs] and [ys] have different lengths, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; iteration stops as soon as <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> sequence is exhausted;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the excess <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in the other sequence are <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; In particular, if [xs] or [ys] is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L215" title="ocaml/stdlib/seq.ml:215">for_all2</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs ys] is true. This is where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L215" title="ocaml/stdlib/seq.ml:215">for_all2</a>] and [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>] differ: [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> xs ys] can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; be true only if [xs] and [ys] have the same <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; At least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the sequences [xs] and [ys] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L215" title="ocaml/stdlib/seq.ml:215">for_all2</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs ys] is equivalent to [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> (fun b -&gt; b) (<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs ys)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L307">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exists2</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L226" title="ocaml/stdlib/seq.ml:226">exists2</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs ys] determines whether <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> pair [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y)] of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; drawn synchronously from the sequences [xs] and [ys] satisfies [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the sequences [xs] and [ys] have different lengths, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; iteration must <a href="gc.mli.html#L527" title="ocaml/stdlib/gc.mli:527">stop</a> as soon as <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> sequence is exhausted;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the excess <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in the other sequence are <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; At least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the sequences [xs] and [ys] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L226" title="ocaml/stdlib/seq.ml:226">exists2</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs ys] is equivalent to [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> (fun b -&gt; b) (<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs ys)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L321">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">equal</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Provided the function [<a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a>] defines an equality on <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> xs ys] determines whether the sequences [xs] and [ys]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; are pointwise <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; At least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the sequences [xs] and [ys] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L330">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">compare</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** Provided the function [cmp] defines <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> preorder on <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> cmp xs ys] compares the sequences [xs] and [ys]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; according to the lexicographic preorder.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For more details on comparison functions, see {!Array.<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; At least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the sequences [xs] and [ys] must be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Constructing sequences} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The functions in this section are lazy: that is, they <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> sequences<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; whose <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are computed only when demanded. *)<br/></li>
<li></span><br/></li>
<li><a id="L346">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">empty</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>] is the <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; It has no <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. Its <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> is 0. *)<br/></li>
<li></span><br/></li>
<li><a id="L350">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">return</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the sequence whose sole element is [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Its <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> is 1. *)<br/></li>
<li></span><br/></li>
<li><a id="L354">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">cons</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L28" title="ocaml/stdlib/seq.ml:28">cons</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> xs] is the sequence that begins with the element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; followed with the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Writing [<a href="seq.ml.html#L28" title="ocaml/stdlib/seq.ml:28">cons</a> (f()) xs] causes the function call [f()]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> place immediately. For this call to be delayed until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequence is queried, <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> must instead write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [(fun () -&gt; Cons(f(), xs))].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><a id="L365">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">init</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> f] is the sequence [f 0; f 1; ...; f (<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] must be nonnegative.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If desired, the infinite sequence [f 0; f 1; ...]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; can be defined as [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f (<a href="seq.ml.html#L701" title="ocaml/stdlib/seq.ml:701">ints</a> 0)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is negative.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L377">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">unfold</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L79" title="ocaml/stdlib/seq.ml:79">unfold</a>] constructs <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; out of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> step function and an initial <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [f u] is [None] then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L79" title="ocaml/stdlib/seq.ml:79">unfold</a> f u] is the <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If [f u] is [Some (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, u')] then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L79" title="ocaml/stdlib/seq.ml:79">unfold</a> f u] is the nonempty sequence [<a href="seq.ml.html#L28" title="ocaml/stdlib/seq.ml:28">cons</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> (<a href="seq.ml.html#L79" title="ocaml/stdlib/seq.ml:79">unfold</a> f u')].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For example, [<a href="seq.ml.html#L79" title="ocaml/stdlib/seq.ml:79">unfold</a> (function [] -&gt; None | h :: <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> -&gt; Some (h, <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>)) <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is equivalent to [List.<a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><a id="L391">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">repeat</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L276" title="ocaml/stdlib/seq.ml:276">repeat</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the infinite sequence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where the element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is repeated indefinitely.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L276" title="ocaml/stdlib/seq.ml:276">repeat</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is equivalent to [<a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a> (<a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L399">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">forever</span></span> : <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L279" title="ocaml/stdlib/seq.ml:279">forever</a> f] is an infinite sequence where every element is produced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (on demand) by the function call [f()].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For instance,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L279" title="ocaml/stdlib/seq.ml:279">forever</a> Random.<a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a>] is an infinite sequence of random <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L279" title="ocaml/stdlib/seq.ml:279">forever</a> f] is equivalent to [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f (<a href="seq.ml.html#L276" title="ocaml/stdlib/seq.ml:276">repeat</a> ())].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L410">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">cycle</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a> xs] is the infinite sequence that consists of an infinite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; number of repetitions of the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [xs] is an <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> sequence,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then [<a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a> xs] is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> as well.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Consuming (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> prefix of) the sequence [<a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a> xs] <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; can cause the sequence [xs] to be consumed more than <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Therefore, [xs] must be persistent.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L423">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">iterate</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L318" title="ocaml/stdlib/seq.ml:318">iterate</a> f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the infinite sequence whose <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], [f (f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)], and so on.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; In other words, it is the orbit of the function [f],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; starting at [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Transforming sequences} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** The functions in this section are lazy: that is, they <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> sequences<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; whose <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are computed only when demanded. *)<br/></li>
<li></span><br/></li>
<li><a id="L437">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs] is the image of the sequence [xs] through the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; transformation [f].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [xs] is the sequence [x0; x1; ...] then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs] is the sequence [f x0; f x1; ...]. *)<br/></li>
<li></span><br/></li>
<li><a id="L444">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">mapi</span></span> : <span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="bytesLabels.mli.html#L180" title="ocaml/stdlib/bytesLabels.mli:180">mapi</a>] is analogous to [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>], but applies the function [f] to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; an <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> and an element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="bytesLabels.mli.html#L180" title="ocaml/stdlib/bytesLabels.mli:180">mapi</a> f xs] is equivalent to [<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> f (<a href="seq.ml.html#L701" title="ocaml/stdlib/seq.ml:701">ints</a> 0) xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L452">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">filter</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] is the sequence of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of [xs]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; that satisfy [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; In other words, [<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] is the sequence [xs],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; deprived of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] such that [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is false. *)<br/></li>
<li></span><br/></li>
<li><a id="L459">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">filter_map</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> f xs] is the sequence of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [y] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Some y], where [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] ranges over [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> f xs] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> Option.<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> (<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> Option.<a href="option.mli.html#L62" title="ocaml/stdlib/option.mli:62">is_some</a> (<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs))]. *)<br/></li>
<li></span><br/></li>
<li><a id="L466">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">scan</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** If [xs] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence [[x0; x1; x2; ...]], then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a> f a0 xs] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence of accumulators<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [[a0; <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; a2; ...]]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where [<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>] is [f a0 x0], [a2] is [f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a> x1], and so on.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Thus, [<a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a> f a0 xs] is conceptually related to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> f a0 xs]. However, instead of performing an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; eager iteration and immediately returning the final accumulator,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; it returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence of accumulators.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For instance, [<a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a> (+) 0] transforms <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence of integers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; into the sequence of its partial sums.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [xs] has <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then [<a href="seq.ml.html#L347" title="ocaml/stdlib/seq.ml:347">scan</a> f a0 xs] has <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>+1].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L485">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">take</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> xs] is the sequence of the first [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [xs] has fewer than [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then [<a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> xs] is equivalent to [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] must be nonnegative.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is negative.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L497">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">drop</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="stack.ml.html#L38" title="ocaml/stdlib/stack.ml:38">drop</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> xs] is the sequence [xs], deprived of its first [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [xs] has fewer than [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then [<a href="stack.ml.html#L38" title="ocaml/stdlib/stack.ml:38">drop</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> xs] is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] must be nonnegative.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="stack.ml.html#L38" title="ocaml/stdlib/stack.ml:38">drop</a>] is lazy: the first [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>+1] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the sequence [xs]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; are demanded only when the first element of [<a href="stack.ml.html#L38" title="ocaml/stdlib/stack.ml:38">drop</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> xs] is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; demanded. For this reason, [<a href="stack.ml.html#L38" title="ocaml/stdlib/stack.ml:38">drop</a> 1 xs] is {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> not} equivalent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to [tail xs], which queries [xs] immediately.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is negative.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L514">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">take_while</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L394" title="ocaml/stdlib/seq.ml:394">take_while</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] is the longest prefix of the sequence [xs]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where every element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] satisfies [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L520">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">drop_while</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L401" title="ocaml/stdlib/seq.ml:401">drop_while</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] is the sequence [xs], deprived of the prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L394" title="ocaml/stdlib/seq.ml:394">take_while</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L526">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">group</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** Provided the function [<a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a>] defines an equality on <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L408" title="ocaml/stdlib/seq.ml:408">group</a> <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> xs] is the sequence of the maximal runs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of adjacent duplicate <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Every element of [<a href="seq.ml.html#L408" title="ocaml/stdlib/seq.ml:408">group</a> <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> xs] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> nonempty sequence of <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The concatenation [<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a> (<a href="seq.ml.html#L408" title="ocaml/stdlib/seq.ml:408">group</a> <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> xs)] is <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Consuming [<a href="seq.ml.html#L408" title="ocaml/stdlib/seq.ml:408">group</a> <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> xs], and consuming the sequences that it <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; can cause [xs] to be consumed more than <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>. Therefore, [xs] must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; persistent.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L541">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">memoize</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** The sequence [<a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> xs] has the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Regardless of whether [xs] is ephemeral or persistent,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> xs] is persistent: even if it is queried several times,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [xs] is queried at most <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The construction of the sequence [<a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> xs] internally relies on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; suspensions provided by the module {!Lazy}. These suspensions are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> not} thread-safe. Therefore, the sequence [<a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> xs]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; must {<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> not} be queried by multiple threads concurrently.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">exception</span> <span class="Constant">Forced_twice<br/></li>
<li></span><span class="Comment">(** This exception is raised when <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence returned by {!<a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (or <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suffix of it) is queried more than <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L561">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">once</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** The sequence [<a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> xs] has the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Regardless of whether [xs] is ephemeral or persistent,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> xs] is an ephemeral sequence: it can be queried at most <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If it (or <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suffix of it) is queried more than <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>, then the exception<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [Forced_twice] is raised. This can be useful, while debugging or testing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to <a href="in_channel.ml.html#L108" title="ocaml/stdlib/in_channel.ml:108">ensure</a> that <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence is consumed at most <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @raise Forced_twice if [<a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> xs], or <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suffix of it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is queried more than <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L575">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">transpose</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** If [xss] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> matrix (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence of rows), then [<a href="#L575" title="ocaml/stdlib/seq.mli:575">transpose</a> xss] is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the sequence of the columns of the matrix [xss].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The rows of the matrix [xss] are not required to have the same <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The matrix [xss] is not required to be finite (in either direction).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The matrix [xss] must be persistent.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Combining sequences} *)<br/></li>
<li></span><br/></li>
<li><a id="L589">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">append</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a> xs ys] is the concatenation of the sequences [xs] and [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Its <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [xs], followed by the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><a id="L596">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">concat</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** If [xss] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence of sequences,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; then [<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a> xss] is its concatenation.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [xss] is the sequence [xs0; xs1; ...] then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a> xss] is the sequence [xs0 @ xs1 @ ...].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L605">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">flat_map</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L58" title="ocaml/stdlib/seq.ml:58">flat_map</a> f xs] is equivalent to [<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a> (<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L608">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">concat_map</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L63" title="ocaml/stdlib/seq.ml:63">concat_map</a> f xs] is equivalent to [<a href="filename.mli.html#L30" title="ocaml/stdlib/filename.mli:30">concat</a> (<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L63" title="ocaml/stdlib/seq.ml:63">concat_map</a>] is an alias for [<a href="seq.ml.html#L58" title="ocaml/stdlib/seq.ml:58">flat_map</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13 *)<br/></li>
<li></span><br/></li>
<li><a id="L615">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">zip</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L615" title="ocaml/stdlib/seq.mli:615">zip</a> xs ys] is the sequence of pairs [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; drawn synchronously from the sequences [xs] and [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the sequences [xs] and [ys] have different lengths, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the sequence ends as soon as <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> sequence is exhausted;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the excess <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in the other sequence are <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="#L615" title="ocaml/stdlib/seq.mli:615">zip</a> xs ys] is equivalent to [<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> (fun <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b -&gt; (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>, b)) xs ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L627">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map2</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> f xs ys] is the sequence of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; where the pairs [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y)] are drawn synchronously from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; sequences [xs] and [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If the sequences [xs] and [ys] have different lengths, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the sequence ends as soon as <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> sequence is exhausted;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the excess <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in the other sequence are <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> f xs ys] is equivalent to [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> (fun (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y) -&gt; f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y) (<a href="#L615" title="ocaml/stdlib/seq.mli:615">zip</a> xs ys)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L640">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">interleave</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L499" title="ocaml/stdlib/seq.ml:499">interleave</a> xs ys] is the sequence that begins with the first element of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [xs], continues with the first element of [ys], and so on.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; When <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the sequences [xs] and [ys] is exhausted,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L499" title="ocaml/stdlib/seq.ml:499">interleave</a> xs ys] continues with the rest of the other sequence.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L649">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">sorted_merge</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** If the sequences [xs] and [ys] are sorted according to the total preorder<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [cmp], then [<a href="seq.ml.html#L538" title="ocaml/stdlib/seq.ml:538">sorted_merge</a> cmp xs ys] is the sorted sequence obtained by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; merging the sequences [xs] and [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For more details on comparison functions, see {!Array.<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L658">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">product</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L658" title="ocaml/stdlib/seq.mli:658">product</a> xs ys] is the Cartesian <a href="#L658" title="ocaml/stdlib/seq.mli:658">product</a> of the sequences [xs] and [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For every element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of [xs] and for every element [y] of [ys],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the pair [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y)] appears <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> as an element of [<a href="#L658" title="ocaml/stdlib/seq.mli:658">product</a> xs ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The order in which the pairs appear is unspecified.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequences [xs] and [ys] are not required to be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequences [xs] and [ys] must be persistent.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L672">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">map_product</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** The sequence [<a href="seq.ml.html#L667" title="ocaml/stdlib/seq.ml:667">map_product</a> f xs ys] is the image through [f]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of the Cartesian <a href="#L658" title="ocaml/stdlib/seq.mli:658">product</a> of the sequences [xs] and [ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; For every element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of [xs] and for every element [y] of [ys],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the element [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] appears <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> as an element of [<a href="seq.ml.html#L667" title="ocaml/stdlib/seq.ml:667">map_product</a> f xs ys].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The order in which these <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> appear is unspecified.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequences [xs] and [ys] are not required to be finite.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The sequences [xs] and [ys] must be persistent.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L667" title="ocaml/stdlib/seq.ml:667">map_product</a> f xs ys] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> (fun (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, y) -&gt; f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y) (<a href="#L658" title="ocaml/stdlib/seq.mli:658">product</a> xs ys)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Splitting <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence into two sequences} *)<br/></li>
<li></span><br/></li>
<li><a id="L692">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">unzip</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L563" title="ocaml/stdlib/seq.ml:563">unzip</a>] transforms <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence of pairs into <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of sequences.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L563" title="ocaml/stdlib/seq.ml:563">unzip</a> xs] is equivalent to [(<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> fst xs, <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> snd xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Querying either of the sequences returned by [<a href="seq.ml.html#L563" title="ocaml/stdlib/seq.ml:563">unzip</a> xs]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; causes [xs] to be queried.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Therefore, querying both of them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; causes [xs] to be queried twice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Thus, [xs] must be persistent and cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If that is not the case, use [<a href="seq.ml.html#L563" title="ocaml/stdlib/seq.ml:563">unzip</a> (<a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L706">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">split</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a>] is an alias for [<a href="seq.ml.html#L563" title="ocaml/stdlib/seq.ml:563">unzip</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L711">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">partition_map</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span>'<span class="ocamlLCIdentifier">b</span>, '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="Statement">)</span> <span class="PreProc">Either</span>.<span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier">b</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L594" title="ocaml/stdlib/seq.ml:594">partition_map</a> f xs] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of sequences [(ys, zs)], where:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [ys] is the sequence of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [y] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Left y], where [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] ranges over [xs];<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - [zs] is the sequence of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [z] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Right z], where [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] ranges over [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L594" title="ocaml/stdlib/seq.ml:594">partition_map</a> f xs] is equivalent to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> Either.<a href="either.mli.html#L72" title="ocaml/stdlib/either.mli:72">find_left</a> (<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs)] and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> Either.<a href="either.mli.html#L75" title="ocaml/stdlib/either.mli:75">find_right</a> (<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Querying either of the sequences returned by [<a href="seq.ml.html#L594" title="ocaml/stdlib/seq.ml:594">partition_map</a> f xs]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; causes [xs] to be queried.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Therefore, querying both of them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; causes [xs] to be queried twice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Thus, [xs] must be persistent and cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If that is not the case, use [<a href="seq.ml.html#L594" title="ocaml/stdlib/seq.ml:594">partition_map</a> f (<a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L733">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">partition</span></span> : <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">*</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of the subsequence of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of [xs] that satisfy [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>] and the subsequence of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [xs] that do not satisfy [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs, <a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; not (<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)) xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Consuming both of the sequences returned by [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> xs] causes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [xs] to be consumed twice and causes the function [f] to be applied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; twice to each element of the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Therefore, [f] should be pure and cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Furthermore, [xs] should be persistent and cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If that is not the case, use [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> (<a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> xs)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Converting between sequences and dispensers} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** A dispenser is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> function of type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [unit -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> option]. Every time this function is invoked, it returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the next element of the sequence. When there are no more <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; it returns [None]. A dispenser has mutable internal <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>, therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is ephemeral: the sequence that it represents can be consumed at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L759">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">of_dispenser</span></span> : <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option</span><span class="Statement">)</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L759" title="ocaml/stdlib/seq.mli:759">of_dispenser</a> it] is the sequence of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> produced by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; dispenser [it]. It is an ephemeral sequence: it can be consumed at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a>. If <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> persistent sequence is needed, use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="seq.ml.html#L433" title="ocaml/stdlib/seq.ml:433">memoize</a> (<a href="#L759" title="ocaml/stdlib/seq.mli:759">of_dispenser</a> it)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><a id="L767">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_dispenser</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type">unit</span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Type">option</span><span class="Statement">)<br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L689" title="ocaml/stdlib/seq.ml:689">to_dispenser</a> xs] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh dispenser on the sequence [xs].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This dispenser has mutable internal <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; which is not protected by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="mutex.mli.html#L35" title="ocaml/stdlib/mutex.mli:35">lock</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; so, it must not be used by several threads concurrently.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1 Sequences of integers} *)<br/></li>
<li></span><br/></li>
<li><a id="L778">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">ints</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="seq.ml.html#L701" title="ocaml/stdlib/seq.ml:701">ints</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is the infinite sequence of the integers beginning at [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; counting up.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.14 *)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
