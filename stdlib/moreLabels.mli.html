<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/moreLabels.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/moreLabels.mli - ocaml</h1>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jacques Garrigue, Kyoto University RIMS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2001 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* </span><span class="Todo">NOTE</span><span class="Comment">: Do not edit this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> directly. Edit templates/ and run<br/></li>
<li></span><span class="Comment"> tools/sync_stdlib_docs *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Extra labeled libraries.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This meta-module provides labelized versions of the {!Hashtbl}, {!Map} and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Set} modules.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This module is intended to be used through [open MoreLabels] which replaces<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Hashtbl}, {!Map}, and {!Set} with their labeled counterparts.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; For example:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; open MoreLabels<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Hashtbl.<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f:(fun ~<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> ~<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> -&gt; g <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>) <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ]}<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> Hashtbl</span><span class="ocamlPreDef"> : </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Hash <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> and <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> functions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; Hash <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> are hashed association <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>, with in-place modification.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Because most operations on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> modify their <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>, they're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; more commonly used in imperative code. The lookup of the value associated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> (see {!<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a>}, {!<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a>}) is normally very fast, often faster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; than the equivalent lookup in {!Map}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The functors {!Make} and {!MakeSeeded} can be used when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; performance or flexibility are <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; The user provides custom equality and <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> functions for the <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> type,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; and obtains <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> custom <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> type for this particular type of <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; {b Warning} <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> is only as good as the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> function. A bad <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; function will turn the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> into <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> degenerate association list,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; with linear time lookup instead of constant time lookup.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The polymorphic {!<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>} <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> is useful in simpler cases or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in interactive environments. It uses the polymorphic {!<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>} function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; defined in the OCaml runtime (at the time of writing, it'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> SipHash),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; as well as the polymorphic equality [(=)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; See {{!examples} the examples section}.<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {b Unsynchronized accesses} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">[</span><span class="ocamlSig">@@@</span><span class="ocamlLCIdentifier">alert</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">unsynchronized_access<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Constant">&quot;Unsynchronized accesses to <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> are <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> programming <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a>.&quot;<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">]<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp;&nbsp; </span><span class="Comment">(**<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Unsynchronized accesses to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> may lead to an invalid <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="domain.ml.html#L36" title="ocaml/stdlib/domain.ml:36">state</a>. Thus, concurrent accesses to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> must be synchronized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (for instance with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Mutex.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>}).<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1 Generic interface} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="Statement">(!</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, </span><span class="Statement">!</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Hashtbl</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The type of <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> from type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] to type ['b]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a></span><span class="ocamlSig"> : </span><span class="Statement">?</span><span class="Identifier">random</span><span class="ocamlSig">: </span><span class="Comment">(* thwart tools/sync_stdlib_docs *)</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] creates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new, <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>, with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; initial <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>].&nbsp; For best results, [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] should be on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; order of the expected number of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> that will be in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>.&nbsp; The <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> grows as needed, so [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is just an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; initial guess.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The optional [~random] parameter (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> boolean) controls whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the internal organization of the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> is <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> at each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; execution of [Hashtbl.<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a>] or deterministic over all executions.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; A <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> that is created with [~random] <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to [false] uses <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; fixed <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> function ({!<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>}) to distribute keys among<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; buckets.&nbsp; As <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> consequence, collisions between keys happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; deterministically.&nbsp; In Web-facing applications or other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; security-sensitive applications, the deterministic collision<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; patterns can be exploited by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> malicious user to <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; denial-of-service attack: the attacker sends <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> crafted to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> many collisions in the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>, slowing the application down.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; A <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> that is created with [~random] <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> to [true] uses the seeded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> function {!<a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a>} with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> seed that is randomly chosen at <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> creation time.&nbsp; In effect, the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> function used is randomly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; selected among [2^{30}] different <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> functions.&nbsp; All these <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; functions have different collision patterns, rendering ineffective the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; denial-of-service attack described above.&nbsp; However, because of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; randomization, enumerating all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> using {!<a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; or {!<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>} is no longer deterministic: <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are enumerated in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; different orders at different runs of the program.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; If no [~random] parameter is given, <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> are created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in non-random mode by default.&nbsp; This default can be changed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; either programmatically by calling {!<a href="hashtbl.ml.html#L57" title="ocaml/stdlib/hashtbl.ml:57">randomize</a>} or by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; setting the [R] flag in the [OCAMLRUNPARAM] environment variable.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.00 the [~random] parameter was not present and all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> were created in non-<a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> mode. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L73" title="ocaml/stdlib/buffer.ml:73">clear</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Empty <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>. Use [<a href="buffer.ml.html#L75" title="ocaml/stdlib/buffer.ml:75">reset</a>] instead of [<a href="buffer.ml.html#L73" title="ocaml/stdlib/buffer.ml:73">clear</a>] to shrink the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="weak.ml.html#L312" title="ocaml/stdlib/weak.ml:312">bucket</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> to its initial <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L75" title="ocaml/stdlib/buffer.ml:75">reset</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Empty <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> and shrink the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="weak.ml.html#L312" title="ocaml/stdlib/weak.ml:312">bucket</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to its initial <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the given hashtable. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> tbl ~<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> ~<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>] adds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] to [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> [tbl].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; {b Warning}: Previous <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> for [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] are not removed, but simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; hidden. That is, after performing {!<a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a>}[ tbl <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the previous binding for [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>], if any, is restored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; (Same behavior as with association lists.)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; If you desire the classic behavior of replacing <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; see {!<a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a>}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> tbl <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> binding of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [tbl],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; or raises [Not_found] if no such binding <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> tbl <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> binding of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [tbl],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; or [None] if no such binding <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L97" title="ocaml/stdlib/ephemeron.mli:97">find_all</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="ephemeron.mli.html#L97" title="ocaml/stdlib/ephemeron.mli:97">find_all</a> tbl <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the list of all <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; associated with [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [tbl].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> binding is returned first, then the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a>, in reverse order of introduction in the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> tbl <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] checks if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is bound in [tbl]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> tbl <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] removes the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> binding of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [tbl],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; restoring the previous binding if it <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; It does nothing if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is not bound in [tbl]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a> tbl ~<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> ~<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>] replaces the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in [tbl] by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] to [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>].&nbsp; If [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] is unbound in [tbl],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] to [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>] is added to [tbl].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; This is functionally equivalent to {!<a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a>}[ tbl <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; followed by {!<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a>}[ tbl <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f tbl] applies [f] to all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> [tbl].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [f] receives the <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> as first argument, and the associated value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; as second argument. Each binding is presented exactly <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> to [f].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The order in which the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are passed to [f] is unspecified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; However, if the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> several <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> for the same <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; they are passed to [f] in reverse order of introduction, that is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the most recent binding is passed first.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; If the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> was created in non-<a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> mode, the order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in which the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are enumerated is reproducible between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; successive runs of the program, and even between minor versions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; of OCaml.&nbsp; For <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>, the order of <a href="map.ml.html#L461" title="ocaml/stdlib/map.ml:461">enumeration</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; is entirely random.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The behavior is not specified if the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> is modified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; by [f] during the iteration.<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L306" title="ocaml/stdlib/hashtbl.ml:306">filter_map_inplace</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="hashtbl.ml.html#L306" title="ocaml/stdlib/hashtbl.ml:306">filter_map_inplace</a> ~f tbl] applies [f] to all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> [tbl] and <a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> each binding depending on the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f].&nbsp; If [f] returns [None], the binding is discarded.&nbsp; If it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; returns [Some new_val], the binding is <a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> to associate the <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to [new_val].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Other comments for {!<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>} apply as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a></span><span class="ocamlSig"> :<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a> ~f tbl ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [(f kN dN ... (f k1 d1 <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>)...)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; where [k1 ... kN] are the keys of all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in [tbl],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; and [d1 ... dN] are the associated values.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Each binding is presented exactly <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> to [f].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The order in which the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are passed to [f] is unspecified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; However, if the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> several <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> for the same <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; they are passed to [f] in reverse order of introduction, that is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the most recent binding is passed first.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; If the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> was created in non-<a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> mode, the order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in which the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are enumerated is reproducible between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; successive runs of the program, and even between minor versions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; of OCaml.&nbsp; For <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>, the order of <a href="map.ml.html#L461" title="ocaml/stdlib/map.ml:461">enumeration</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; is entirely random.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The behavior is not specified if the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> is modified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; by [f] during the iteration.<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> tbl] returns the number of <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in [tbl].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; It takes constant time.&nbsp; Multiple <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are counted <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> each, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [Hashtbl.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>] gives the number of times [Hashtbl.<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>] calls its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; first argument. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L57" title="ocaml/stdlib/hashtbl.ml:57">randomize</a></span><span class="ocamlSig"> : </span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** After <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> call to [Hashtbl.<a href="hashtbl.ml.html#L57" title="ocaml/stdlib/hashtbl.ml:57">randomize</a>()], <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> are created in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> mode by default: {!<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a>} returns <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>, unless the [~random:false] optional parameter is given.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; The same effect can be achieved by setting the [R] parameter in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the [OCAMLRUNPARAM] environment variable.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; It is recommended that applications or Web frameworks that need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="fun.mli.html#L39" title="ocaml/stdlib/fun.mli:39">protect</a> themselves against the denial-of-service attack described<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; in {!<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a>} call [Hashtbl.<a href="hashtbl.ml.html#L57" title="ocaml/stdlib/hashtbl.ml:57">randomize</a>()] at initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; time <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> any domains are created.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Note that <a href="seq.ml.html#L447" title="ocaml/stdlib/seq.ml:447">once</a> [Hashtbl.<a href="hashtbl.ml.html#L57" title="ocaml/stdlib/hashtbl.ml:57">randomize</a>()] was called, there is no way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to revert to the non-<a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> default behavior of {!<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a>}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; This is intentional.&nbsp; Non-<a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> can still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; created using [Hashtbl.<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> ~random:false].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L58" title="ocaml/stdlib/hashtbl.ml:58">is_randomized</a></span><span class="ocamlSig"> : </span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Return [true] if the <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> are currently created in <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; by default, [false] otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L621" title="ocaml/stdlib/hashtbl.ml:621">rebuild</a></span><span class="ocamlSig"> : </span><span class="Statement">?</span><span class="Identifier">random</span><span class="ocamlSig"> </span><span class="Comment">(* thwart tools/sync_stdlib_docs *)</span><span class="ocamlSig"> :</span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of the given hashtable.&nbsp; Unlike {!<a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a>},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {!<a href="hashtbl.ml.html#L621" title="ocaml/stdlib/hashtbl.ml:621">rebuild</a>}[ h] re-<a href="weak.ml.html#L313" title="ocaml/stdlib/weak.ml:313">hashes</a> all the (<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>, value) entries of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the original <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> [h].&nbsp; The returned <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> is <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [h] was <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a>, or the optional [random] parameter is true, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; if the default is to <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {!<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a>} for more information.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; {!<a href="hashtbl.ml.html#L621" title="ocaml/stdlib/hashtbl.ml:621">rebuild</a>} can safely be used to import <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> built<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; by an old version of the {!Hashtbl} module, then marshaled to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; persistent storage.&nbsp; After unmarshaling, apply {!<a href="hashtbl.ml.html#L621" title="ocaml/stdlib/hashtbl.ml:621">rebuild</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to produce <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> for the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> version of the {!Hashtbl}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; module.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** @since 4.00 *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L228" title="ocaml/stdlib/hashtbl.ml:228">statistics</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="PreProc">Hashtbl</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L228" title="ocaml/stdlib/hashtbl.ml:228">statistics</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Statement">{<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="ocamlLCIdentifier">num_bindings</span><span class="ocamlSig">: </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Number of <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> present in the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Same value as returned by {!<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>}. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="ocamlLCIdentifier">num_buckets</span><span class="ocamlSig">: </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Number of buckets in the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="ocamlLCIdentifier">max_bucket_length</span><span class="ocamlSig">: </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Maximal number of <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> per <a href="weak.ml.html#L312" title="ocaml/stdlib/weak.ml:312">bucket</a>. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="ocamlLCIdentifier">bucket_histogram</span><span class="ocamlSig">: </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Type">array<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Histogram of <a href="weak.ml.html#L312" title="ocaml/stdlib/weak.ml:312">bucket</a> sizes.&nbsp; This array [histo] has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [max_bucket_length + 1].&nbsp; The value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [histo.(<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>)] is the number of buckets whose <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> is [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>]. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">}<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="camlinternalOO.ml.html#L607" title="ocaml/stdlib/camlinternalOO.ml:607">stats</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L228" title="ocaml/stdlib/hashtbl.ml:228">statistics</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="camlinternalOO.ml.html#L607" title="ocaml/stdlib/camlinternalOO.ml:607">stats</a> tbl] returns <a href="hashtbl.ml.html#L228" title="ocaml/stdlib/hashtbl.ml:228">statistics</a> about the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> [tbl]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; number of buckets, <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the biggest <a href="weak.ml.html#L312" title="ocaml/stdlib/weak.ml:312">bucket</a>, distribution of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; buckets by <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1 Hash <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> and Sequences} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">,'</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Iterate on the whole <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>.&nbsp; The order in which the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; appear in the sequence is unspecified. However, if the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; several <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> for the same <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>, they appear in reversed order of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; introduction, that is, the most recent binding appears first.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; The behavior is not specified if the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> is modified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; during the iteration.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L270" title="ocaml/stdlib/hashtbl.ml:270">to_seq_keys</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">,</span><span class="Statement">_)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as [Seq.<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> fst (<a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a> m)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L272" title="ocaml/stdlib/hashtbl.ml:272">to_seq_values</a></span><span class="ocamlSig"> : </span><span class="Statement">(_</span><span class="ocamlSig">,'</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as [Seq.<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> snd (<a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a> m)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L313" title="ocaml/stdlib/buffer.ml:313">add_seq</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">,'</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Add the given <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> to the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>, using {!<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L103" title="ocaml/stdlib/ephemeron.mli:103">replace_seq</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">,'</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Add the given <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> to the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>, using {!<a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L315" title="ocaml/stdlib/buffer.ml:315">of_seq</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Build <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> from the given <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a>. The <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; in the same order they appear in the sequence, using {!<a href="ephemeron.mli.html#L103" title="ocaml/stdlib/ephemeron.mli:103">replace_seq</a>},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; which means that if two pairs have the same <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>, only the latest <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; will appear in the <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1 Functorial interface} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The functorial interface allows the use of specific comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> functions, either for performance/security concerns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; or because keys are not hashable/comparable with the polymorphic builtins.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; For instance, <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> might want to specialize <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a> for integer keys:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; module IntHash =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> j = <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>=j<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> = <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> land <a href="int32.ml.html#L52" title="ocaml/stdlib/int32.ml:52">max_int</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; module IntHashtbl = Hashtbl.Make(IntHash)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; let h = IntHashtbl.<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> 17 in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; IntHashtbl.<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> h 12 &quot;hello&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; This creates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new module [IntHashtbl], with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; IntHashtbl.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] of <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> from [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] to ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. In this example, [h]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>] values so its type is [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> IntHashtbl.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Note that the new type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> IntHashtbl.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] is not compatible with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the type [('<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>,'b) Hashtbl.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] of the generic interface. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; example, [Hashtbl.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> h] would not type-<a href="weak.ml.html#L58" title="ocaml/stdlib/weak.ml:58">check</a>, you must use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [IntHashtbl.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a>].<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">module type </span><span class="PreProc">HashedType</span><span class="ocamlSig"> </span><span class="Statement">=<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the hashtable keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The equality predicate used to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** A hashing function on keys. It must be such that if two keys are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> according to [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>], then they have identical <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> values<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; as computed by [<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Examples: suitable ([<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>], [<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>]) pairs for arbitrary <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; types include<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ([(=)], {!<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>}) for comparing objects by structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (provided objects do not contain floats)<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ([(fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y -&gt; <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y = 0)], {!<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>})<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for comparing objects by structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and handling {!Stdlib.<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>} correctly<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ([(==)], {!<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>}) for comparing objects by physical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equality (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. for mutable or cyclic objects). *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp;&nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">module type </span><span class="PreProc">S</span><span class="ocamlSig"> </span><span class="Statement">=<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="Statement">!</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L73" title="ocaml/stdlib/buffer.ml:73">clear</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L75" title="ocaml/stdlib/buffer.ml:75">reset</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Comment">(** @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L97" title="ocaml/stdlib/ephemeron.mli:97">find_all</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L306" title="ocaml/stdlib/hashtbl.ml:306">filter_map_inplace</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a></span><span class="ocamlSig"> :<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="camlinternalOO.ml.html#L607" title="ocaml/stdlib/camlinternalOO.ml:607">stats</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L228" title="ocaml/stdlib/hashtbl.ml:228">statistics</a></span><span class="ocamlSig"> </span><span class="Comment">(** @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L270" title="ocaml/stdlib/hashtbl.ml:270">to_seq_keys</a></span><span class="ocamlSig"> : </span><span class="Statement">_</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L272" title="ocaml/stdlib/hashtbl.ml:272">to_seq_values</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L313" title="ocaml/stdlib/buffer.ml:313">add_seq</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L103" title="ocaml/stdlib/ephemeron.mli:103">replace_seq</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L315" title="ocaml/stdlib/buffer.ml:315">of_seq</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">module</span><span class="ocamlModSpec"> </span><span class="PreProc">Make</span><span class="ocamlSig"> </span><span class="ocamlMPRestr">:</span><span class="Statement"> functor </span><span class="ocamlModParam">(</span><span class="PreProc">H</span><span class="ocamlPreMPRestr"> </span><span class="ocamlMPRestr">:</span><span class="ocamlPreMPRestr"> </span><span class="PreProc">HashedType</span><span class="ocamlModParam">)</span><span class="Statement"> -&gt;</span><span class="ocamlSig"> </span><span class="Constant">S<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">with</span><span class="ocamlSig"> </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="PreProc">H</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp;&nbsp; </span><span class="Statement">and</span><span class="ocamlSig"> </span><span class="Statement">type</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="PreProc">Hashtbl</span><span class="ocamlSig">.</span><span class="Constant">Make</span><span class="Statement">(</span><span class="Constant">H</span><span class="Statement">)</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Functor building an implementation of the hashtable structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; The functor [Hashtbl.Make] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> structure containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> type [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] of keys and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] of <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; associating <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] to keys of type [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; The operations perform similarly to those of the generic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; interface, but use the hashing and equality functions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; specified in the functor argument [H] instead of generic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; equality and hashing.&nbsp; Since the <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> function is not seeded,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the [<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a>] operation of the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> structure always returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; non-<a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">module type </span><span class="PreProc">SeededHashedType</span><span class="ocamlSig"> </span><span class="Statement">=<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the hashtable keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The equality predicate used to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a></span><span class="ocamlSig">: </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** A seeded hashing function on keys.&nbsp; The first argument is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the seed.&nbsp; It must be the case that if [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] is true,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then [<a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a> seed <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = <a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a> seed y] for any value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [seed].&nbsp; A suitable choice for [<a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a>] is the function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {!Hashtbl.<a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a>} below. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> signature of the functor {!MakeSeeded}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">module type </span><span class="PreProc">SeededS</span><span class="ocamlSig"> </span><span class="Statement">=<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="Statement">!</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a></span><span class="ocamlSig"> : </span><span class="Statement">?</span><span class="Identifier">random</span><span class="ocamlSig"> </span><span class="Comment">(* thwart tools/sync_stdlib_docs *)</span><span class="ocamlSig"> :</span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L73" title="ocaml/stdlib/buffer.ml:73">clear</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L75" title="ocaml/stdlib/buffer.ml:75">reset</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Comment">(** @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L97" title="ocaml/stdlib/ephemeron.mli:97">find_all</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L306" title="ocaml/stdlib/hashtbl.ml:306">filter_map_inplace</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a></span><span class="ocamlSig"> :<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="camlinternalOO.ml.html#L607" title="ocaml/stdlib/camlinternalOO.ml:607">stats</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L228" title="ocaml/stdlib/hashtbl.ml:228">statistics</a><br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L270" title="ocaml/stdlib/hashtbl.ml:270">to_seq_keys</a></span><span class="ocamlSig"> : </span><span class="Statement">_</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L272" title="ocaml/stdlib/hashtbl.ml:272">to_seq_values</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L313" title="ocaml/stdlib/buffer.ml:313">add_seq</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L103" title="ocaml/stdlib/ephemeron.mli:103">replace_seq</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L315" title="ocaml/stdlib/buffer.ml:315">of_seq</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** @since 4.07 *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> signature of the functor {!MakeSeeded}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">module</span><span class="ocamlModSpec"> </span><span class="PreProc">MakeSeeded</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="Constant">H</span><span class="ocamlSig"> : </span><span class="Constant">SeededHashedType</span><span class="Statement">)</span><span class="ocamlSig"> : </span><span class="Constant">SeededS<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">with</span><span class="ocamlSig"> </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="PreProc">H</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp;&nbsp; </span><span class="Statement">and</span><span class="ocamlSig"> </span><span class="Statement">type</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="PreProc">Hashtbl</span><span class="ocamlSig">.</span><span class="Constant">MakeSeeded</span><span class="Statement">(</span><span class="Constant">H</span><span class="Statement">)</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Functor building an implementation of the hashtable structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; The functor [Hashtbl.MakeSeeded] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> structure containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> type [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] of keys and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>] of <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; associating <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] to keys of type [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; The operations perform similarly to those of the generic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; interface, but use the seeded hashing and equality functions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; specified in the functor argument [H] instead of generic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; equality and hashing.&nbsp; The [<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a>] operation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> structure supports the [~random] optional parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and returns <a href="hashtbl.ml.html#L55" title="ocaml/stdlib/hashtbl.ml:55">randomized</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> if [~random:true] is passed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; or if randomization is globally on (see {!Hashtbl.<a href="hashtbl.ml.html#L57" title="ocaml/stdlib/hashtbl.ml:57">randomize</a>}).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1 The polymorphic <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> functions} *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] associates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> nonnegative integer to any value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; any type. It is guaranteed that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = y] or [Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y = 0], then [<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> y].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Moreover, [<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>] always terminates, even on cyclic structures. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** A variant of {!<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>} that is further parameterized by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; an integer seed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="hashtbl.ml.html#L502" title="ocaml/stdlib/hashtbl.ml:502">hash_param</a></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Hashtbl.<a href="hashtbl.ml.html#L502" title="ocaml/stdlib/hashtbl.ml:502">hash_param</a> meaningful total <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] computes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> value for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; with the same properties as for [<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>]. The two extra integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; parameters [meaningful] and [total] give more precise <a href="gc.mli.html#L113" title="ocaml/stdlib/gc.mli:113">control</a> over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; hashing. Hashing performs <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> breadth-first, <a href="either.mli.html#L60" title="ocaml/stdlib/either.mli:60">left</a>-to-<a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> traversal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; of the structure [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], stopping after [meaningful] meaningful nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; were encountered, or [total] nodes (meaningful or not) were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; encountered.&nbsp; If [total] as specified by the user exceeds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> certain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; value, currently 256, then it is capped to that value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Meaningful nodes are: integers; floating-point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; numbers; strings; characters; booleans; and constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; constructors. Larger values of [meaningful] and [total] means that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; more nodes are taken into account to compute the final <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; and therefore collisions are less likely to happen.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; hashing takes longer. The parameters [meaningful] and [total]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; govern the tradeoff between accuracy and speed.&nbsp; As default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; choices, {!<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>} and {!<a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a>} <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [meaningful = 10] and [total = 100]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">seeded_hash_param</span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** A variant of {!<a href="hashtbl.ml.html#L502" title="ocaml/stdlib/hashtbl.ml:502">hash_param</a>} that is further parameterized by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; an integer seed.&nbsp; Usage:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [Hashtbl.seeded_hash_param meaningful total seed <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; @since 4.00 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1:examples Examples}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2 Basic Example}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; (* 0...99 *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let seq = Seq.<a href="seq.ml.html#L701" title="ocaml/stdlib/seq.ml:701">ints</a> 0 |&gt; Seq.<a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> 100<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; (* build from Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; # let tbl =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&gt; Seq.<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, <a href="stdlib.ml.html#L265" title="ocaml/stdlib/stdlib.ml:265">string_of_int</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&gt; Hashtbl.<a href="buffer.ml.html#L315" title="ocaml/stdlib/buffer.ml:315">of_seq</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; val tbl : (<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>, <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>) Hashtbl.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = &lt;abstr&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # Hashtbl.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> tbl<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> = 100<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # Hashtbl.<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> tbl 32<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> option = Some &quot;32&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # Hashtbl.<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> tbl 166<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> option = None<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # Hashtbl.<a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a> tbl 166 &quot;<a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> six six&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : unit = ()<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # Hashtbl.<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> tbl 166<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> option = Some &quot;<a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> six six&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # Hashtbl.<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> tbl<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> = 101<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; ]}<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2 Counting Elements}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> (here, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> {!Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>}), we want to <a href="weak.ml.html#L97" title="ocaml/stdlib/weak.ml:97">count</a> how many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; times each distinct element occurs in the sequence. A simple way to do this,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; assuming the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are comparable and hashable, is to use <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="camlinternalOO.ml.html#L94" title="ocaml/stdlib/camlinternalOO.ml:94">table</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; that maps <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> to their number of occurrences.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Here we illustrate that principle using <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequence of (ascii) characters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (type [<a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; We use <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> custom [Char_tbl] specialized for [<a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; # module Char_tbl = Hashtbl.Make(struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = <a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> = Char.<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> = Hashtbl.<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; end)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; (*&nbsp; <a href="weak.ml.html#L97" title="ocaml/stdlib/weak.ml:97">count</a> distinct occurrences of chars in [seq] *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; # let count_chars (seq : <a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a> Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>) : _ list =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let counts = Char_tbl.<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> 16 in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Seq.<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fun <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a> -&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let count_c =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Char_tbl.<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> counts <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&gt; Option.value ~default:0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Char_tbl.<a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a> counts <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a> (count_c + 1))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* turn into <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Char_tbl.<a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a> (fun <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a> -&gt; (<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>,<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>) :: <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>) counts []<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&gt; List.<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a> (fun (c1,_)(c2,_) -&gt; Char.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> c1 c2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; val count_chars : Char_tbl.<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> -&gt; (Char.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>) list = &lt;fun&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; (* basic seq from <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; # let seq = String.<a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a> &quot;hello world, and all the camels in it!&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; val seq : <a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a> Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = &lt;fun&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # count_chars seq<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : (Char.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>) list =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(' ', 7); ('!', 1); (',', 1); ('<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>', 3); ('<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>', 1); ('d', 2); ('<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>', 3);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; ('h', 2); ('<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>', 2); ('<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>', 6); ('m', 1); ('<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>', 2); ('o', 2); ('<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>', 1);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; ('<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>', 1); ('<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>', 2); ('<a href="camlinternalFormat.ml.html#L1198" title="ocaml/stdlib/camlinternalFormat.ml:1198">w</a>', 1)]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; (* &quot;abcabcabc...&quot; *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; # let seq2 =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Seq.<a href="seq.ml.html#L294" title="ocaml/stdlib/seq.ml:294">cycle</a> (String.<a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a> &quot;abc&quot;) |&gt; Seq.<a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> 31<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; val seq2 : <a href="bigarray.mli.html#L188" title="ocaml/stdlib/bigarray.mli:188">char</a> Seq.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = &lt;fun&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # String.<a href="buffer.ml.html#L315" title="ocaml/stdlib/buffer.ml:315">of_seq</a> seq2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : String.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = &quot;abcabcabcabcabcabcabcabcabcabca&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; # count_chars seq2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; - : (Char.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>) list = [('<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>', 11); ('b', 10); ('<a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a>', 10)]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">end<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> Map</span><span class="ocamlPreDef"> : </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Association <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a> over ordered types.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; This module implements applicative association <a href="camlinternalOO.ml.html#L402" title="ocaml/stdlib/camlinternalOO.ml:402">tables</a>, also known as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; finite maps or dictionaries, given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> total ordering function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; over the keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; All operations over maps are purely applicative (no side-effects).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; The implementation uses balanced binary trees, and therefore searching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; and insertion <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> time logarithmic in the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; For instance:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; module IntPairs =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; let <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> (x0,y0) (x1,y1) =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; match Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> x0 x1 with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 0 -&gt; Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> y0 y1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a> -&gt; <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; end<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; module PairsMap = Map.Make(IntPairs)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; let m = PairsMap.(<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> |&gt; <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (0,1) &quot;hello&quot; |&gt; <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (1,0) &quot;world&quot;)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; This creates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new module [PairsMap], with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> PairsMap.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; of maps from [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>] to ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. In this example, [m] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; values so its type is [<a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> PairsMap.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>].<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">module type </span><span class="PreProc">OrderedType</span><span class="ocamlSig"> </span><span class="Statement">=<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** A total ordering function over the keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-argument function [f] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f e1 e2] is <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> if the keys [e1] and [e2] are <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f e1 e2] is strictly negative if [e1] is smaller than [e2],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and [f e1 e2] is strictly positive if [e1] is greater than [e2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Example: <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable ordering function is the generic structural<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comparison function {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>}. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Input signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">module type </span><span class="PreProc">S</span><span class="ocamlSig"> </span><span class="Statement">=<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:maps Maps} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="Statement">!</span><span class="ocamlSig">+'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of maps from type [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] to type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> ~<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> ~<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> containing the same <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m], plus <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] to [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>]. If [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] was already bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in [m] to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value that is physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m] is returned unchanged (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [m]). Otherwise, the previous binding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] in [m] disappears.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L28" title="ocaml/stdlib/map.ml:28">add_to_list</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L28" title="ocaml/stdlib/map.ml:28">add_to_list</a> ~<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> ~<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> m] is [m] with [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] mapped to [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> :: Map.<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> m] if [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] was bound in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m] and [[<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]] otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> ~<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> ~f m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> containing the same <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m], except for the binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>]. Depending on the value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [y] where [y] is [f (<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> m)], the binding of [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; added, removed or updated. If [y] is [None], the binding is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removed if it <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>; otherwise, if [y] is [Some z] then [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is associated to [z] in the resulting <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.&nbsp; If [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>] was already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bound in [m] to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value that is physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [z], [m]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is returned unchanged (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [m]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.06 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L30" title="ocaml/stdlib/map.ml:30">singleton</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L30" title="ocaml/stdlib/map.ml:30">singleton</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns the <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>-element <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> that <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [y] for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> containing the same <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m], except for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] which is unbound in the returned <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] was not in [m], [m] is returned unchanged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [m]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a></span><span class="ocamlSig">:<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a> ~f m1 m2] computes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> whose keys are <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of the keys of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m1] and of [m2]. The presence of each such binding, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; corresponding value, is determined with the function [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; In terms of the [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a>] operation, we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> (<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a> f m1 m2) = f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> (<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m1) (<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m2)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for any <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], provided that [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> None None = None].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a> ~f m1 m2] computes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> whose keys are <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of the keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of [m1] and of [m2].&nbsp; When the same binding is defined in both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arguments, the function [f] is used to <a href="array.mli.html#L284" title="ocaml/stdlib/array.mli:284">combine</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> special case of [<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a>]: [<a href="map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a> f m1 m2] is equivalent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to [<a href="map.ml.html#L32" title="ocaml/stdlib/map.ml:32">merge</a> f' m1 m2], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - [f' _key None None = None]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - [f' _key (Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>) None = Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - [f' _key None (Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>) = Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - [f' <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> (Some v1) (Some v2) = f <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> v1 v2]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.03 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L36" title="ocaml/stdlib/map.ml:36">cardinal</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return the number of <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:<a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> Bindings} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return the list of all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The returned list is sorted in increasing order of keys with respect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the ordering [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>], where [Ord] is the argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; given to {!Map.Make}.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L38" title="ocaml/stdlib/map.ml:38">min_binding</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return the binding with the smallest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (with respect to the [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] ordering), or raise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Not_found] if the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L39" title="ocaml/stdlib/map.ml:39">min_binding_opt</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return the binding with the smallest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> in the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (with respect to the [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] ordering), or [None]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L40" title="ocaml/stdlib/map.ml:40">max_binding</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="map.ml.html#L38" title="ocaml/stdlib/map.ml:38">min_binding</a>}, but returns the binding with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the largest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> in the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L41" title="ocaml/stdlib/map.ml:41">max_binding_opt</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="map.ml.html#L39" title="ocaml/stdlib/map.ml:39">min_binding_opt</a>}, but returns the binding with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the largest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> in the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L42" title="ocaml/stdlib/map.ml:42">choose</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> binding of the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, or raise [Not_found] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. Which binding is chosen is unspecified,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; but <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> will be chosen for <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> maps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L43" title="ocaml/stdlib/map.ml:43">choose_opt</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> binding of the given <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, or [None] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. Which binding is chosen is unspecified,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; but <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> will be chosen for <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> maps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:searching Searching} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> value of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [m],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no binding for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] if the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> value of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in [m] is [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], or [None] if no binding for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a> ~f m], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically increasing function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns the binding of [m] with the lowest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] such that [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no such <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, [<a href="map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a> (fun <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> -&gt; Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0) m] will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the first binding [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>, <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] of [m] where [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (intuitively: [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> &gt;= <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]), or raise [Not_found] if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; any element of [m].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L47" title="ocaml/stdlib/map.ml:47">find_first_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L47" title="ocaml/stdlib/map.ml:47">find_first_opt</a> ~f m], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically increasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function, returns an option containing the binding of [m] with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] such that [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>], or [None] if no such <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L48" title="ocaml/stdlib/map.ml:48">find_last</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L48" title="ocaml/stdlib/map.ml:48">find_last</a> ~f m], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically decreasing function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns the binding of [m] with the highest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] such that [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no such <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L49" title="ocaml/stdlib/map.ml:49">find_last_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L49" title="ocaml/stdlib/map.ml:49">find_last_opt</a> ~f m], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically decreasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function, returns an option containing the binding of [m] with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the highest <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] such that [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>], or [None] if no such <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:traversing Traversing} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f m] applies [f] to all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> [m].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f] receives the <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> as first argument, and the associated value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; as second argument.&nbsp; The <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are passed to [f] in increasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; order with respect to the ordering over the type of the keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a></span><span class="ocamlSig">:<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a> ~f m ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes [(f kN dN ... (f k1 d1 <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>)...)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where [k1 ... kN] are the keys of all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in [m]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (in increasing order), and [d1 ... dN] are the associated <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:transforming Transforming} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> ~f m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with same domain as [m], where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; associated value [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] of all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replaced by the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the application of [f] to [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> are passed to [f] in increasing order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with respect to the ordering over the type of the keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L180" title="ocaml/stdlib/bytesLabels.mli:180">mapi</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}, but the function receives as arguments both the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> and the associated value for each binding of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> ~f m] returns the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> in [m]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that satisfy predicate [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>]. If every binding in [m] satisfies [f],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m] is returned unchanged (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [m])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> ~f m] applies the function [f] to every binding of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m], and builds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> from the results. For each binding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>, <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>)] in the <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - if [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] is [None] then [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] is not in the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - if [f <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] is [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>'] then the binding [(<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>, <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>')]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is in the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, the following function on maps whose values are lists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fun _k li -&gt; match li with [] -&gt; None | _::<a href="list.mli.html#L76" title="ocaml/stdlib/list.mli:76">tl</a> -&gt; Some <a href="list.mli.html#L76" title="ocaml/stdlib/list.mli:76">tl</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drops all <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] whose value is an <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> list, and pops<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the first element of each value that is non-<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> ~f m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of maps [(m1, m2)], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m1] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] that satisfy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predicate [f], and [m2] is the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [m] that do not satisfy [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> triple [(<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>, <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>, <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>)], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] whose <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is strictly less than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] is the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> with all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m] whose <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is strictly greater than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>] is [None] if [m] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> no binding for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] if [m] binds [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] to [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:predicates Predicates and comparisons} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L53" title="ocaml/stdlib/stack.ml:53">is_empty</a></span><span class="ocamlSig">: '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Test whether <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> or not. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> m] returns [true] if [m] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> binding for [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and [false] otherwise. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">cmp</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> ~cmp m1 m2] tests whether the maps [m1] and [m2] are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, that is, contain <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> keys and associate them with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.&nbsp; [cmp] is the equality predicate used to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> associated with the keys. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">cmp</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Total ordering between maps.&nbsp; The first argument is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> total ordering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used to <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> associated with <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> keys in the two maps. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> ~f m] checks if all the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; satisfy the predicate [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> ~f m] checks if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> binding of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; satisfies the predicate [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 3.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:converting Converting} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a> m] is {!<a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a>}[ m].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a> bs] adds the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [bs] to the <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in list order (if <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> is bound twice in [bs] the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; takes over).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Iterate on the whole <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, in ascending order of keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L67" title="ocaml/stdlib/map.ml:67">to_rev_seq</a></span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Iterate on the whole <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, in descending order of keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L68" title="ocaml/stdlib/map.ml:68">to_seq_from</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L68" title="ocaml/stdlib/map.ml:68">to_seq_from</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> m] iterates on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of the <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> of [m],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in ascending order of keys, from <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] or above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L313" title="ocaml/stdlib/buffer.ml:313">add_seq</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Add the given <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a> to the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>, in order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L315" title="ocaml/stdlib/buffer.ml:315">of_seq</a></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Build <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> from the given <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Output signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">module</span><span class="ocamlModSpec"> </span><span class="PreProc">Make</span><span class="ocamlSig"> </span><span class="ocamlMPRestr">:</span><span class="Statement"> functor </span><span class="ocamlModParam">(</span><span class="PreProc">Ord</span><span class="ocamlPreMPRestr"> </span><span class="ocamlMPRestr">:</span><span class="ocamlPreMPRestr"> </span><span class="PreProc">OrderedType</span><span class="ocamlModParam">)</span><span class="Statement"> -&gt;</span><span class="ocamlSig"> </span><span class="Constant">S<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">with</span><span class="ocamlSig"> </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="PreProc">Ord</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp;&nbsp; </span><span class="Statement">and</span><span class="ocamlSig"> </span><span class="Statement">type</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="PreProc">Map</span><span class="ocamlSig">.</span><span class="Constant">Make</span><span class="Statement">(</span><span class="Constant">Ord</span><span class="Statement">)</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Functor building an implementation of the <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> totally ordered type. *)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">end<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> Set</span><span class="ocamlPreDef"> : </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Sets over ordered types.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; This module implements the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> structure, given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> total ordering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; function over the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. All operations over sets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; are purely applicative (no side-effects).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; The implementation uses balanced binary trees, and is therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; reasonably efficient: insertion and membership <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; logarithmic in the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, for instance.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; The {!Make} functor constructs implementations for any type, given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; For instance:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; module IntPairs =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; let <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> (x0,y0) (x1,y1) =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; match Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> x0 x1 with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 0 -&gt; Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> y0 y1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a> -&gt; <a href="arg.ml.html#L398" title="ocaml/stdlib/arg.ml:398">c</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; end<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; module PairsSet = Set.Make(IntPairs)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; let m = PairsSet.(<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> |&gt; <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (2,3) |&gt; <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (5,7) |&gt; <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> (11,13))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; This creates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new module [PairsSet], with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new type [PairsSet.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; of sets of [<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>].<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">module type </span><span class="PreProc">OrderedType</span><span class="ocamlSig"> </span><span class="Statement">=<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">(** A total ordering function over the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> two-argument function [f] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f e1 e2] is <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> if the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> [e1] and [e2] are <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f e1 e2] is strictly negative if [e1] is smaller than [e2],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and [f e1 e2] is strictly positive if [e1] is greater than [e2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Example: <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable ordering function is the generic structural<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comparison function {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>}. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Input signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">module type </span><span class="PreProc">S</span><span class="ocamlSig"> </span><span class="Statement">=<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">sig<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:sets Sets} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The type of sets. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** The <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> containing all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plus [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] was already in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned unchanged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L30" title="ocaml/stdlib/map.ml:30">singleton</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L30" title="ocaml/stdlib/map.ml:30">singleton</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>-element <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> containing only [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> containing all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; except [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] was not in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned unchanged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Set <a href="map.ml.html#L35" title="ocaml/stdlib/map.ml:35">union</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L33" title="ocaml/stdlib/set.ml:33">inter</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Set intersection. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Test if two sets are <a href="set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L35" title="ocaml/stdlib/set.ml:35">diff</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Set difference: [<a href="set.ml.html#L35" title="ocaml/stdlib/set.ml:35">diff</a> <a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a> <a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that are not in [<a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L36" title="ocaml/stdlib/map.ml:36">cardinal</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return the number of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:<a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> Elements} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return the list of all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the given <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The returned list is sorted in increasing order with respect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the ordering [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>], where [Ord] is the argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; given to {!Set.Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L38" title="ocaml/stdlib/set.ml:38">min_elt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return the smallest element of the given <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (with respect to the [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] ordering), or raise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Not_found] if the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L39" title="ocaml/stdlib/set.ml:39">min_elt_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return the smallest element of the given <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (with respect to the [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] ordering), or [None]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L40" title="ocaml/stdlib/set.ml:40">max_elt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="set.ml.html#L38" title="ocaml/stdlib/set.ml:38">min_elt</a>}, but returns the largest element of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; given <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L41" title="ocaml/stdlib/set.ml:41">max_elt_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Same as {!<a href="set.ml.html#L39" title="ocaml/stdlib/set.ml:39">min_elt_opt</a>}, but returns the largest element of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; given <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L42" title="ocaml/stdlib/map.ml:42">choose</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of the given <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, or raise [Not_found] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. Which element is chosen is unspecified,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; but <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> will be chosen for <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> sets. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L43" title="ocaml/stdlib/map.ml:43">choose_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Return <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of the given <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, or [None] if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>. Which element is chosen is unspecified,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; but <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> will be chosen for <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> sets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:searching Searching} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the element of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] (according<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>]), or raise [Not_found] if no such element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.01 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the element of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] (according<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>]), or [None] if no such element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically increasing function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns the lowest element [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] such that [f <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no such element <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, [<a href="map.ml.html#L46" title="ocaml/stdlib/map.ml:46">find_first</a> (fun <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> -&gt; Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0) <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the first element [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] where [Ord.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &gt;= 0]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (intuitively: [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a> &gt;= <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]), or raise [Not_found] if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; any element of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L47" title="ocaml/stdlib/map.ml:47">find_first_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L47" title="ocaml/stdlib/map.ml:47">find_first_opt</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically increasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function, returns an option containing the lowest element [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; such that [f <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>], or [None] if no such element <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L48" title="ocaml/stdlib/map.ml:48">find_last</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L48" title="ocaml/stdlib/map.ml:48">find_last</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically decreasing function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns the highest element [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] such that [f <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or raises [Not_found] if no such element <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L49" title="ocaml/stdlib/map.ml:49">find_last_opt</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L49" title="ocaml/stdlib/map.ml:49">find_last_opt</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], where [f] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> monotonically decreasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function, returns an option containing the highest element [<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>] of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; such that [f <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>], or [None] if no such element <a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.05 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:traversing Traversing} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] applies [f] in turn to all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] are presented to [f] in increasing order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with respect to the ordering over the type of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="stack.ml.html#L59" title="ocaml/stdlib/stack.ml:59">fold</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes [(f xN ... (f x2 (f x1 <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>))...)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where [x1 ... xN] are the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>], in increasing order. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:transforming Transforming} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> whose <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are [f a0],[f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>]... [f<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aN], where [a0],[<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>]...[aN] are the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> are passed to [f] in increasing order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with respect to the ordering over the type of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If no element of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is changed by [f], [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unchanged. (If each <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> of [f] is physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>, the returned <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.04 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L54" title="ocaml/stdlib/map.ml:54">filter</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that satisfy predicate [f]. If [f] satisfies every element in [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned unchanged (the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function is then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 4.03 Physical equality was not ensured.*)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of all [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] for <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {[<a href="map.ml.html#L55" title="ocaml/stdlib/map.ml:55">filter_map</a> (fun <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> -&gt; if <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> mod 2 = 0 then Some (<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> / 2) else None) <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of halves of the even <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If no element of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is changed or dropped by [f] (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = Some <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] for each element [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]), then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is returned unchanged: the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is then physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.11 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L56" title="ocaml/stdlib/map.ml:56">partition</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pair of sets [(<a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>, <a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>)], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>] is the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that satisfy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predicate [f], and [<a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] is the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that do not satisfy [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L57" title="ocaml/stdlib/map.ml:57">split</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> triple [(<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>, present, <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>)], where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strictly less than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] is the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strictly greater than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>];<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [present] is [false] if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> no element <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or [true] if [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> an element <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:predicates Predicates and comparisons} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="stack.ml.html#L53" title="ocaml/stdlib/stack.ml:53">is_empty</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Test whether <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> is <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> or not. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] tests whether [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] belongs to the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a> <a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] tests whether the sets [<a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>] and [<a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, that is, contain <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Total ordering between sets. Can be used as the ordering function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for doing sets of sets. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> <a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a> <a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>] tests whether the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> [<a href="list.ml.html#L378" title="ocaml/stdlib/list.ml:378">s1</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> [<a href="list.ml.html#L379" title="ocaml/stdlib/list.ml:379">s2</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] checks if all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; satisfy the predicate [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> ~f <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] checks if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> satisfies the predicate [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** {1:converting Converting} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] is {!<a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>}[ <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a></span><span class="ocamlSig">: </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] creates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> from <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is usually more efficient than folding [<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a>] over the list,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; except perhaps for lists with many duplicated <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L68" title="ocaml/stdlib/map.ml:68">to_seq_from</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L68" title="ocaml/stdlib/map.ml:68">to_seq_from</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>] iterates on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="set.ml.html#L61" title="ocaml/stdlib/set.ml:61">subset</a> of the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in ascending order, from [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L293" title="ocaml/stdlib/buffer.ml:293">to_seq</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Iterate on the whole <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, in ascending order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="map.ml.html#L67" title="ocaml/stdlib/map.ml:67">to_rev_seq</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Iterate on the whole <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, in descending order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.12 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L313" title="ocaml/stdlib/buffer.ml:313">add_seq</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Add the given <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> to the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>, in order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="buffer.ml.html#L315" title="ocaml/stdlib/buffer.ml:315">of_seq</a></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; &nbsp; </span><span class="Comment">(** Build <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> from the given <a href="map.ml.html#L37" title="ocaml/stdlib/map.ml:37">bindings</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 4.07 *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="PreProc">end<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Output signature of the functor {!Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">module</span><span class="ocamlModSpec"> </span><span class="PreProc">Make</span><span class="ocamlSig"> </span><span class="ocamlMPRestr">:</span><span class="Statement"> functor </span><span class="ocamlModParam">(</span><span class="PreProc">Ord</span><span class="ocamlPreMPRestr"> </span><span class="ocamlMPRestr">:</span><span class="ocamlPreMPRestr"> </span><span class="PreProc">OrderedType</span><span class="ocamlModParam">)</span><span class="Statement"> -&gt;</span><span class="ocamlSig"> </span><span class="Constant">S<br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp; </span><span class="Statement">with</span><span class="ocamlSig"> </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="PreProc">Ord</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; &nbsp;&nbsp; </span><span class="Statement">and</span><span class="ocamlSig"> </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="PreProc">Set</span><span class="ocamlSig">.</span><span class="Constant">Make</span><span class="Statement">(</span><span class="Constant">Ord</span><span class="Statement">)</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Functor building an implementation of the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; given <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> totally ordered type. *)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">end<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
