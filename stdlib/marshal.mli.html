<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/marshal.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/marshal.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L63">to_channel</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L55">extern_flags</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 1997 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Marshaling of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> structures.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; This module provides functions to encode arbitrary <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> structures<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as sequences of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>, which can then be written on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; sent over <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> pipe or network connection.&nbsp; The <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> can then<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; be read back later, possibly in another process, and decoded back<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; into <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> structure. The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> for the byte sequences<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is compatible across all machines for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> given version of OCaml.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Warning: marshaling is currently not type-safe. The type<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of marshaled <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> is not transmitted along the value of the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; making it impossible to <a href="weak.ml.html#L58" title="ocaml/stdlib/weak.ml:58">check</a> that the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> read back possesses the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; type expected by the context. In particular, the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> type of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the [Marshal.from_*] functions is given as ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], but this is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; misleading: the returned OCaml value does not possess type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; for all ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]; it has <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>, unique type which cannot be determined<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; at compile-time.&nbsp; The programmer should explicitly give the expected<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; type of the returned value, using the following syntax:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; - [(Marshal.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a> chan : type)].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Anything can happen at run-time if the object in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> does not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; belong to the given type.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; Values of extensible variant types, for example exceptions (of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; extensible type [<a href="effect.ml.html#L18" title="ocaml/stdlib/effect.ml:18">exn</a>]), returned by the unmarshaller should not be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; pattern-matched over through [match ... with] or [try ... with],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; because unmarshalling does not preserve the information required for<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; matching their constructors. Structural equalities with other<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; extensible variant values does not work either.&nbsp; Most other uses such<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; as Printexc.<a href="int32.ml.html#L72" title="ocaml/stdlib/int32.ml:72">to_string</a>, will still work as expected.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The representation of marshaled values is not human-readable,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and uses <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> that are not printable characters. Therefore,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a> and <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> channels used in conjunction with [Marshal.<a href="#L63" title="ocaml/stdlib/marshal.mli:63">to_channel</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and [Marshal.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a>] must be opened in binary mode, using <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="stdlib.ml.html#L338" title="ocaml/stdlib/stdlib.ml:338">open_out_bin</a>] or [<a href="stdlib.ml.html#L412" title="ocaml/stdlib/stdlib.ml:412">open_in_bin</a>]; channels opened in text mode will<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; cause unmarshaling <a href="printexc.ml.html#L299" title="ocaml/stdlib/printexc.ml:299">errors</a> on platforms where text channels behave<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; differently than binary channels, <a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. Windows.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><a id="L55">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">extern_flags</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">No_sharing</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** Don'<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> preserve sharing *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Closures</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** Send function closures *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Compat_32</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** Ensure 32-bit compatibility *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">Compression</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** Compress the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> if possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><span class="Comment">(** The flags to the [Marshal.to_*] functions below. *)<br/></li>
<li></span><br/></li>
<li><a id="L63">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">to_channel</span></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L308" title="ocaml/stdlib/stdlib.ml:308">out_channel</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L55" title="ocaml/stdlib/marshal.mli:55">extern_flags</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><span class="Comment">(** [Marshal.<a href="#L63" title="ocaml/stdlib/marshal.mli:63">to_channel</a> chan <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> flags] writes the representation<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] on channel [chan]. The [flags] argument is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; possibly <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> list of flags that governs the marshaling<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; behavior with respect to sharing, functional values, and compatibility<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; between 32- and 64-bit platforms.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If [flags] does not contain [Marshal.No_sharing], circularities<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and sharing inside the value [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] are detected and preserved<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in the sequence of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> produced. In particular, this<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; guarantees that marshaling always terminates. Sharing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; between values marshaled by successive calls to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [Marshal.<a href="#L63" title="ocaml/stdlib/marshal.mli:63">to_channel</a>] is neither detected nor preserved, though.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If [flags] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> [Marshal.No_sharing], sharing is <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; This results in faster marshaling if [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> no shared<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; substructures, but may cause slower marshaling and larger<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; byte representations if [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] actually <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> sharing,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; or even non-termination if [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> cycles.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If [flags] does not contain [Marshal.Closures], marshaling fails<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; when it encounters <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> functional value inside [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]: only 'pure' <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; structures, containing neither functions nor objects, can safely be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; transmitted between different programs. If [flags] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [Marshal.Closures], functional values will be marshaled as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> in the code of the program together with the values<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; corresponding to the free variables captured in the <a href="camlinternalOO.ml.html#L59" title="ocaml/stdlib/camlinternalOO.ml:59">closure</a>.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; this case, the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> of marshaling can only be read back in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; processes that run exactly the same program, with exactly the same<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; compiled code. (This is checked at un-marshaling time, using an MD5<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; digest of the code transmitted along with the code <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a>.)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; The exact definition of which free variables are captured in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalOO.ml.html#L59" title="ocaml/stdlib/camlinternalOO.ml:59">closure</a> is not specified and can vary between bytecode and native<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; code (and according to optimization flags).&nbsp; In particular, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; function value accessing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> global reference may or may not include<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the reference in its <a href="camlinternalOO.ml.html#L59" title="ocaml/stdlib/camlinternalOO.ml:59">closure</a>.&nbsp; If it does, unmarshaling the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; corresponding <a href="camlinternalOO.ml.html#L59" title="ocaml/stdlib/camlinternalOO.ml:59">closure</a> will <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new reference, different from<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the global <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If [flags] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> [Marshal.Compression], the marshaled <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; representing value [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] is compressed <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> being written to<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; channel [chan].&nbsp; Decompression takes place automatically in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the unmarshaling functions {!Stdlib.<a href="stdlib.mli.html#L1146" title="ocaml/stdlib/stdlib.mli:1146">input_value</a>}, {!Marshal.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a>},<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Marshal.<a href="lexing.mli.html#L97" title="ocaml/stdlib/lexing.mli:97">from_string</a>}, etc.&nbsp; For large values [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], compression<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; typically reduces the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> of marshaled <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> by <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> factor 2 to 4,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; but slows down marshaling and, to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> lesser extent, unmarshaling.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Compression is not supported on <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> platforms; in this case,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the [Marshal.Compression] flag is silently <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a> and uncompressed<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> is written to channel [chan].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If [flags] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> [Marshal.Compat_32], marshaling fails when<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; it encounters an integer value outside the range [[-2{^30}, 2{^30}-1]]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of integers that are representable on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 32-bit platform.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; ensures that marshaled <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> generated on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 64-bit platform can be<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; safely read back on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 32-bit platform.&nbsp; If [flags] does not<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; contain [Marshal.Compat_32], integer values outside the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; range [[-2{^30}, 2{^30}-1]] are marshaled, and can be read back on<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 64-bit platform, but will cause an <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> at un-marshaling time<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; when read back on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 32-bit platform.&nbsp; The [Mashal.Compat_32] flag<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; only matters when marshaling is performed on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 64-bit platform;<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; it has no effect if marshaling is performed on <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> 32-bit platform.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @raise Failure if [chan] is not in binary mode.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> 5.1 Compression mode was not supported<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="buffer.ml.html#L47" title="ocaml/stdlib/buffer.ml:47">to_bytes</a></span> :<br/></li>
<li>&nbsp; '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L55" title="ocaml/stdlib/marshal.mli:55">extern_flags</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_output_value_to_bytes&quot;<br/></li>
<li></span><span class="Comment">(** [Marshal.<a href="buffer.ml.html#L47" title="ocaml/stdlib/buffer.ml:47">to_bytes</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> flags] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence containing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the representation of [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The [flags] argument has the same meaning as for<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Marshal.<a href="#L63" title="ocaml/stdlib/marshal.mli:63">to_channel</a>}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L72" title="ocaml/stdlib/int32.ml:72">to_string</a></span> :<br/></li>
<li>&nbsp; '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L55" title="ocaml/stdlib/marshal.mli:55">extern_flags</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_output_value_to_string&quot;<br/></li>
<li></span><span class="Comment">(** Same as [<a href="buffer.ml.html#L47" title="ocaml/stdlib/buffer.ml:47">to_bytes</a>] but <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> instead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="marshal.ml.html#L33" title="ocaml/stdlib/marshal.ml:33">to_buffer</a></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L55" title="ocaml/stdlib/marshal.mli:55">extern_flags</a></span> <span class="Type">list</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [Marshal.<a href="marshal.ml.html#L33" title="ocaml/stdlib/marshal.ml:33">to_buffer</a> buff <a href="bigarray.ml.html#L275" title="ocaml/stdlib/bigarray.ml:275">ofs</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> flags] marshals the value [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; storing its byte representation in the sequence [buff],<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; starting at <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> [<a href="bigarray.ml.html#L275" title="ocaml/stdlib/bigarray.ml:275">ofs</a>], and writing at most<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>.&nbsp; It returns the number of <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; actually written to the sequence. If the byte representation<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] does not fit in [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] characters, the exception [Failure]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; is raised. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a></span> : <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L307" title="ocaml/stdlib/stdlib.ml:307">in_channel</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** [Marshal.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a> chan] reads from channel [chan] the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; byte representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> structured value, as produced by<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the [Marshal.to_*] functions, and reconstructs and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; returns the corresponding value.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise End_of_file if [chan] is already at the end of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @raise Failure if the end of the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is reached during<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; unmarshalling itself or if [chan] is not in binary mode.*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="marshal.ml.html#L55" title="ocaml/stdlib/marshal.ml:55">from_bytes</a></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** [Marshal.<a href="marshal.ml.html#L55" title="ocaml/stdlib/marshal.ml:55">from_bytes</a> buff <a href="bigarray.ml.html#L275" title="ocaml/stdlib/bigarray.ml:275">ofs</a>] unmarshals <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> structured value<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; like {!Marshal.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a>} does, except that the byte<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; representation is not read from <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> channel, but taken from<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the byte sequence [buff], starting at <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="bigarray.ml.html#L275" title="ocaml/stdlib/bigarray.ml:275">ofs</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; The byte sequence is not mutated.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.02 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="lexing.mli.html#L97" title="ocaml/stdlib/lexing.mli:97">from_string</a></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">(** Same as [<a href="marshal.ml.html#L55" title="ocaml/stdlib/marshal.ml:55">from_bytes</a>] but <a href="seq.ml.html#L364" title="ocaml/stdlib/seq.ml:364">take</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> as argument instead of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; byte sequence. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="marshal.ml.html#L48" title="ocaml/stdlib/marshal.ml:48">header_size</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** The <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> representing <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> marshaled value are composed of<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fixed-<a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> header and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> variable-sized <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> part,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; whose <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> can be determined from the header.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Marshal.<a href="marshal.ml.html#L48" title="ocaml/stdlib/marshal.ml:48">header_size</a>} is the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>, in <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>, of the header.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Marshal.<a href="marshal.ml.html#L49" title="ocaml/stdlib/marshal.ml:49">data_size</a>}[ buff <a href="bigarray.ml.html#L275" title="ocaml/stdlib/bigarray.ml:275">ofs</a>] is the <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>, in <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; of the <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> part, assuming <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid header is stored in<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [buff] starting at <a href="lexing.mli.html#L20" title="ocaml/stdlib/lexing.mli:20">position</a> [<a href="bigarray.ml.html#L275" title="ocaml/stdlib/bigarray.ml:275">ofs</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Finally, {!Marshal.<a href="marshal.ml.html#L53" title="ocaml/stdlib/marshal.ml:53">total_size</a>} [buff <a href="bigarray.ml.html#L275" title="ocaml/stdlib/bigarray.ml:275">ofs</a>] is the total <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; in <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a>, of the marshaled value.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Both {!Marshal.<a href="marshal.ml.html#L49" title="ocaml/stdlib/marshal.ml:49">data_size</a>} and {!Marshal.<a href="marshal.ml.html#L53" title="ocaml/stdlib/marshal.ml:53">total_size</a>} raise [Failure]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; if [buff], [<a href="bigarray.ml.html#L275" title="ocaml/stdlib/bigarray.ml:275">ofs</a>] does not contain <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid header.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; To read the byte representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> marshaled value into<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> byte sequence, the program needs to read first<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!Marshal.<a href="marshal.ml.html#L48" title="ocaml/stdlib/marshal.ml:48">header_size</a>} <a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a> into the sequence,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; then determine the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the remainder of the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; representation using {!Marshal.<a href="marshal.ml.html#L49" title="ocaml/stdlib/marshal.ml:49">data_size</a>},<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> sure the sequence is large enough to hold the remaining<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>, then read it, and finally call {!Marshal.<a href="marshal.ml.html#L55" title="ocaml/stdlib/marshal.ml:55">from_bytes</a>}<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; to unmarshal the value. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="marshal.ml.html#L49" title="ocaml/stdlib/marshal.ml:49">data_size</a></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** See {!Marshal.<a href="marshal.ml.html#L48" title="ocaml/stdlib/marshal.ml:48">header_size</a>}.*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="marshal.ml.html#L53" title="ocaml/stdlib/marshal.ml:53">total_size</a></span> : <span class="ocamlLCIdentifier"><a href="digest.ml.html#L29" title="ocaml/stdlib/digest.ml:29">bytes</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** See {!Marshal.<a href="marshal.ml.html#L48" title="ocaml/stdlib/marshal.ml:48">header_size</a>}.*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="marshal.ml.html#L70" title="ocaml/stdlib/marshal.ml:70">compression_supported</a></span> : <span class="Type">unit</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** Indicates whether the compressed <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> is supported.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [Marshal.<a href="marshal.ml.html#L70" title="ocaml/stdlib/marshal.ml:70">compression_supported</a>()] is [true], compressed <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is unmarshaled safely by {!Stdlib.<a href="stdlib.mli.html#L1146" title="ocaml/stdlib/stdlib.mli:1146">input_value</a>}, {!Marshal.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a>},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Marshal.<a href="lexing.mli.html#L97" title="ocaml/stdlib/lexing.mli:97">from_string</a>} and related functions.&nbsp; Moreover, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [Marshal.Compression] flag is honored by the {!Marshal.<a href="#L63" title="ocaml/stdlib/marshal.mli:63">to_channel</a>},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Marshal.<a href="int32.ml.html#L72" title="ocaml/stdlib/int32.ml:72">to_string</a>} and related functions, resulting in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; production of compressed <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If [Marshal.<a href="marshal.ml.html#L70" title="ocaml/stdlib/marshal.ml:70">compression_supported</a>()] is [false], compressed <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; causes {!Stdlib.<a href="stdlib.mli.html#L1146" title="ocaml/stdlib/stdlib.mli:1146">input_value</a>}, {!Marshal.<a href="lexing.mli.html#L92" title="ocaml/stdlib/lexing.mli:92">from_channel</a>},<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Marshal.<a href="lexing.mli.html#L97" title="ocaml/stdlib/lexing.mli:97">from_string</a>} and related functions to fail and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [Failure] exception to be raised.&nbsp; Moreover,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Marshal.<a href="#L63" title="ocaml/stdlib/marshal.mli:63">to_channel</a>}, {!Marshal.<a href="int32.ml.html#L72" title="ocaml/stdlib/int32.ml:72">to_string</a>} and related functions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ignore the [Marshal.Compression] flag and produce uncompressed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1<br/></li>
<li></span><span class="Comment">*)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
