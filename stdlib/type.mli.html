<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/type.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/type.mli - ocaml</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L22">eq</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; The OCaml programmers&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2022 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Type introspection.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:witness Type equality witness} *)<br/></li>
<li></span><br/></li>
<li><a id="L22">&#x200c;</a><span class="Statement">type</span> <span class="Statement">(_</span>, <span class="Statement">_)</span> <span class="ocamlLCIdentifier"><span class="linkable">eq</span></span> <span class="Statement">=</span> <span class="Constant">Equal</span>: <span class="Statement">(</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span>, '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span> <span class="ocamlLCIdentifier"><span class="linkable">eq</span></span> <span class="Comment">(** *)<br/></li>
<li></span><span class="Comment">(** The purpose of [<a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a>] is to represent type equalities that may not otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; be known by the type checker (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.g. because they may depend on dynamic <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; A value of type [(<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>, b) <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a>] represents the fact that types [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] and [b] are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; If <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> has <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value [<a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a> : (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>, b) <a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a>] that proves types [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] and [b] are <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> can use it to convert <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value of type [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value of type [b] by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; pattern matching on [Equal]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let cast (type <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>) (type b) (Equal : (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>, b) Type.<a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a>) (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> : <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>) : b = <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; At runtime, this function simply returns its second argument unchanged.<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:identifiers Type identifiers} *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Type identifiers.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; A type identifier is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value that denotes <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> type. Given two type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; identifiers, they can be tested for {{!Id.provably_equal}equality} to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; prove they denote the same type. Note that:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - Unequal identifiers do not imply unequal types: <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> given type can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; denoted by more than <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> identifier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - Type identifiers can be marshalled, but they <a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new, distinct,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; identity on unmarshalling, so the equalities are lost.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; See an {{!Id.example}example} of use. *)<br/></li>
<li></span><span class="Statement">module</span><span class="PreProc"> Id</span><span class="ocamlPreDef"> : </span><span class="PreProc">sig<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1:ids Type identifiers} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="Statement">!</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The type for identifiers for type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a></span><span class="ocamlSig"> : </span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> ()] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new type identifier. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">uid</span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [uid <a href="domain.mli.html#L45" title="ocaml/stdlib/domain.mli:45">id</a>] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> runtime unique identifier for [<a href="domain.mli.html#L45" title="ocaml/stdlib/domain.mli:45">id</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">provably_equal</span><span class="ocamlSig"> : '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier">b</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig">, '</span><span class="ocamlLCIdentifier">b</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L651" title="ocaml/stdlib/camlinternalFormat.ml:651">eq</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [provably_equal i0 i1] is [Some Equal] if identifier [i0] is <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to [i1] and [None] otherwise. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1:example Example}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; The following shows how type identifiers can be used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; implement <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> simple heterogeneous <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>-value dictionary. In contrast to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; {!Stdlib.Map} values whose keys <a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single, homogeneous type of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; values, this dictionary can associate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> different type of value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to each <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>.<br/></li>
<li></span><span class="Comment">{[<br/></li>
<li></span><span class="Comment">(** Heterogeneous dictionaries. *)<br/></li>
<li></span><span class="Comment">module Dict : sig<br/></li>
<li></span><span class="Comment">&nbsp; type <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">&nbsp; (** The type for dictionaries. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; type '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; (** The type for keys binding values of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; val <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> : unit -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a><br/></li>
<li></span><span class="Comment">&nbsp; (** [<a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> ()] is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new dictionary <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; val <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> : <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">&nbsp; (** [<a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a>] is the <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> dictionary. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; val <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> : '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> -&gt; <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> -&gt; <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">&nbsp; (** [<a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> d] is [d] with [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] bound to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; val <a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> : '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> -&gt; <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> -&gt; <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">&nbsp; (** [<a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> d] is [d] with the <a href="bytes.ml.html#L665" title="ocaml/stdlib/bytes.ml:665">last</a> binding of [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] removed. *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; val <a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> : '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> -&gt; <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> -&gt; '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> option<br/></li>
<li></span><span class="Comment">&nbsp; (** [<a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> d] is the binding of [<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>] in [d], if any. *)<br/></li>
<li></span><span class="Comment">end = struct<br/></li>
<li></span><span class="Comment">&nbsp; type '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> = '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> Type.Id.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">&nbsp; type binding = B : '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> * '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> -&gt; binding<br/></li>
<li></span><span class="Comment">&nbsp; type <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> = (<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> * binding) list<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; let <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> () = Type.Id.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> ()<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="bytesLabels.mli.html#L86" title="ocaml/stdlib/bytesLabels.mli:86">empty</a> = []<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a> d = (Type.Id.uid <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>, B (<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>, <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>)) :: d<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="ephemeron.mli.html#L94" title="ocaml/stdlib/ephemeron.mli:94">remove</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> d = List.<a href="list.mli.html#L429" title="ocaml/stdlib/list.mli:429">remove_assoc</a> (Type.Id.uid <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>) d<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> : type <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>. <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="ephemeron.mli.html#L87" title="ocaml/stdlib/ephemeron.mli:87">key</a> -&gt; <a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a> -&gt; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> option = fun <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> d -&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; match List.<a href="list.mli.html#L398" title="ocaml/stdlib/list.mli:398">assoc_opt</a> (Type.Id.uid <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>) d with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; | None -&gt; None<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; | Some (B (<a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>', <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>)) -&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; match Type.Id.provably_equal <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a> <a href="scanf.ml.html#L1464" title="ocaml/stdlib/scanf.ml:1464">k</a>' with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; | Some Type.Equal -&gt; Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; | None -&gt; assert false<br/></li>
<li></span><span class="Comment">end<br/></li>
<li></span><span class="Comment">]}<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><span class="PreProc">end<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
