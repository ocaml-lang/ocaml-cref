<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/float.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/float.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L536">append</a></li>
<li><a href="#L870">append</a></li>
<li><a href="#L563">blit</a></li>
<li><a href="#L897">blit</a></li>
<li><a href="#L440">compare</a></li>
<li><a href="#L542">concat</a></li>
<li><a href="#L876">concat</a></li>
<li><a href="#L553">copy</a></li>
<li><a href="#L887">copy</a></li>
<li><a href="#L524">create</a></li>
<li><a href="#L858">create</a></li>
<li><a href="#L447">equal</a></li>
<li><a href="#L644">exists</a></li>
<li><a href="#L978">exists</a></li>
<li><a href="#L721">fast_sort</a></li>
<li><a href="#L1055">fast_sort</a></li>
<li><a href="#L557">fill</a></li>
<li><a href="#L891">fill</a></li>
<li><a href="#L665">find_index</a></li>
<li><a href="#L999">find_index</a></li>
<li><a href="#L673">find_map</a></li>
<li><a href="#L1007">find_map</a></li>
<li><a href="#L678">find_mapi</a></li>
<li><a href="#L1012">find_mapi</a></li>
<li><a href="#L659">find_opt</a></li>
<li><a href="#L993">find_opt</a></li>
<li><a href="#L614">fold_left</a></li>
<li><a href="#L948">fold_left</a></li>
<li><a href="#L619">fold_right</a></li>
<li><a href="#L953">fold_right</a></li>
<li><a href="#L639">for_all</a></li>
<li><a href="#L973">for_all</a></li>
<li><a href="#L509">get</a></li>
<li><a href="#L843">get</a></li>
<li><a href="#L495">hash</a></li>
<li><a href="#L529">init</a></li>
<li><a href="#L863">init</a></li>
<li><a href="#L585">iter</a></li>
<li><a href="#L919">iter</a></li>
<li><a href="#L626">iter2</a></li>
<li><a href="#L960">iter2</a></li>
<li><a href="#L590">iteri</a></li>
<li><a href="#L924">iteri</a></li>
<li><a href="#L506">length</a></li>
<li><a href="#L840">length</a></li>
<li><a href="#L520">make</a></li>
<li><a href="#L854">make</a></li>
<li><a href="#L595">map</a></li>
<li><a href="#L929">map</a></li>
<li><a href="#L631">map2</a></li>
<li><a href="#L965">map2</a></li>
<li><a href="#L745">map_from_array</a></li>
<li><a href="#L1079">map_from_array</a></li>
<li><a href="#L599">map_inplace</a></li>
<li><a href="#L933">map_inplace</a></li>
<li><a href="#L740">map_to_array</a></li>
<li><a href="#L1074">map_to_array</a></li>
<li><a href="#L604">mapi</a></li>
<li><a href="#L938">mapi</a></li>
<li><a href="#L609">mapi_inplace</a></li>
<li><a href="#L943">mapi_inplace</a></li>
<li><a href="#L456">max</a></li>
<li><a href="#L474">max_num</a></li>
<li><a href="#L649">mem</a></li>
<li><a href="#L983">mem</a></li>
<li><a href="#L654">mem_ieee</a></li>
<li><a href="#L988">mem_ieee</a></li>
<li><a href="#L450">min</a></li>
<li><a href="#L462">min_max</a></li>
<li><a href="#L481">min_max_num</a></li>
<li><a href="#L467">min_num</a></li>
<li><a href="#L49">minus_one</a></li>
<li><a href="#L577">of_list</a></li>
<li><a href="#L911">of_list</a></li>
<li><a href="#L736">of_seq</a></li>
<li><a href="#L1070">of_seq</a></li>
<li><a href="#L45">one</a></li>
<li><a href="#L488">seeded_hash</a></li>
<li><a href="#L514">set</a></li>
<li><a href="#L848">set</a></li>
<li><a href="#L687">sort</a></li>
<li><a href="#L1021">sort</a></li>
<li><a href="#L712">stable_sort</a></li>
<li><a href="#L1046">stable_sort</a></li>
<li><a href="#L545">sub</a></li>
<li><a href="#L879">sub</a></li>
<li><a href="#L574">to_list</a></li>
<li><a href="#L908">to_list</a></li>
<li><a href="#L727">to_seq</a></li>
<li><a href="#L1061">to_seq</a></li>
<li><a href="#L731">to_seqi</a></li>
<li><a href="#L1065">to_seqi</a></li>
<li><a href="#L41">zero</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L202">fpclass</a></li>
<li><a href="#L437">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Xavier Leroy, projet Cristal, INRIA Rocquencourt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Nicolas Ojeda Bar, LexiFi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2018 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(* </span><span class="Todo">NOTE</span><span class="Comment">:<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>.template.mli, run tools/sync_stdlib_docs after editing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; it to generate <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>.mli.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; If this <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>.mli, do not edit it directly -- edit<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; templates/<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>.template.mli instead.<br/></li>
<li></span><span class="Comment"> *)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Floating-point arithmetic.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; OCaml'<a href="camlinternalFormat.ml.html#L2702" title="ocaml/stdlib/camlinternalFormat.ml:2702">s</a> floating-point numbers follow the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; IEEE 754 standard, using double <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a> (64 <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a>) numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Floating-point operations never raise an exception on overflow,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; underflow, division by <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, etc.&nbsp; Instead, special IEEE numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; are returned as appropriate, such as [<a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>] for [1.0 /. 0.0],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="stdlib.ml.html#L181" title="ocaml/stdlib/stdlib.ml:181">neg_infinity</a>] for [-1.0 /. 0.0], and [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] ('not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number')<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; for [0.0 /. 0.0].&nbsp; These special numbers then propagate through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; floating-point computations as expected: for instance,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [1.0 /. <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>] is [0.0], basic arithmetic operations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ([+.], [-.], [*.], [/.]) with [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as an argument <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], ...<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.07<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><a id="L41">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">zero</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The floating point 0.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L45">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">one</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The floating-point 1.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L49">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">minus_one</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The floating-point -1.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L28" title="ocaml/stdlib/complex.ml:28">neg</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%negfloat&quot;<br/></li>
<li></span><span class="Comment">(** Unary negation. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="ephemeron.mli.html#L93" title="ocaml/stdlib/ephemeron.mli:93">add</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%addfloat&quot;<br/></li>
<li></span><span class="Comment">(** Floating-point addition. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%subfloat&quot;<br/></li>
<li></span><span class="Comment">(** Floating-point subtraction. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L32" title="ocaml/stdlib/complex.ml:32">mul</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%mulfloat&quot;<br/></li>
<li></span><span class="Comment">(** Floating-point multiplication. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L35" title="ocaml/stdlib/complex.ml:35">div</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%divfloat&quot;<br/></li>
<li></span><span class="Comment">(** Floating-point division. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">fma</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Constant">&quot;caml_fma_float&quot;</span> <span class="Constant">&quot;caml_fma&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [fma <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y z] returns [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> * y + z], with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> best effort for computing<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; this expression with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> single rounding, using either hardware<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; instructions (providing full IEEE compliance) or <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> software<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; emulation.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; On 64-bit Cygwin, 64-bit mingw-w64 and MSVC 2017 and earlier, this function<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; may be emulated owing to known bugs on limitations on these platforms.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Note: since software emulation of the fma is costly, <a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> sure that you are<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; using hardware fma support if performance matters.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">rem</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_fmod_float&quot;</span> <span class="Constant">&quot;fmod&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [rem <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] returns the remainder of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] with respect to [b].&nbsp; The returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; value is [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> -. <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> *. b], where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the quotient [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> /. b] rounded towards<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a> to an integer. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L48" title="ocaml/stdlib/int32.ml:48">succ</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L48" title="ocaml/stdlib/int32.ml:48">succ</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the floating point number <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> after [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the smallest floating-point number greater than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].&nbsp; See also<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!next_after}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L49" title="ocaml/stdlib/int32.ml:49">pred</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L49" title="ocaml/stdlib/int32.ml:49">pred</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the floating-point number <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a> <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; the greatest floating-point number smaller than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].&nbsp; See also<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; {!next_after}.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L50" title="ocaml/stdlib/int32.ml:50">abs</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%absfloat&quot;<br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L50" title="ocaml/stdlib/int32.ml:50">abs</a> f] returns the absolute value of [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** Positive <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L181" title="ocaml/stdlib/stdlib.ml:181">neg_infinity</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** Negative <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** A special floating-point value denoting the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; undefined operation such as [0.0 /. 0.0].&nbsp; Stands for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; 'not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number'.&nbsp; Any floating-point operation with [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument returns [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>, unless otherwise specified in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; IEEE 754 standard.&nbsp; As for floating-point comparisons,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [=], [&lt;], [&lt;=], [&gt;] and [&gt;=] <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> [false] and [&lt;&gt;] returns [true]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; if <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> or both of their arguments is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] is [<a href="float.ml.html#L34" title="ocaml/stdlib/float.ml:34">quiet_nan</a>] since 5.1; it was <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> signaling NaN <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="float.ml.html#L38" title="ocaml/stdlib/float.ml:38">signaling_nan</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** Signaling NaN. The corresponding signals do not raise OCaml exception,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; but the value can be useful for interoperability with C libraries.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="float.ml.html#L34" title="ocaml/stdlib/float.ml:34">quiet_nan</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** Quiet NaN.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The constant <a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The largest positive finite value of type [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="stdlib.ml.html#L187" title="ocaml/stdlib/stdlib.ml:187">min_float</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The smallest positive, non-<a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, non-denormalized value of type [<a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="float.ml.html#L46" title="ocaml/stdlib/float.ml:46">epsilon</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** The difference between [1.0] and the smallest exactly representable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; floating-point number greater than [1.0]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="float.ml.html#L39" title="ocaml/stdlib/float.ml:39">is_finite</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="float.ml.html#L39" title="ocaml/stdlib/float.ml:39">is_finite</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [true] if and only if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is finite <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>., not infinite and<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; not {!<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="float.ml.html#L40" title="ocaml/stdlib/float.ml:40">is_infinite</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="float.ml.html#L40" title="ocaml/stdlib/float.ml:40">is_infinite</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [true] if and only if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is {!<a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>} or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!<a href="stdlib.ml.html#L181" title="ocaml/stdlib/stdlib.ml:181">neg_infinity</a>}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="float.ml.html#L41" title="ocaml/stdlib/float.ml:41">is_nan</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="float.ml.html#L41" title="ocaml/stdlib/float.ml:41">is_nan</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [true] if and only if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number (see {!<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>}).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="float.ml.html#L116" title="ocaml/stdlib/float.ml:116">is_integer</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** [<a href="float.ml.html#L116" title="ocaml/stdlib/float.ml:116">is_integer</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [true] if and only if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is an integer.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="uchar.mli.html#L65" title="ocaml/stdlib/uchar.mli:65">of_int</a></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%floatofint&quot;<br/></li>
<li></span><span class="Comment">(** Convert an integer to floating-point. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="uchar.mli.html#L74" title="ocaml/stdlib/uchar.mli:74">to_int</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;%intoffloat&quot;<br/></li>
<li></span><span class="Comment">(** Truncate the given floating-point number to an integer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is unspecified if the argument is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] or falls outside the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; range of representable integers. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="bytesLabels.mli.html#L93" title="ocaml/stdlib/bytesLabels.mli:93">of_string</a></span> : <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_float_of_string&quot;<br/></li>
<li></span><span class="Comment">(** Convert the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>.&nbsp; The <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is read in decimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (by default) or in hexadecimal (marked by [0x] or [0X]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> of decimal floating-point numbers is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [ [-] dd.ddd (<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>|E) [+|-] dd ], where [d] stands for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> decimal digit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="printexc.ml.html#L253" title="ocaml/stdlib/printexc.ml:253">format</a> of hexadecimal floating-point numbers is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [ [-] 0(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>|X) hh.hhh (<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>|P) [+|-] dd ], where [h] stands for an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; hexadecimal digit and [d] for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> decimal digit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; In both cases, at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the integer and fractional parts must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; given; the exponent part is optional.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The [_] (underscore) character can appear anywhere in the <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and is <a href="camlinternalFormat.ml.html#L2403" title="ocaml/stdlib/camlinternalFormat.ml:2403">ignored</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Depending on the execution platforms, other representations of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; floating-point numbers can be accepted, but should not be relied upon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; @raise Failure if the given <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> is not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L76" title="ocaml/stdlib/int32.ml:76">of_string_opt</a></span>: <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Type">option<br/></li>
<li></span><span class="Comment">(** Same as [<a href="bytesLabels.mli.html#L93" title="ocaml/stdlib/bytesLabels.mli:93">of_string</a>], but returns [None] instead of raising. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">val</span> <span class="ocamlLCIdentifier"><a href="int32.ml.html#L72" title="ocaml/stdlib/int32.ml:72">to_string</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a><br/></li>
<li></span><span class="Comment">(** Return <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="digest.ml.html#L26" title="ocaml/stdlib/digest.ml:26">string</a> representation of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floating-point number.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This conversion can involve <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> loss of <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a>. For greater <a href="gc.mli.html#L113" title="ocaml/stdlib/gc.mli:113">control</a> over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the manner in which the number is printed, see {!Printf}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; This function is an alias for {!Stdlib.<a href="stdlib.ml.html#L287" title="ocaml/stdlib/stdlib.ml:287">string_of_float</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L202">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">fpclass</span></span> <span class="Statement">=</span> <span class="PreProc">Stdlib</span>.<span class="ocamlLCIdentifier"><span class="linkable">fpclass</span></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">FP_normal</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** Normal number, <a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> of the below *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">FP_subnormal</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** Number very <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> to 0.0, has reduced <a href="camlinternalFormat.ml.html#L2551" title="ocaml/stdlib/camlinternalFormat.ml:2551">precision</a> *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">FP_zero</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** Number is 0.0 or -0.0 *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">FP_infinite</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">(** Number is positive or negative <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a> *)<br/></li>
<li></span>&nbsp; <span class="Statement">|</span> <span class="Constant">FP_nan</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">(** Not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number: <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of an undefined operation *)<br/></li>
<li></span><span class="Comment">(** The five classes of floating-point numbers, as determined by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the {!classify_float} function. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">classify_float</span> : <span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">])</span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="#L202" title="ocaml/stdlib/float.mli:202">fpclass</a></span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Constant">&quot;caml_classify_float&quot;</span> <span class="Constant">&quot;caml_classify_float_unboxed&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Return the class of the given floating-point number:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; normal, subnormal, <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, infinite, or not <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L79" title="ocaml/stdlib/complex.ml:79">pow</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_power_float&quot;</span> <span class="Constant">&quot;<a href="complex.ml.html#L79" title="ocaml/stdlib/complex.ml:79">pow</a>&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exponentiation. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L57" title="ocaml/stdlib/complex.ml:57">sqrt</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_sqrt_float&quot;</span> <span class="Constant">&quot;<a href="complex.ml.html#L57" title="ocaml/stdlib/complex.ml:57">sqrt</a>&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Square root. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">cbrt</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_cbrt_float&quot;</span> <span class="Constant">&quot;caml_cbrt&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Cube root.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L74" title="ocaml/stdlib/complex.ml:74">exp</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_exp_float&quot;</span> <span class="Constant">&quot;<a href="complex.ml.html#L74" title="ocaml/stdlib/complex.ml:74">exp</a>&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Exponential. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">exp2</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_exp2_float&quot;</span> <span class="Constant">&quot;caml_exp2&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Base 2 exponential function.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier"><a href="complex.ml.html#L77" title="ocaml/stdlib/complex.ml:77">log</a></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_log_float&quot;</span> <span class="Constant">&quot;<a href="complex.ml.html#L77" title="ocaml/stdlib/complex.ml:77">log</a>&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Natural logarithm. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">log10</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_log10_float&quot;</span> <span class="Constant">&quot;log10&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Base 10 logarithm. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">log2</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_log2_float&quot;</span> <span class="Constant">&quot;caml_log2&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Base 2 logarithm.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">expm1</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_expm1_float&quot;</span> <span class="Constant">&quot;caml_expm1&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [expm1 <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] computes [<a href="complex.ml.html#L74" title="ocaml/stdlib/complex.ml:74">exp</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -. 1.0], giving numerically-accurate results<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; even if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> to [0.0]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">log1p</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_log1p_float&quot;</span> <span class="Constant">&quot;caml_log1p&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [log1p <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] computes [<a href="complex.ml.html#L77" title="ocaml/stdlib/complex.ml:77">log</a>(1.0 +. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)] (natural logarithm),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; giving numerically-accurate results even if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is <a href="out_channel.mli.html#L78" title="ocaml/stdlib/out_channel.mli:78">close</a> to [0.0]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">cos</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_cos_float&quot;</span> <span class="Constant">&quot;cos&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Cosine.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">sin</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_sin_float&quot;</span> <span class="Constant">&quot;sin&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Sine.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">tan</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_tan_float&quot;</span> <span class="Constant">&quot;tan&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Tangent.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">acos</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_acos_float&quot;</span> <span class="Constant">&quot;acos&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Arc cosine.&nbsp; The argument must fall within the range [[-1.0, 1.0]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [0.0] and [<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">asin</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_asin_float&quot;</span> <span class="Constant">&quot;asin&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Arc sine.&nbsp; The argument must fall within the range [[-1.0, 1.0]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [-<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>/2] and [<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>/2]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">atan</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_atan_float&quot;</span> <span class="Constant">&quot;atan&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Arc tangent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [-<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>/2] and [<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>/2]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">atan2</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_atan2_float&quot;</span> <span class="Constant">&quot;atan2&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [atan2 y <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns the arc tangent of [y /. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].&nbsp; The signs of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and [y] are used to determine the quadrant of the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [-<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>] and [<a href="float.ml.html#L43" title="ocaml/stdlib/float.ml:43">pi</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">hypot</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_hypot_float&quot;</span> <span class="Constant">&quot;caml_hypot&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [hypot <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns [<a href="complex.ml.html#L57" title="ocaml/stdlib/complex.ml:57">sqrt</a>(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> *. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> +. y *. y)], that is, the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; of the hypotenuse of <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="either.mli.html#L63" title="ocaml/stdlib/either.mli:63">right</a>-angled triangle with sides of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and [y], or, equivalently, the distance of the point [(<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>,y)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to origin.&nbsp; If <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or [y] is infinite, returns [<a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; even if the other is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">cosh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_cosh_float&quot;</span> <span class="Constant">&quot;cosh&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic cosine.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">sinh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_sinh_float&quot;</span> <span class="Constant">&quot;sinh&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic sine.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">tanh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_tanh_float&quot;</span> <span class="Constant">&quot;tanh&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic tangent.&nbsp; Argument is in radians. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">acosh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_acosh_float&quot;</span> <span class="Constant">&quot;caml_acosh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic arc cosine.&nbsp; The argument must fall within the range<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [[1.0, inf]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and is between [0.0] and [inf].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">asinh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_asinh_float&quot;</span> <span class="Constant">&quot;caml_asinh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic arc sine.&nbsp; The argument and <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> range over the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; real line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">atanh</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_atanh_float&quot;</span> <span class="Constant">&quot;caml_atanh&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Hyperbolic arc tangent.&nbsp; The argument must fall within the range<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [[-1.0, 1.0]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; Result is in radians and ranges over the entire real line.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">erf</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_erf_float&quot;</span> <span class="Constant">&quot;caml_erf&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Error function.&nbsp; The argument ranges over the entire real line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is always within [[-1.0, 1.0]].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">erfc</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_erfc_float&quot;</span> <span class="Constant">&quot;caml_erfc&quot;<br/></li>
<li></span>&nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Complementary <a href="result.ml.html#L19" title="ocaml/stdlib/result.ml:19">error</a> function ([erfc <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 1 - erf <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The argument ranges over the entire real line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is always within [[-1.0, 1.0]].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.13<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">trunc</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_trunc_float&quot;</span> <span class="Constant">&quot;caml_trunc&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [trunc <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] rounds [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] to the nearest integer whose absolute value is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; less than or <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">round</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_round_float&quot;</span> <span class="Constant">&quot;caml_round&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [round <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] rounds [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] to the nearest integer with ties (fractional<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; values of 0.5) rounded away from <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, regardless of the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a><br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; rounding direction.&nbsp; If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is an integer, [+0.], [-0.], [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], or<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; infinite, [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] itself is returned.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; On 64-bit mingw-w64, this function may be emulated owing to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> bug in the<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; C runtime library (CRT) on this platform.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">ceil</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_ceil_float&quot;</span> <span class="Constant">&quot;ceil&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Round above to an integer value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [ceil f] returns the least integer value greater than or <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is returned as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">floor</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_floor_float&quot;</span> <span class="Constant">&quot;floor&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** Round below to an integer value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [floor f] returns the greatest integer value less than or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [f].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; The <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> is returned as <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">next_after</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span>&nbsp; <span class="Statement">=</span> <span class="Constant">&quot;caml_nextafter_float&quot;</span> <span class="Constant">&quot;caml_nextafter&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [next_after <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns the next representable floating-point<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; value following [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in the direction of [y].&nbsp; More precisely, if<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [y] is greater (resp. less) than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], it returns the smallest<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; (resp. largest) representable number greater (resp. less) than [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] equals [y], the function returns [y].&nbsp; If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or [y] is<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] is returned.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Note that [next_after <a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a> <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a> = <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>] and that<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [next_after 0. <a href="stdlib.ml.html#L179" title="ocaml/stdlib/stdlib.ml:179">infinity</a>] is the smallest denormalized positive number.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is the smallest denormalized positive number,<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; [next_after <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> 0. = 0.]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">copy_sign</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span>&nbsp; <span class="Statement">=</span> <span class="Constant">&quot;caml_copysign_float&quot;</span> <span class="Constant">&quot;caml_copysign&quot;<br/></li>
<li></span><span class="Statement">[</span>@@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">]</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [copy_sign <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> whose absolute value is that of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and whose sign is that of [y].&nbsp; If [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], returns [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; If [y] is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], returns either [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or [-. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], but it is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; specified which. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">sign_bit</span> : <span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">])</span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span>&nbsp; <span class="Statement">=</span> <span class="Constant">&quot;caml_signbit_float&quot;</span> <span class="Constant">&quot;caml_signbit&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [sign_bit <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is [true] if and only if the sign bit of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; For example [sign_bit 1.] and [signbit 0.] are [false] while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [sign_bit (-1.)] and [sign_bit (-0.)] are [true].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">frexp</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">*</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_frexp_float&quot;<br/></li>
<li></span><span class="Comment">(** [frexp f] returns the pair of the significant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and the exponent of [f].&nbsp; When [f] is <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; significant [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and the exponent [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] of [f] are <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>.&nbsp; When [f] is non-<a href="int32.ml.html#L45" title="ocaml/stdlib/int32.ml:45">zero</a>, they are defined by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [f = <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> *. 2 ** <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] and [0.5 &lt;= <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> &lt; 1.0]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">ldexp</span> : <span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">])</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">untagged</span><span class="Statement">])</span> <span class="Statement">-&gt;</span> <span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">[</span>@<span class="ocamlLCIdentifier">unboxed</span><span class="Statement">])</span> <span class="Statement">=<br/></li>
<li></span>&nbsp; <span class="Constant">&quot;caml_ldexp_float&quot;</span> <span class="Constant">&quot;caml_ldexp_float_unboxed&quot;</span> <span class="Statement">[</span>@@<span class="ocamlLCIdentifier">noalloc</span><span class="Statement">]<br/></li>
<li></span><span class="Comment">(** [ldexp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> *. 2 ** <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">external</span> <span class="ocamlLCIdentifier">modf</span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">*</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">=</span> <span class="Constant">&quot;caml_modf_float&quot;<br/></li>
<li></span><span class="Comment">(** [modf f] returns the pair of the fractional and integral<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; part of [f]. *)<br/></li>
<li></span><br/></li>
<li><a id="L437">&#x200c;</a><span class="Statement">type</span> <span class="ocamlLCIdentifier"><span class="linkable">t</span></span> <span class="Statement">=</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** An alias for the type of floating-point numbers. *)<br/></li>
<li></span><br/></li>
<li><a id="L440">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">compare</span></span>: <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns [0] if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [y], <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> negative integer if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; is less than [y], and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> positive integer if [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [y]. [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] treats [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to itself and less than any other <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; value.&nbsp; This treatment of [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] ensures that [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>] defines <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ordering relation.&nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L447">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">equal</span></span>: <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="Comment">(** The <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> function for floating-point numbers, compared using {!<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L450">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">min</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L89" title="ocaml/stdlib/int32.ml:89">min</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns the minimum of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and [y].&nbsp; It returns [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; when [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or [y] is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>].&nbsp; Moreover [<a href="int32.ml.html#L89" title="ocaml/stdlib/int32.ml:89">min</a> (-0.) (+0.) = -0.]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L456">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">max</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** [<a href="int32.ml.html#L90" title="ocaml/stdlib/int32.ml:90">max</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns the maximum of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and [y].&nbsp; It returns [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; when [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] or [y] is [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>].&nbsp; Moreover [<a href="int32.ml.html#L90" title="ocaml/stdlib/int32.ml:90">max</a> (-0.) (+0.) = +0.]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L462">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">min_max</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">*</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L462" title="ocaml/stdlib/float.mli:462">min_max</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] is [(<a href="int32.ml.html#L89" title="ocaml/stdlib/int32.ml:89">min</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y, <a href="int32.ml.html#L90" title="ocaml/stdlib/int32.ml:90">max</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y)], just more efficient.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L467">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">min_num</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L467" title="ocaml/stdlib/float.mli:467">min_num</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns the minimum of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and [y] treating [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; missing values.&nbsp; If both [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and [y] are [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>], [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] is returned.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Moreover [<a href="#L467" title="ocaml/stdlib/float.mli:467">min_num</a> (-0.) (+0.) = -0.]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L474">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">max_num</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L474" title="ocaml/stdlib/float.mli:474">max_num</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] returns the maximum of [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and [y] treating [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] as<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; missing values.&nbsp; If both [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] and [y] are [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] [<a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a>] is returned.<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; Moreover [<a href="#L474" title="ocaml/stdlib/float.mli:474">max_num</a> (-0.) (+0.) = +0.]<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L481">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">min_max_num</span></span> : <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span> <span class="Statement">*</span> <span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="Comment">(** [<a href="#L481" title="ocaml/stdlib/float.mli:481">min_max_num</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] is [(<a href="#L467" title="ocaml/stdlib/float.mli:467">min_num</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y, <a href="#L474" title="ocaml/stdlib/float.mli:474">max_num</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y)], just more<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; efficient.&nbsp; Note that in particular [<a href="#L481" title="ocaml/stdlib/float.mli:481">min_max_num</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a> = (<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>, <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)]<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; and [<a href="#L481" title="ocaml/stdlib/float.mli:481">min_max_num</a> <a href="stdlib.ml.html#L183" title="ocaml/stdlib/stdlib.ml:183">nan</a> y = (y, y)].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp;&nbsp; @since 4.08 *)<br/></li>
<li></span><br/></li>
<li><a id="L488">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">seeded_hash</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** A seeded <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> function for floats, with the same <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> value as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Hashtbl.<a href="int32.ml.html#L108" title="ocaml/stdlib/int32.ml:108">seeded_hash</a>}. This function allows this module to be passed as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; argument to the functor {!Hashtbl.MakeSeeded}.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L495">&#x200c;</a><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">hash</span></span> : <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="Comment">(** An unseeded <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> function for floats, with the same <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> value as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {!Hashtbl.<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>}. This function allows this module to be passed as argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; to the functor {!Hashtbl.Make}. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> Array</span><span class="ocamlPreDef"> : </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">floatarray<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The type of <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> arrays with packed representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L506">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">length</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Return the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> (number of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>) of the given floatarray. *)<br/></li>
<li></span><br/></li>
<li><a id="L509">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">get</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns the element number [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] of floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is outside the range 0 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L514">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">set</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] modifies floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in place, replacing element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; number [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] with [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is outside the range 0 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L520">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">make</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>], initialized with [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L524">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">create</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; with uninitialized <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L529">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">init</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> f] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; with element number [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] initialized to the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of [f <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; In other terms, [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> f] tabulates the results of [f]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; applied to the integers [0] to [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L536">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">append</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a> v1 v2] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray containing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; concatenation of the floatarrays [v1] and [v2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> v1 + <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> v2 &gt; Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L542">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">concat</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a>}, but concatenates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of floatarrays. *)<br/></li>
<li></span><br/></li>
<li><a id="L545">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">sub</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; containing the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; of floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]; that is, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> &lt; 0], or [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &lt; 0], or [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &gt; <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L553">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">copy</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], that is, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; containing the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L557">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fill</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L121" title="ocaml/stdlib/bytesLabels.mli:121">fill</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] modifies the floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in place,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; storing [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L563">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">blit</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> src src_pos dst dst_pos <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] copies [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; from floatarray [src], starting at element number [src_pos],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to floatarray [dst], starting at element number [dst_pos].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; It works correctly even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [src] and [dst] are the same floatarray, and the source and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; destination chunks overlap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [src_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [src], or if [dst_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [dst]. *)<br/></li>
<li></span><br/></li>
<li><a id="L574">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_list</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns the list of all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L577">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">of_list</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray containing the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>].*)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Iterators} *)<br/></li>
<li></span><br/></li>
<li><a id="L585">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">iter</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] in turn to all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].&nbsp; It is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0); f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1); ()]. *)<br/></li>
<li></span><br/></li>
<li><a id="L590">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">iteri</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>}, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; function is applied with the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the element as first argument,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and the element itself as second argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L595">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and builds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]. *)<br/></li>
<li></span><br/></li>
<li><a id="L599">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map_inplace</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="array.mli.html#L163" title="ocaml/stdlib/array.mli:163">map_inplace</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and updates their values in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L604">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mapi</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the element as first argument,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and the element itself as second argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L609">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mapi_inplace</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="array.mli.html#L163" title="ocaml/stdlib/array.mli:163">map_inplace</a>}, but the function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; element as first argument, and the element itself as second argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L614">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fold_left</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f (... (f (f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(0)) <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(1)) ...) <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L619">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fold_right</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L191" title="ocaml/stdlib/bytesLabels.mli:191">fold_right</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0) (f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1) ( ... (f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1) <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>) ...))],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Iterators on two arrays} *)<br/></li>
<li></span><br/></li>
<li><a id="L626">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">iter2</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Array.<a href="seq.ml.html#L191" title="ocaml/stdlib/seq.ml:191">iter2</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and [b].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if the floatarrays are not the same <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L631">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map2</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and [b], and builds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [[| f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0) b.(0); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1) b.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> b - 1)|]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if the floatarrays are not the same <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Array scanning} *)<br/></li>
<li></span><br/></li>
<li><a id="L639">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">for_all</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> f [|<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|]] checks if all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the floatarray<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; satisfy the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) &amp;&amp; (f a2) &amp;&amp; ... &amp;&amp; (f an)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L644">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">exists</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> f [|<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|]] checks if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the floatarray satisfies the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) || (f a2) || ... || (f an)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L649">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mem</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] is true if and only if there is an element of [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; structurally <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. there is an [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; that [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 0]. *)<br/></li>
<li></span><br/></li>
<li><a id="L654">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mem_ieee</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a>}, but uses IEEE equality instead of structural equality. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Array searching} *)<br/></li>
<li></span><br/></li>
<li><a id="L659">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_opt</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(* [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns the first element of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] that satisfies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the predicate [f]. Returns [None] if there is no value that satisfies [f]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L665">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_index</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="seq.ml.html#L153" title="ocaml/stdlib/seq.ml:153">find_index</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns [Some <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>], where [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; element of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] that satisfies [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], if there is such an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; It returns [None] if there is no such element.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L673">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_map</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(* [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies [f] to the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in order, and returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the first <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the form [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], or [None] if <a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L678">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_mapi</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a>], but the predicate is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Sorting} *)<br/></li>
<li></span><br/></li>
<li><a id="L687">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">sort</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Sort <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray in increasing order according to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; function.&nbsp; The comparison function must <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> 0 if its arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> as <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> positive integer if the first is greater,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> negative integer if the first is smaller (see below for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; complete specification).&nbsp; For example, {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>} is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable comparison function.&nbsp; After calling [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>], the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; array is sorted in place in increasing order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>] is guaranteed to run in constant heap space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and (at most) logarithmic <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Heap Sort.&nbsp; It runs in constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Specification of the comparison function:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Let [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] be the floatarray and [cmp] the comparison function. The following<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; must be true for all [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], [y], [z] in [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] :<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] &gt; 0 if and only if [cmp y <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] &lt; 0<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; if [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] &gt;= 0 and [cmp y z] &gt;= 0 then [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> z] &gt;= 0<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; When [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>] returns, [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; reordered in such <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> way that for all <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> and j valid indices of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] :<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; [cmp <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(j)] &gt;= 0 if and only if <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> &gt;= j<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L712">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">stable_sort</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}, but the sorting algorithm is stable (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> that <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> are kept in their original order) and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; not guaranteed to run in constant heap space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Merge Sort. It uses <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>/2], where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; It is usually faster than the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation of {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L721">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fast_sort</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>} or {!<a href="array.mli.html#L317" title="ocaml/stdlib/array.mli:317">stable_sort</a>}, whichever is faster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; on typical <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Float arrays and Sequences} *)<br/></li>
<li></span><br/></li>
<li><a id="L727">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_seq</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Iterate on the floatarray, in increasing order. Modifications of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; floatarray during iteration will be reflected in the sequence. *)<br/></li>
<li></span><br/></li>
<li><a id="L731">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_seqi</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Iterate on the floatarray, in increasing order, yielding indices along<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. Modifications of the floatarray during iteration will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; reflected in the sequence. *)<br/></li>
<li></span><br/></li>
<li><a id="L736">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">of_seq</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Create an array from the generator. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L740">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map_to_array</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">array<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="#L740" title="ocaml/stdlib/float.mli:740">map_to_array</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and builds an array with the results returned by [f]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [[| f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0); f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1) |]]. *)<br/></li>
<li></span><br/></li>
<li><a id="L745">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map_from_array</span></span><span class="ocamlSig"> : </span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">array</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="#L745" title="ocaml/stdlib/float.mli:745">map_from_array</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and builds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1:floatarray_concurrency Arrays and concurrency safety}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Care must be taken when concurrently accessing <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> arrays from multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; domains: accessing an array will never crash <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> program, but unsynchronized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; accesses might yield surprising (non-sequentially-consistent) results.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; {2:floatarray_atomicity Atomicity}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Every <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array operation that accesses more than <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> array element is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; not atomic. This includes iteration, scanning, sorting, splitting and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; combining arrays.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; For example, consider the following program:<br/></li>
<li></span><span class="Comment">&nbsp; {[let <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> = 100_000_000<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> = Float.Array.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 1.<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> f () =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Float.Array.<a href="bytesLabels.mli.html#L170" title="ocaml/stdlib/bytesLabels.mli:170">iteri</a> (fun <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; Float.Array.<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> (f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; let d1 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (<a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> +. 1.))<br/></li>
<li></span><span class="Comment">&nbsp; let d2 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (<a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt;&nbsp; 2. *. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> +. 1.))<br/></li>
<li></span><span class="Comment">&nbsp; let () = Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; After executing this code, each <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> of the <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [2.], [3.], [4.] or [5.]. If atomicity is required, then the user must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; implement their own synchronization (for example, using {!Mutex.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>}).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; {2:floatarray_data_race Data races}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; If two domains only access <a href="set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a> parts of the array, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; observed behaviour is the equivalent to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sequential interleaving of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the operations from the two domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; A <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> race is said to occur when two domains access the same array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; element without synchronization and at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the accesses is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; write. In the absence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the observed behaviour is equivalent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sequential interleaving of the operations from different domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Whenever possible, <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races should be avoided by using synchronization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to mediate the accesses to the array <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Indeed, in the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, programs will not crash but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; observed behaviour may not be equivalent to any sequential interleaving of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; operations from different domains. Nevertheless, even in the presence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> read operation will <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the value of <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> prior write to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; that <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> few exceptions.<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; {2:floatarray_datarace_tearing Tearing }<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Float arrays have two supplementary caveats in the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; First, the <a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> operation might <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> an array byte-by-byte. Data races<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; between such <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> operation and another operation might produce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; surprising values due to tearing: partial writes interleaved with other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; operations can <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> values that would not exist with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; execution.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; For instance, at the end of<br/></li>
<li></span><span class="Comment">&nbsp; {[let zeros = Float.Array.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 0.<br/></li>
<li></span><span class="Comment">&nbsp; let max_floats = Float.Array.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> Float.<a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a><br/></li>
<li></span><span class="Comment">&nbsp; let <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> = Float.Array.<a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> zeros<br/></li>
<li></span><span class="Comment">&nbsp; let d1 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Float.Array.<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> zeros 0 <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> 0 <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>)<br/></li>
<li></span><span class="Comment">&nbsp; let d2 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Float.Array.<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> max_floats 0 <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> 0 <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>)<br/></li>
<li></span><span class="Comment">&nbsp; let () = Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; the [<a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a>] <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array might contain values that are neither [0.]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; nor [<a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Second, on 32-bit architectures, getting or setting <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> involves two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; separate memory accesses. In the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the user may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; observe tearing on any operation.<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(**/**)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Undocumented functions} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(* These functions are for system use only. Do not call directly. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">unsafe_get</span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_unsafe_get&quot;<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">unsafe_set</span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_unsafe_set&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">end<br/></li>
<li></span><span class="Comment">(** Float arrays with packed representation. *)<br/></li>
<li></span><br/></li>
<li><span class="Statement">module</span><span class="PreProc"> ArrayLabels</span><span class="ocamlPreDef"> : </span><span class="PreProc">sig<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">type</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">floatarray<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** The type of <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> arrays with packed representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 4.08<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L840">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">length</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Return the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> (number of <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>) of the given floatarray. *)<br/></li>
<li></span><br/></li>
<li><a id="L843">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">get</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns the element number [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] of floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is outside the range 0 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L848">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">set</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] modifies floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in place, replacing element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; number [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] with [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is outside the range 0 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L854">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">make</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>], initialized with [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L858">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">create</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; with uninitialized <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L863">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">init</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> ~f] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; with element number [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] initialized to the <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of [f <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; In other terms, [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> ~f] tabulates the results of [f]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; applied to the integers [0] to [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt; 0] or [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &gt; Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L870">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">append</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a> v1 v2] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray containing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; concatenation of the floatarrays [v1] and [v2].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> v1 + <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> v2 &gt; Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L876">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">concat</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="seq.ml.html#L30" title="ocaml/stdlib/seq.ml:30">append</a>}, but concatenates <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list of floatarrays. *)<br/></li>
<li></span><br/></li>
<li><a id="L879">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">sub</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span><span class="ocamlSig">:</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span><span class="ocamlSig">:</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="buffer.ml.html#L49" title="ocaml/stdlib/buffer.ml:49">sub</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; containing the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; of floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]; that is, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> &lt; 0], or [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &lt; 0], or [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> &gt; <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L887">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">copy</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], that is, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; containing the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L891">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fill</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a></span><span class="ocamlSig">:</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span><span class="ocamlSig">:</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L121" title="ocaml/stdlib/bytesLabels.mli:121">fill</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] modifies the floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in place,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; storing [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> number [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] to [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a> + <a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a> - 1].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [<a href="out_channel.mli.html#L133" title="ocaml/stdlib/out_channel.mli:133">pos</a>] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L897">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">blit</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">src</span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">src_pos</span><span class="ocamlSig">:</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">dst</span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">dst_pos</span><span class="ocamlSig">:</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a></span><span class="ocamlSig">:</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> ~src ~src_pos ~dst ~dst_pos ~<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] copies [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; from floatarray [src], starting at element number [src_pos],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to floatarray [dst], starting at element number [dst_pos].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; It works correctly even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [src] and [dst] are the same floatarray, and the source and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; destination chunks overlap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if [src_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [src], or if [dst_pos] and [<a href="list.ml.html#L404" title="ocaml/stdlib/list.ml:404">len</a>] do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; designate <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> valid subarray of [dst]. *)<br/></li>
<li></span><br/></li>
<li><a id="L908">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_list</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Type">list<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="camlinternalOO.ml.html#L191" title="ocaml/stdlib/camlinternalOO.ml:191">to_list</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns the list of all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L911">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">of_list</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Type">list</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="map.ml.html#L65" title="ocaml/stdlib/map.ml:65">of_list</a> <a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] returns <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> fresh floatarray containing the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] is greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [Sys.<a href="sys.mli.html#L195" title="ocaml/stdlib/sys.mli:195">max_floatarray_length</a>].*)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Iterators} *)<br/></li>
<li></span><br/></li>
<li><a id="L919">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">iter</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] in turn to all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].&nbsp; It is equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0); f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1); ()]. *)<br/></li>
<li></span><br/></li>
<li><a id="L924">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">iteri</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a>}, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; function is applied with the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the element as first argument,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and the element itself as second argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L929">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and builds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]. *)<br/></li>
<li></span><br/></li>
<li><a id="L933">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map_inplace</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="array.mli.html#L163" title="ocaml/stdlib/array.mli:163">map_inplace</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and updates their values in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L938">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mapi</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="bytesLabels.mli.html#L175" title="ocaml/stdlib/bytesLabels.mli:175">map</a>}, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the element as first argument,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and the element itself as second argument. *)<br/></li>
<li></span><br/></li>
<li><a id="L943">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mapi_inplace</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="array.mli.html#L163" title="ocaml/stdlib/array.mli:163">map_inplace</a>}, but the function is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; element as first argument, and the element itself as second argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L948">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fold_left</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L185" title="ocaml/stdlib/bytesLabels.mli:185">fold_left</a> ~f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> ~<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f (... (f (f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(0)) <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(1)) ...) <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>.(<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1)],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray [<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>]. *)<br/></li>
<li></span><br/></li>
<li><a id="L953">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fold_right</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a></span><span class="ocamlSig">:'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L126" title="ocaml/stdlib/camlinternalFormat.ml:126">acc</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L191" title="ocaml/stdlib/bytesLabels.mli:191">fold_right</a> f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>] computes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0) (f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1) ( ... (f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>-1) <a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a>) ...))],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Iterators on two arrays} *)<br/></li>
<li></span><br/></li>
<li><a id="L960">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">iter2</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [Array.<a href="seq.ml.html#L191" title="ocaml/stdlib/seq.ml:191">iter2</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and [b].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if the floatarrays are not the same <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. *)<br/></li>
<li></span><br/></li>
<li><a id="L965">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map2</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="seq.ml.html#L488" title="ocaml/stdlib/seq.ml:488">map2</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> b] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and [b], and builds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [[| f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0) b.(0); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1) b.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> b - 1)|]].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @raise Invalid_argument if the floatarrays are not the same <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Array scanning} *)<br/></li>
<li></span><br/></li>
<li><a id="L973">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">for_all</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L197" title="ocaml/stdlib/bytesLabels.mli:197">for_all</a> ~f [|<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|]] checks if all <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of the floatarray<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; satisfy the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) &amp;&amp; (f a2) &amp;&amp; ... &amp;&amp; (f an)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L978">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">exists</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="bytesLabels.mli.html#L201" title="ocaml/stdlib/bytesLabels.mli:201">exists</a> f [|<a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>; ...; an|]] checks if at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> element of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the floatarray satisfies the predicate [f]. That is, it returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [(f <a href="camlinternalFormat.ml.html#L657" title="ocaml/stdlib/camlinternalFormat.ml:657">a1</a>) || (f a2) || ... || (f an)]. *)<br/></li>
<li></span><br/></li>
<li><a id="L983">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mem</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> ~<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] is true if and only if there is an element of [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; structurally <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>], <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>. there is an [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] in [<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a>] such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; that [<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> = 0]. *)<br/></li>
<li></span><br/></li>
<li><a id="L988">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">mem_ieee</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a></span><span class="ocamlSig">:</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="ephemeron.mli.html#L99" title="ocaml/stdlib/ephemeron.mli:99">mem</a>}, but uses IEEE equality instead of structural equality. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Array searching} *)<br/></li>
<li></span><br/></li>
<li><a id="L993">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_opt</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(* [<a href="ephemeron.mli.html#L96" title="ocaml/stdlib/ephemeron.mli:96">find_opt</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns the first element of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] that satisfies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the predicate [f]. Returns [None] if there is no value that satisfies [f]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; in the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L999">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_index</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="seq.ml.html#L153" title="ocaml/stdlib/seq.ml:153">find_index</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] returns [Some <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>], where [<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>] is the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; element of the array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] that satisfies [f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], if there is such an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; element.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; It returns [None] if there is no such element.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L1007">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_map</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(* [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies [f] to the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] in order, and returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the first <a href="stdlib.ml.html#L246" title="ocaml/stdlib/stdlib.ml:246">result</a> of the form [Some <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>], or [None] if <a href="option.mli.html#L27" title="ocaml/stdlib/option.mli:27">none</a> exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><a id="L1012">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">find_mapi</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option</span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">option<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as [<a href="seq.ml.html#L161" title="ocaml/stdlib/seq.ml:161">find_map</a>], but the predicate is applied to the <a href="bytesLabels.mli.html#L219" title="ocaml/stdlib/bytesLabels.mli:219">index</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; the element as first argument (counting from 0), and the element<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; itself as second argument.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp;&nbsp; @since 5.1 *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Sorting} *)<br/></li>
<li></span><br/></li>
<li><a id="L1021">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">sort</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">cmp</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Sort <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray in increasing order according to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; function.&nbsp; The comparison function must <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> 0 if its arguments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> as <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a>, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> positive integer if the first is greater,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> negative integer if the first is smaller (see below for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; complete specification).&nbsp; For example, {!Stdlib.<a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a>} is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> suitable comparison function.&nbsp; After calling [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>], the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; array is sorted in place in increasing order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>] is guaranteed to run in constant heap space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and (at most) logarithmic <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Heap Sort.&nbsp; It runs in constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Specification of the comparison function:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Let [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] be the floatarray and [cmp] the comparison function. The following<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; must be true for all [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>], [y], [z] in [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] :<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] &gt; 0 if and only if [cmp y <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>] &lt; 0<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; if [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> y] &gt;= 0 and [cmp y z] &gt;= 0 then [cmp <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> z] &gt;= 0<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; When [<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>] returns, [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] <a href="bytesLabels.mli.html#L269" title="ocaml/stdlib/bytesLabels.mli:269">contains</a> the same <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> as <a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; reordered in such <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> way that for all <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> and j valid indices of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] :<br/></li>
<li></span><span class="Comment">&nbsp; -&nbsp; &nbsp; &nbsp; [cmp <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(j)] &gt;= 0 if and only if <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> &gt;= j<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><a id="L1046">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">stable_sort</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">cmp</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}, but the sorting algorithm is stable (<a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a>.<a href="camlinternalFormat.ml.html#L2118" title="ocaml/stdlib/camlinternalFormat.ml:2118">e</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> that <a href="int32.ml.html#L83" title="ocaml/stdlib/int32.ml:83">compare</a> <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> are kept in their original order) and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; not guaranteed to run in constant heap space.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; The <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation uses Merge Sort. It uses <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; floatarray of <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>/2], where [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] is the <a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> of the floatarray.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; It is usually faster than the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> implementation of {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>}. *)<br/></li>
<li></span><br/></li>
<li><a id="L1055">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">fast_sort</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">cmp</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Same as {!<a href="array.mli.html#L292" title="ocaml/stdlib/array.mli:292">sort</a>} or {!<a href="array.mli.html#L317" title="ocaml/stdlib/array.mli:317">stable_sort</a>}, whichever is faster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; on typical <a href="in_channel.ml.html#L69" title="ocaml/stdlib/in_channel.ml:69">input</a>. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Float arrays and Sequences} *)<br/></li>
<li></span><br/></li>
<li><a id="L1061">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_seq</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Iterate on the floatarray, in increasing order. Modifications of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; floatarray during iteration will be reflected in the sequence. *)<br/></li>
<li></span><br/></li>
<li><a id="L1065">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">to_seqi</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Statement">(</span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">*</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Iterate on the floatarray, in increasing order, yielding indices along<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>. Modifications of the floatarray during iteration will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; reflected in the sequence. *)<br/></li>
<li></span><br/></li>
<li><a id="L1070">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">of_seq</span></span><span class="ocamlSig"> : </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="PreProc">Seq</span><span class="ocamlSig">.</span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** Create an array from the generator. *)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L1074">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map_to_array</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">array<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="#L740" title="ocaml/stdlib/float.mli:740">map_to_array</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and builds an array with the results returned by [f]:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [[| f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(0); f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(1); ...; f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>.(<a href="buffer.ml.html#L71" title="ocaml/stdlib/buffer.ml:71">length</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> - 1) |]]. *)<br/></li>
<li></span><br/></li>
<li><a id="L1079">&#x200c;</a><span class="ocamlSig">&nbsp; </span><span class="Statement">val</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><span class="linkable">map_from_array</span></span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier">f</span><span class="ocamlSig">:</span><span class="Statement">(</span><span class="ocamlSig">'</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="Statement">)</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> '</span><span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span><span class="ocamlSig"> </span><span class="Type">array</span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Comment">(** [<a href="#L745" title="ocaml/stdlib/float.mli:745">map_from_array</a> ~f <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] applies function [f] to all the <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a> of [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; and builds <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> floatarray with the results returned by [f]. *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {1:floatarray_concurrency Arrays and concurrency safety}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Care must be taken when concurrently accessing <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> arrays from multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; domains: accessing an array will never crash <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> program, but unsynchronized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; accesses might yield surprising (non-sequentially-consistent) results.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; {2:floatarray_atomicity Atomicity}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Every <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array operation that accesses more than <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> array element is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; not atomic. This includes iteration, scanning, sorting, splitting and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; combining arrays.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; For example, consider the following program:<br/></li>
<li></span><span class="Comment">&nbsp; {[let <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> = 100_000_000<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> = Float.ArrayLabels.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 1.<br/></li>
<li></span><span class="Comment">&nbsp; let <a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> f () =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; Float.ArrayLabels.<a href="bytesLabels.mli.html#L170" title="ocaml/stdlib/bytesLabels.mli:170">iteri</a> ~f:(fun <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; Float.Array.<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="complex.ml.html#L22" title="ocaml/stdlib/complex.ml:22">i</a> (f <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>)) <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; let d1 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (<a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt; <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> +. 1.))<br/></li>
<li></span><span class="Comment">&nbsp; let d2 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (<a href="map.ml.html#L29" title="ocaml/stdlib/map.ml:29">update</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> (fun <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> -&gt;&nbsp; 2. *. <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> +. 1.))<br/></li>
<li></span><span class="Comment">&nbsp; let () = Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; After executing this code, each <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> of the <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array [<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>] is either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; [2.], [3.], [4.] or [5.]. If atomicity is required, then the user must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; implement their own synchronization (for example, using {!Mutex.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a>}).<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; {2:floatarray_data_race Data races}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; If two domains only access <a href="set.ml.html#L34" title="ocaml/stdlib/set.ml:34">disjoint</a> parts of the array, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; observed behaviour is the equivalent to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sequential interleaving of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; the operations from the two domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; A <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> race is said to occur when two domains access the same array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; element without synchronization and at least <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> of the accesses is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; write. In the absence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the observed behaviour is equivalent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sequential interleaving of the operations from different domains.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Whenever possible, <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races should be avoided by using synchronization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; to mediate the accesses to the array <a href="set.ml.html#L37" title="ocaml/stdlib/set.ml:37">elements</a>.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Indeed, in the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, programs will not crash but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; observed behaviour may not be equivalent to any sequential interleaving of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; operations from different domains. Nevertheless, even in the presence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> read operation will <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the value of <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> prior write to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; that <a href="printexc.ml.html#L206" title="ocaml/stdlib/printexc.ml:206">location</a> with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> few exceptions.<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; {2:floatarray_datarace_tearing Tearing }<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Float arrays have two supplementary caveats in the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; First, the <a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> operation might <a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> an array byte-by-byte. Data races<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; between such <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> operation and another operation might produce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; surprising values due to tearing: partial writes interleaved with other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; operations can <a href="buffer.ml.html#L40" title="ocaml/stdlib/buffer.ml:40">create</a> <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> values that would not exist with <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sequential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; execution.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; For instance, at the end of<br/></li>
<li></span><span class="Comment">&nbsp; {[let zeros = Float.Array.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> 0.<br/></li>
<li></span><span class="Comment">&nbsp; let max_floats = Float.Array.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a> Float.<a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a><br/></li>
<li></span><span class="Comment">&nbsp; let <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> = Float.Array.<a href="oo.mli.html#L20" title="ocaml/stdlib/oo.mli:20">copy</a> zeros<br/></li>
<li></span><span class="Comment">&nbsp; let d1 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Float.Array.<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> zeros 0 <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> 0 <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>)<br/></li>
<li></span><span class="Comment">&nbsp; let d2 = Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; Float.Array.<a href="buffer.ml.html#L55" title="ocaml/stdlib/buffer.ml:55">blit</a> max_floats 0 <a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a> 0 <a href="nativeint.ml.html#L47" title="ocaml/stdlib/nativeint.ml:47">size</a>)<br/></li>
<li></span><span class="Comment">&nbsp; let () = Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d1; Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> d2<br/></li>
<li></span><span class="Comment">&nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; the [<a href="camlinternalFormat.ml.html#L1333" title="ocaml/stdlib/camlinternalFormat.ml:1333">res</a>] <a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a> array might contain values that are neither [0.]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; nor [<a href="stdlib.ml.html#L185" title="ocaml/stdlib/stdlib.ml:185">max_float</a>].<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; Second, on 32-bit architectures, getting or setting <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="printexc.ml.html#L24" title="ocaml/stdlib/printexc.ml:24">field</a> involves two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; separate memory accesses. In the presence of <a href="weak.ml.html#L84" title="ocaml/stdlib/weak.ml:84">data</a> races, the user may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; observe tearing on any operation.<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(**/**)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(** {2 Undocumented functions} *)<br/></li>
<li></span><br/></li>
<li><span class="ocamlSig">&nbsp; </span><span class="Comment">(* These functions are for system use only. Do not call directly. *)<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">unsafe_get</span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_unsafe_get&quot;<br/></li>
<li></span><span class="ocamlSig">&nbsp; </span><span class="Statement">external</span><span class="ocamlSig"> </span><span class="ocamlLCIdentifier">unsafe_set</span><span class="ocamlSig"> : </span><span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type"><a href="random.mli.html#L78" title="ocaml/stdlib/random.mli:78">float</a></span><span class="ocamlSig"> </span><span class="Statement">-&gt;</span><span class="ocamlSig"> </span><span class="Type">unit</span><span class="ocamlSig"> </span><span class="Statement">=</span><span class="ocamlSig"> </span><span class="Constant">&quot;%floatarray_unsafe_set&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">end<br/></li>
<li></span><span class="Comment">(** Float arrays with packed representation (labeled functions). *)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
