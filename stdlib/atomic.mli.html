<!-- generated by the vscode.pl tool from vscoded.-->

<html>
 <head>
  <title>ocaml/stdlib/atomic.mli - ocaml</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

  <h1>ocaml/stdlib/atomic.mli - ocaml</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L46">compare_and_set</a></li>
<li><a href="#L56">decr</a></li>
<li><a href="#L39">exchange</a></li>
<li><a href="#L50">fetch_and_add</a></li>
<li><a href="#L33">get</a></li>
<li><a href="#L53">incr</a></li>
<li><a href="#L30">make</a></li>
<li><a href="#L36">set</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L27">t</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">(**************************************************************************)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OCaml&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Stephen Dolan, University of Cambridge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Gabriel Scherer, projet Partout, INRIA Paris-Saclay&nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2017-2018 University of Cambridge.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; Copyright 2020 Institut National de Recherche en Informatique et&nbsp; &nbsp;&nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp;&nbsp; en Automatique.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; All rights reserved.&nbsp; This <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> is distributed under the terms of&nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; the GNU Lesser General Public License version 2.1, with the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp;&nbsp; special exception on linking described in the <a href="digest.ml.html#L38" title="ocaml/stdlib/digest.ml:38">file</a> LICENSE.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br/></li>
<li></span><span class="Comment">(**************************************************************************)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Atomic references.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; See {{!examples} the examples} below.<br/></li>
<li></span><span class="Comment">&nbsp; See 'Memory model: The hard <a href="random.mli.html#L45" title="ocaml/stdlib/random.mli:45">bits</a>' chapter in the manual.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; @since 4.12<br/></li>
<li></span><span class="Comment">*)<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** An atomic (mutable) reference to <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> value of type ['<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a>]. *)<br/></li>
<li><a id="L27">&#x200c;</a></span><span class="Statement">type</span> <span class="Statement">!</span>'<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><span class="linkable">t</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Create an atomic reference. *)<br/></li>
<li><a id="L30">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">make</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Get the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> value of the atomic reference. *)<br/></li>
<li><a id="L33">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">get</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Set <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new value for the atomic reference. *)<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">set</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** Set <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> new value for the atomic reference, and <a href="seq.ml.html#L26" title="ocaml/stdlib/seq.ml:26">return</a> the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> value. *)<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">exchange</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">(** [<a href="#L46" title="ocaml/stdlib/atomic.mli:46">compare_and_set</a> <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> seen <a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] sets the new value of [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] to [<a href="lexing.ml.html#L131" title="ocaml/stdlib/lexing.ml:131">v</a>] only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; if its <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> value is physically <a href="int32.ml.html#L84" title="ocaml/stdlib/int32.ml:84">equal</a> to [seen] -- the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; comparison and the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> occur atomically. Returns [true] if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; comparison succeeded (so the <a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> happened) and [false]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; otherwise. *)<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">compare_and_set</span></span> : '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> '<span class="ocamlLCIdentifier"><a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">(** [<a href="#L50" title="ocaml/stdlib/atomic.mli:50">fetch_and_add</a> <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] atomically increments the value of [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] by [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>],<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; and returns the <a href="arg.ml.html#L121" title="ocaml/stdlib/arg.ml:121">current</a> value (<a href="arg.ml.html#L272" title="ocaml/stdlib/arg.ml:272">before</a> the increment). *)<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">fetch_and_add</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="Statement">-&gt;</span> <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">(** [<a href="atomic.ml.html#L25" title="ocaml/stdlib/atomic.ml:25">incr</a> <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] atomically increments the value of [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] by [1]. *)<br/></li>
<li><a id="L53">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">incr</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** [<a href="atomic.ml.html#L26" title="ocaml/stdlib/atomic.ml:26">decr</a> <a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] atomically decrements the value of [<a href="float.ml.html#L571" title="ocaml/stdlib/float.ml:571">r</a>] by [1]. *)<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="Statement">val</span> <span class="ocamlLCIdentifier"><span class="linkable">decr</span></span> : <span class="Type"><a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a></span> <span class="ocamlLCIdentifier"><a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a></span> <span class="Statement">-&gt;</span> <span class="Type">unit<br/></li>
<li></span><br/></li>
<li><span class="Comment">(** {1:examples Examples}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2 Basic Thread Coordination}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; A basic use case is to have global counters that are updated in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; thread-safe way, for example to keep <a href="option.mli.html#L30" title="ocaml/stdlib/option.mli:30">some</a> sorts of metrics<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; over IOs performed by the program. Another basic use case is to coordinate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the termination of threads in <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> given program, for example when <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> thread<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; finds an answer, or when the program is shut down by the user.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Here, for example, we're going to try to <a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number whose <a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; satisfies <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> basic property. To do that, we'll run multiple threads which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; will try random numbers until they <a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> that works.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Of course the <a href="out_channel.mli.html#L105" title="ocaml/stdlib/out_channel.mli:105">output</a> below is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> sample run and will change every time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; the program is run.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (* use for termination *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; let stop_all_threads = Atomic.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> false<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; (* total number of individual attempts to <a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; let num_attempts = Atomic.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> 0<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; (* <a href="ephemeron.mli.html#L95" title="ocaml/stdlib/ephemeron.mli:95">find</a> <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> number that satisfies [<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>], by... trying random numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; until <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> fits. *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; let find_number_where (<a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a>:<a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> -&gt; <a href="random.mli.html#L84" title="ocaml/stdlib/random.mli:84">bool</a>) =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let rand = Random.State.make_self_init() in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; while not (Atomic.<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> stop_all_threads) do<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; let <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> = Random.State.<a href="random.mli.html#L55" title="ocaml/stdlib/random.mli:55">full_int</a> rand <a href="int32.ml.html#L52" title="ocaml/stdlib/int32.ml:52">max_int</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; ignore (Atomic.<a href="#L50" title="ocaml/stdlib/atomic.mli:50">fetch_and_add</a> num_attempts 1 : <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a>);<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; if <a href="camlinternalFormat.ml.html#L1153" title="ocaml/stdlib/camlinternalFormat.ml:1153">p</a> (Hashtbl.<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>) then (<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Printf.<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;found %d (<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>=%d)\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>%!&quot; <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> (Hashtbl.<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Atomic.<a href="bigarray.mli.html#L544" title="ocaml/stdlib/bigarray.mli:544">set</a> stop_all_threads true; (* <a href="condition.mli.html#L163" title="ocaml/stdlib/condition.mli:163">signal</a> all threads to <a href="gc.mli.html#L527" title="ocaml/stdlib/gc.mli:527">stop</a> *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; )<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; done;;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">&nbsp; &nbsp; (* run multiple domains to search for <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> [<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>] where [<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a> <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt;= 100] *)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; let () =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let criterion <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> = <a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a> &lt;= 100 in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let threads =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; Array.<a href="bigarray.mli.html#L301" title="ocaml/stdlib/bigarray.mli:301">init</a> 8<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fun _ -&gt; Domain.<a href="domain.mli.html#L33" title="ocaml/stdlib/domain.mli:33">spawn</a> (fun () -&gt; find_number_where criterion))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Array.<a href="stack.ml.html#L57" title="ocaml/stdlib/stack.ml:57">iter</a> Domain.<a href="domain.mli.html#L40" title="ocaml/stdlib/domain.mli:40">join</a> threads;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; Printf.<a href="printf.mli.html#L129" title="ocaml/stdlib/printf.mli:129">printf</a> &quot;total number of attempts: %d\<a href="buffer.ml.html#L42" title="ocaml/stdlib/buffer.ml:42">n</a>%!&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; (Atomic.<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> num_attempts) ;;<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; - : unit = ()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; found 1651745641680046833 (<a href="int32.ml.html#L109" title="ocaml/stdlib/int32.ml:109">hash</a>=33)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; total number of attempts: 30230350<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ]}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {2 Treiber Stack}<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Another example is <a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> basic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; {{: https://en.wikipedia.org/wiki/Treiber_stack} Treiber <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a>}<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> thread-safe <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a>) that can be safely shared between threads.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Note how both [<a href="stack.ml.html#L26" title="ocaml/stdlib/stack.ml:26">push</a>] and [<a href="stack.ml.html#L28" title="ocaml/stdlib/stack.ml:28">pop</a>] are recursive, because they attempt to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; swap the new <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> (with <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> more, or <a href="int32.ml.html#L46" title="ocaml/stdlib/int32.ml:46">one</a> fewer, element) with the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; This is optimistic concurrency: each iteration of, say, [<a href="stack.ml.html#L26" title="ocaml/stdlib/stack.ml:26">push</a> <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; gets the old <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>], and hopes that by the time it tries to <a href="ephemeron.mli.html#L98" title="ocaml/stdlib/ephemeron.mli:98">replace</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>] with [<a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a>::<a href="array.ml.html#L356" title="ocaml/stdlib/array.ml:356">l</a>], nobody else has had time to modify the list. If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; [<a href="#L46" title="ocaml/stdlib/atomic.mli:46">compare_and_set</a>] fails it means we were too optimistic, and must try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; again.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; {[<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; type '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> = '<a href="camlinternalFormat.ml.html#L73" title="ocaml/stdlib/camlinternalFormat.ml:73">a</a> list Atomic.<a href="sys.mli.html#L427" title="ocaml/stdlib/sys.mli:427">t</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; let rec <a href="stack.ml.html#L26" title="ocaml/stdlib/stack.ml:26">push</a> (<a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a>: _ <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a>) <a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a> : unit =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let cur = Atomic.<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let <a href="stdlib.ml.html#L569" title="ocaml/stdlib/stdlib.ml:569">success</a> = Atomic.<a href="#L46" title="ocaml/stdlib/atomic.mli:46">compare_and_set</a> <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> cur (<a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a> :: cur) in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; if not <a href="stdlib.ml.html#L569" title="ocaml/stdlib/stdlib.ml:569">success</a> then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; <a href="stack.ml.html#L26" title="ocaml/stdlib/stack.ml:26">push</a> <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> <a href="set.ml.html#L26" title="ocaml/stdlib/set.ml:26">elt</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; let rec <a href="stack.ml.html#L28" title="ocaml/stdlib/stack.ml:28">pop</a> (<a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a>: _ <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a>) : _ option =<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; let cur = Atomic.<a href="bigarray.mli.html#L541" title="ocaml/stdlib/bigarray.mli:541">get</a> <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; match cur with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; | [] -&gt; None<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; | <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a> :: tail -&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; let <a href="stdlib.ml.html#L569" title="ocaml/stdlib/stdlib.ml:569">success</a> = Atomic.<a href="#L46" title="ocaml/stdlib/atomic.mli:46">compare_and_set</a> <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a> cur tail in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; if <a href="stdlib.ml.html#L569" title="ocaml/stdlib/stdlib.ml:569">success</a> then Some <a href="camlinternalFormat.ml.html#L918" title="ocaml/stdlib/camlinternalFormat.ml:918">x</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; else <a href="stack.ml.html#L28" title="ocaml/stdlib/stack.ml:28">pop</a> <a href="effect.ml.html#L39" title="ocaml/stdlib/effect.ml:39">stack</a><br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; # let st = Atomic.<a href="bytesLabels.mli.html#L75" title="ocaml/stdlib/bytesLabels.mli:75">make</a> []<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; # <a href="stack.ml.html#L26" title="ocaml/stdlib/stack.ml:26">push</a> st 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - : unit = ()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; # <a href="stack.ml.html#L26" title="ocaml/stdlib/stack.ml:26">push</a> st 2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - : unit = ()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; # <a href="stack.ml.html#L28" title="ocaml/stdlib/stack.ml:28">pop</a> st<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - : <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> option = Some 2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; # <a href="stack.ml.html#L28" title="ocaml/stdlib/stack.ml:28">pop</a> st<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - : <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> option = Some 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; # <a href="stack.ml.html#L28" title="ocaml/stdlib/stack.ml:28">pop</a> st<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; - : <a href="bigarray.mli.html#L176" title="ocaml/stdlib/bigarray.mli:176">int</a> option = None<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; ]}<br/></li>
<li></span><span class="Comment">&nbsp; *)<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="index.html">Top Level</a></span>
 </p>

 </body>
</html>
